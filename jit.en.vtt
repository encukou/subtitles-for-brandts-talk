WEBVTT
Kind: captions
Language: en

00:06.480 --> 00:08.880 align:start position:0%
all right it's time

00:08.880 --> 00:16.279 align:start position:0%
for Brandt and his talk!

00:16.279 --> 00:18.840 align:start position:0%
All right so instead of giving this

00:18.840 --> 00:20.199 align:start position:0%
talk tomorrow -- by the way can everyone

00:20.199 --> 00:23.279 align:start position:0%
hear me? Okay cool. So, instead of

00:23.279 --> 00:24.560 align:start position:0%
giving this talk tomorrow I'm giving it

00:24.560 --> 00:26.840 align:start position:0%
today. I'm going to be sharing a

00:26.840 --> 00:28.760 align:start position:0%
little bit about something I have been

00:28.760 --> 00:30.400 align:start position:0%
thinking quite a bit about for last few

00:30.400 --> 00:32.840 align:start position:0%
months which is what Python's future JIT

00:32.840 --> 00:35.440 align:start position:0%
compiler might look like. Or, CPython's

00:35.440 --> 00:38.079 align:start position:0%
future JIT compiler, specifically.

00:38.079 --> 00:39.360 align:start position:0%
So I'm going to start with some

00:39.360 --> 00:42.079 align:start position:0%
background and this will also

00:42.079 --> 00:43.559 align:start position:0%
be good background for Ken's talk

00:43.559 --> 00:45.280 align:start position:0%
immediately after this, on

00:45.280 --> 00:47.440 align:start position:0%
optimizations that we hope to perform.

00:47.440 --> 00:50.440 align:start position:0%
Specifically, I'm mostly going to be

00:50.440 --> 00:52.000 align:start position:0%
talking about some experiments

00:52.000 --> 00:54.280 align:start position:0%
that I've done with actually generating

00:54.280 --> 00:56.600 align:start position:0%
and executing machine code, not

00:56.600 --> 00:58.280 align:start position:0%
necessarily optimizations and things

00:58.280 --> 01:00.120 align:start position:0%
that happen in the meantime. However, I

01:00.120 --> 01:01.680 align:start position:0%
will be giving some background on that

01:01.680 --> 01:03.120 align:start position:0%
because I think it's really helpful for

01:03.120 --> 01:04.880 align:start position:0%
understanding how everything ties

01:04.880 --> 01:07.799 align:start position:0%
together. So, a little recent history:

01:07.799 --> 01:09.560 align:start position:0%
In CPython

01:09.560 --> 01:11.720 align:start position:0%
3.11, one of the headline features was

01:11.720 --> 01:14.880 align:start position:0%
the specializing adaptive interpreter.

01:14.880 --> 01:17.400 align:start position:0%
This delivered really good

01:17.400 --> 01:19.080 align:start position:0%
speedups; I think the number we quoted

01:19.080 --> 01:22.200 align:start position:0%
most widely was something like 25%. If

01:22.200 --> 01:24.040 align:start position:0%
you want to take that at face value, that

01:24.040 --> 01:26.240 align:start position:0%
it was just a one-time performance gain

01:26.240 --> 01:29.640 align:start position:0%
that was nice to have, then sure, but

01:29.640 --> 01:31.400 align:start position:0%
if you think about it and you read a

01:31.400 --> 01:32.600 align:start position:0%
little bit between the lines you

01:32.600 --> 01:33.799 align:start position:0%
understand that we're now collecting

01:33.799 --> 01:37.520 align:start position:0%
runtime profiling data for user code.

01:37.520 --> 01:38.600 align:start position:0%
And that's something that we can use

01:38.600 --> 01:40.640 align:start position:0%
later if we want to lower that code and

01:40.640 --> 01:42.280 align:start position:0%
make it more statically typed.

01:42.280 --> 01:46.159 align:start position:0%
In CPython 3.12, we got a nice

01:46.159 --> 01:47.840 align:start position:0%
quality of life improvement as

01:47.840 --> 01:50.600 align:start position:0%
maintainers. We started generating the

01:50.600 --> 01:53.520 align:start position:0%
interpreter cases, the main `switch`, from a

01:53.520 --> 01:55.759 align:start position:0%
domain specific language. This

01:55.759 --> 01:59.920 align:start position:0%
allowed us to analyze and modify

01:59.920 --> 02:01.240 align:start position:0%
parts of the interpreter at build

02:01.240 --> 02:03.840 align:start position:0%
time. This is really helpful for the

02:03.840 --> 02:05.840 align:start position:0%
people actually working on the bytecode,

02:05.840 --> 02:09.840 align:start position:0%
because we can worry less about

02:09.840 --> 02:12.560 align:start position:0%
things like error handling, reference

02:12.560 --> 02:17.440 align:start position:0%
counts, adding counters,

02:17.440 --> 02:19.480 align:start position:0%
stats, and all those sorts of things.

02:19.480 --> 02:21.400 align:start position:0%
But at the same time, again if you can

02:21.400 --> 02:23.160 align:start position:0%
kind of read between the lines, we now

02:23.160 --> 02:24.440 align:start position:0%
are able to generate multiple

02:24.440 --> 02:26.160 align:start position:0%
interpreters from a single source of

02:26.160 --> 02:29.160 align:start position:0%
truth. And we also are able to

02:29.160 --> 02:31.239 align:start position:0%
generate lots of metadata by

02:31.239 --> 02:33.319 align:start position:0%
analyzing that single source of

02:33.319 --> 02:35.480 align:start position:0%
truth. So in

02:35.480 --> 02:38.040 align:start position:0%
3.13 – and again this is all stuff

02:38.040 --> 02:40.760 align:start position:0%
that's actually currently on main – we

02:40.760 --> 02:42.680 align:start position:0%
do have an internal pipeline for

02:42.680 --> 02:45.360 align:start position:0%
detecting, optimizing, and executing hot

02:45.360 --> 02:47.840 align:start position:0%
code paths. This is off by default, but

02:47.840 --> 02:50.239 align:start position:0%
if you build Python and you set the

02:50.239 --> 02:51.599 align:start position:0%
right environment variable or pass the

02:51.599 --> 02:54.959 align:start position:0%
right -X option – it's called µops,

02:54.959 --> 02:59.560 align:start position:0%
`-X uops` – basically, CPython will find

02:59.560 --> 03:02.239 align:start position:0%
hot loops in your code, it will

03:02.239 --> 03:05.440 align:start position:0%
build a trace of that loop,

03:05.440 --> 03:08.840 align:start position:0%
and it will break it up into a more

03:08.840 --> 03:09.799 align:start position:0%
efficient

03:09.799 --> 03:12.799 align:start position:0%
representation, and optimize it – do

03:12.799 --> 03:15.120 align:start position:0%
some light optimization – and execute it

03:15.120 --> 03:18.440 align:start position:0%
in a second interpreter. Now, currently,

03:18.440 --> 03:19.720 align:start position:0%
this is actually a little bit slower.

03:19.720 --> 03:21.000 align:start position:0%
You don't want to turn it on. It's like

03:21.000 --> 03:22.920 align:start position:0%
5% or 6% slower, just because it's

03:22.920 --> 03:24.920 align:start position:0%
kind of the first phase of this entire

03:24.920 --> 03:27.360 align:start position:0%
pipeline, and in the end the

03:27.360 --> 03:29.519 align:start position:0%
interpreter isn't really what we want to

03:29.519 --> 03:32.040 align:start position:0%
be executing these things. I'll get to

03:32.040 --> 03:34.040 align:start position:0%
that later. Basically, this

03:34.040 --> 03:35.280 align:start position:0%
wouldn't be possible without either of

03:35.280 --> 03:37.480 align:start position:0%
the first two steps. Being able to

03:37.480 --> 03:39.560 align:start position:0%
break big complicated bytecode

03:39.560 --> 03:41.239 align:start position:0%
instructions down into more simple

03:41.239 --> 03:43.760 align:start position:0%
atomic steps is only possible because of

03:43.760 --> 03:46.599 align:start position:0%
the changes made in 3.11 for

03:46.599 --> 03:49.040 align:start position:0%
specialization, and in 3.12 where we're

03:49.040 --> 03:51.720 align:start position:0%
able to define bytecode

03:51.720 --> 03:54.640 align:start position:0%
instructions in terms of smaller

03:54.640 --> 03:58.400 align:start position:0%
steps. So, I like providing examples,

03:58.400 --> 03:59.840 align:start position:0%
just so we can walk through what

03:59.840 --> 04:01.280 align:start position:0%
this pipeline looks like in practice and

04:01.280 --> 04:02.599 align:start position:0%
what it may look like in the future. So,

04:02.599 --> 04:03.879 align:start position:0%
we're going to look at my Fibonacci

04:03.879 --> 04:05.760 align:start position:0%
function here. It's pretty

04:05.760 --> 04:07.319 align:start position:0%
straightforward, and specifically, we're

04:07.319 --> 04:09.640 align:start position:0%
going to focus on the inner loop. It's

04:09.640 --> 04:11.280 align:start position:0%
pretty simple: we're looping over

04:11.280 --> 04:13.280 align:start position:0%
the range and then we update the values

04:13.280 --> 04:16.440 align:start position:0%
for `a` and `b` by adding `a` and `b`

04:16.440 --> 04:19.079 align:start position:0%
together. If you look at the bytecode

04:19.079 --> 04:20.359 align:start position:0%
for this function, it'll look

04:20.359 --> 04:25.120 align:start position:0%
something like this.

04:25.120 --> 04:27.199 align:start position:0%
If you want to know how the bytecode

04:27.199 --> 04:28.639 align:start position:0%
works you can look at the `dis`

04:28.639 --> 04:30.520 align:start position:0%
documentation. Basically, these are

04:30.520 --> 04:33.919 align:start position:0%
generic instructions that have mostly

04:33.919 --> 04:35.800 align:start position:0%
remained unchanged since the earliest

04:35.800 --> 04:37.199 align:start position:0%
versions of

04:37.199 --> 04:40.560 align:start position:0%
Python. However, in 3.11, we got our

04:40.560 --> 04:43.080 align:start position:0%
specialized bytecode. That took

04:43.080 --> 04:45.120 align:start position:0%
generic operations like FOR_ITER and

04:45.120 --> 04:48.360 align:start position:0%
BINARY_OP and allowed us to specialize

04:48.360 --> 04:50.000 align:start position:0%
those at runtime, for example, for

04:50.000 --> 04:52.520 align:start position:0%
iterating over a range object or adding

04:52.520 --> 04:54.360 align:start position:0%
two integers

04:54.360 --> 04:58.759 align:start position:0%
together. That's great. Now, in

04:58.759 --> 05:02.600 align:start position:0%
3.13 we're building micro-op traces.

05:02.600 --> 05:04.360 align:start position:0%
These micro-ops are those smaller,

05:04.360 --> 05:06.000 align:start position:0%
more atomic steps that I was talking

05:06.000 --> 05:07.199 align:start position:0%
about that we're able to break

05:07.199 --> 05:11.360 align:start position:0%
individual instructions up into.

05:11.360 --> 05:13.240 align:start position:0%
As I mentioned before, you can actually

05:13.240 --> 05:15.560 align:start position:0%
run these things off of main by passing

05:15.560 --> 05:18.759 align:start position:0%
`-X uops`, and when you do

05:18.759 --> 05:20.600 align:start position:0%
that we will collect a trace for this

05:20.600 --> 05:22.440 align:start position:0%
loop and we'll actually break each of

05:22.440 --> 05:25.160 align:start position:0%
these instructions up into their

05:25.160 --> 05:26.840 align:start position:0%
individual components. You can see

05:26.840 --> 05:28.280 align:start position:0%
that for some of the simpler

05:28.280 --> 05:30.479 align:start position:0%
instructions, they may only expand

05:30.479 --> 05:32.960 align:start position:0%
to two micro-ops (and that's what we

05:32.960 --> 05:35.440 align:start position:0%
call them, micro-ops), but the more

05:35.440 --> 05:38.319 align:start position:0%
complicated ones, like FOR_ITER_RANGE or

05:38.319 --> 05:40.240 align:start position:0%
the integer addition, may have several

05:40.240 --> 05:42.479 align:start position:0%
different parts. And what's nice about

05:42.479 --> 05:44.479 align:start position:0%
breaking those parts up is that if any

05:44.479 --> 05:45.919 align:start position:0%
of the parts are redundant, for example

05:45.919 --> 05:47.080 align:start position:0%
if we're checking that something's an

05:47.080 --> 05:48.680 align:start position:0%
integer when we can actually prove that

05:48.680 --> 05:51.520 align:start position:0%
it's an integer, then we can remove it.

05:51.520 --> 05:53.319 align:start position:0%
Or if we want to move things around,

05:53.319 --> 05:55.000 align:start position:0%
that's an option as

05:55.000 --> 05:59.600 align:start position:0%
well. So another thing that 3.13

05:59.600 --> 06:01.720 align:start position:0%
main will currently do for you is we'll

06:01.720 --> 06:03.280 align:start position:0%
do some light optimization on these

06:03.280 --> 06:05.120 align:start position:0%
micro-ops. Currently, the only

06:05.120 --> 06:07.800 align:start position:0%
optimization we perform is we'll find

06:07.800 --> 06:09.720 align:start position:0%
redundant frame pointer updates.

06:09.720 --> 06:11.840 align:start position:0%
Basically, if we have an operation that

06:11.840 --> 06:14.280 align:start position:0%
cannot fail, or the control flow cannot

06:14.280 --> 06:16.280 align:start position:0%
move to any other point in the

06:16.280 --> 06:18.680 align:start position:0%
program, there's no reason for us to

06:18.680 --> 06:20.039 align:start position:0%
update the frame and say “oh we're

06:20.039 --> 06:22.199 align:start position:0%
currently executing this instruction”.

06:22.199 --> 06:24.199 align:start position:0%
It's a very very simple optimization,

06:24.199 --> 06:25.880 align:start position:0%
but it does work as a nice proof of

06:25.880 --> 06:28.000 align:start position:0%
concept. So, we will actually

06:28.000 --> 06:30.599 align:start position:0%
identify these four _SET_IP

06:30.599 --> 06:32.800 align:start position:0%
instructions, and just remove them for

06:32.800 --> 06:35.080 align:start position:0%
you. That's just pure overhead that

06:35.080 --> 06:36.319 align:start position:0%
we're able to

06:36.319 --> 06:39.039 align:start position:0%
remove. In the future, and Ken will talk a

06:39.039 --> 06:40.440 align:start position:0%
little bit more about this, we'll be able

06:40.440 --> 06:42.919 align:start position:0%
to do stronger optimizations, where

06:42.919 --> 06:44.560 align:start position:0%
we're able to remove more expensive

06:44.560 --> 06:46.800 align:start position:0%
checks. For instance, if we can

06:46.800 --> 06:48.520 align:start position:0%
statically prove (as we can in the case

06:48.520 --> 06:50.800 align:start position:0%
of this function) that, for example, we're

06:50.800 --> 06:52.479 align:start position:0%
always iterating over a range object

06:52.479 --> 06:54.479 align:start position:0%
once we've entered this loop, and that

06:54.479 --> 06:56.400 align:start position:0%
`a` and `b` are both integers once we've

06:56.400 --> 06:58.080 align:start position:0%
entered this loop, then we can also

06:58.080 --> 07:00.560 align:start position:0%
remove those as well, and what's left is

07:00.560 --> 07:02.199 align:start position:0%
basically the bare minimum amount of

07:02.199 --> 07:05.280 align:start position:0%
work required to actually execute

07:05.280 --> 07:06.960 align:start position:0%
this hot inner loop. And you'll notice

07:06.960 --> 07:08.759 align:start position:0%
that this is entirely statically typed,

07:08.759 --> 07:10.759 align:start position:0%
which is great for further

07:10.759 --> 07:14.000 align:start position:0%
lowering. So, once we've removed all of

07:14.000 --> 07:15.960 align:start position:0%
that extra stuff that we can

07:15.960 --> 07:19.000 align:start position:0%
prove we don't actually need, then comes

07:19.000 --> 07:20.800 align:start position:0%
just-in-time compilation. And that's

07:20.800 --> 07:21.800 align:start position:0%
what I'm going to spend the rest of

07:21.800 --> 07:23.440 align:start position:0%
this time talking

07:23.440 --> 07:25.879 align:start position:0%
about. We have a couple different

07:25.879 --> 07:28.000 align:start position:0%
goals with the just-in-time compilation.

07:28.000 --> 07:31.120 align:start position:0%
Our main overarching goal is to

07:31.120 --> 07:33.680 align:start position:0%
remove interpretive overhead. So, we have

07:33.680 --> 07:37.039 align:start position:0%
removed all the extra dynamic

07:37.039 --> 07:39.599 align:start position:0%
work that needs to take place, but

07:39.599 --> 07:42.280 align:start position:0%
there's still a lot of other

07:42.280 --> 07:43.919 align:start position:0%
overhead that just comes from the way

07:43.919 --> 07:46.280 align:start position:0%
the virtual machine is laid out and

07:46.280 --> 07:49.759 align:start position:0%
the way it interacts with data. We

07:49.759 --> 07:51.520 align:start position:0%
want to remove interpretive overhead by

07:51.520 --> 07:53.639 align:start position:0%
statically compiling these optimized

07:53.639 --> 07:56.319 align:start position:0%
traces, and statically compiling them

07:56.319 --> 07:59.840 align:start position:0%
allows to us to reduce indirection

07:59.840 --> 08:01.639 align:start position:0%
through a few different ways. First of

08:01.639 --> 08:05.199 align:start position:0%
all, we can burn in – basically,

08:05.199 --> 08:07.879 align:start position:0%
encode directly into the machine code –

08:07.879 --> 08:10.599 align:start position:0%
the values of constants, caches and

08:10.599 --> 08:13.440 align:start position:0%
arguments to instructions. So basically,

08:13.440 --> 08:16.080 align:start position:0%
instead of decoding an

08:16.080 --> 08:18.720 align:start position:0%
instruction's oparg every single time

08:18.720 --> 08:20.800 align:start position:0%
we execute that instruction, we can

08:20.800 --> 08:23.000 align:start position:0%
instead, for example, make it an immediate

08:23.000 --> 08:26.159 align:start position:0%
value to an instruction in actual

08:26.159 --> 08:29.560 align:start position:0%
machine code, which replaces a

08:29.560 --> 08:31.280 align:start position:0%
memory load, is a lot more compact, and a

08:31.280 --> 08:32.159 align:start position:0%
lot more

08:32.159 --> 08:34.599 align:start position:0%
efficient. We can also do things like

08:34.599 --> 08:36.320 align:start position:0%
moving data off of frames and into

08:36.320 --> 08:39.360 align:start position:0%
registers. The micro-ops still execute

08:39.360 --> 08:41.640 align:start position:0%
on a Python frame, which means that

08:41.640 --> 08:43.360 align:start position:0%
intermediate values that live on the

08:43.360 --> 08:46.519 align:start position:0%
value stack are all still being written

08:46.519 --> 08:48.920 align:start position:0%
to memory and read from memory. If

08:48.920 --> 08:50.680 align:start position:0%
we can lift all of that stuff out of

08:50.680 --> 08:52.600 align:start position:0%
memory and into actual hardware

08:52.600 --> 08:55.360 align:start position:0%
registers, that saves a lot of traffic

08:55.360 --> 08:57.519 align:start position:0%
to and from main memory, which is

08:57.519 --> 08:59.680 align:start position:0%
always a good thing. Finally, we can

08:59.680 --> 09:01.640 align:start position:0%
bring hot code paths inline, so instead

09:01.640 --> 09:04.480 align:start position:0%
of having a large interpreter where

09:04.480 --> 09:06.720 align:start position:0%
we have all of these different cases

09:06.720 --> 09:08.279 align:start position:0%
that all need to be present because we

09:08.279 --> 09:10.880 align:start position:0%
can jump into them at any time, here

09:10.880 --> 09:12.640 align:start position:0%
we can make a straight line code path

09:12.640 --> 09:14.959 align:start position:0%
that executes exactly those instructions

09:14.959 --> 09:16.640 align:start position:0%
that I showed on the previous

09:16.640 --> 09:19.000 align:start position:0%
slide. Now, these need to be weighed

09:19.000 --> 09:22.800 align:start position:0%
against some practical goals, right?

09:22.800 --> 09:24.640 align:start position:0%
I don't think anyone wants me to

09:24.640 --> 09:27.720 align:start position:0%
dump a 10_000 line C++ JIT on us,

09:27.720 --> 09:30.800 align:start position:0%
right? So, the first thing is broad

09:30.800 --> 09:32.640 align:start position:0%
platform support. Python runs on lots of

09:32.640 --> 09:35.000 align:start position:0%
places and our JIT should too. I think

09:35.000 --> 09:36.440 align:start position:0%
that this is an ambitious goal, but it's

09:36.440 --> 09:39.959 align:start position:0%
an important one. I think that it

09:39.959 --> 09:42.240 align:start position:0%
should have few runtime dependencies, for

09:42.240 --> 09:45.519 align:start position:0%
example, I would like for this JIT to be

09:45.519 --> 09:48.279 align:start position:0%
in a place where, for example, users

09:48.279 --> 09:50.680 align:start position:0%
wouldn't need to have a full LLVM

09:50.680 --> 09:53.040 align:start position:0%
install. I don't think

09:53.040 --> 09:55.120 align:start position:0%
that's a good user experience. It can

09:55.120 --> 09:56.680 align:start position:0%
maybe be made into a good user

09:56.680 --> 09:58.839 align:start position:0%
experience, but I think I'd rather start

09:58.839 --> 10:01.120 align:start position:0%
from a place where you just download

10:01.120 --> 10:03.120 align:start position:0%
Python the same way as you always have

10:03.120 --> 10:04.600 align:start position:0%
and everything just

10:04.600 --> 10:07.760 align:start position:0%
works. And finally, and perhaps most

10:07.760 --> 10:10.120 align:start position:0%
importantly to me, low implementation

10:10.120 --> 10:12.480 align:start position:0%
complexity. CPython is

10:12.480 --> 10:14.920 align:start position:0%
overwhelmingly maintained by volunteers,

10:14.920 --> 10:18.640 align:start position:0%
and so I think that being able to

10:18.640 --> 10:22.120 align:start position:0%
keep the complexity down is a really

10:22.120 --> 10:24.279 align:start position:0%
really important goal to keep in mind. In

10:24.279 --> 10:27.000 align:start position:0%
fact, I personally feel like it's

10:27.000 --> 10:28.760 align:start position:0%
worth sacrificing peak performance in

10:28.760 --> 10:30.880 align:start position:0%
order to keep the implementation as

10:30.880 --> 10:33.120 align:start position:0%
simple, easy to maintain, and easy to

10:33.120 --> 10:35.480 align:start position:0%
understand and teach and learn as

10:35.480 --> 10:38.760 align:start position:0%
possible. So, these are competing

10:38.760 --> 10:41.000 align:start position:0%
goals, right? We want to make things

10:41.000 --> 10:43.600 align:start position:0%
fast but we're also willing to, as I said,

10:43.600 --> 10:45.639 align:start position:0%
sacrifice peak performance to make sure

10:45.639 --> 10:48.160 align:start position:0%
that this is something that we

10:48.160 --> 10:50.880 align:start position:0%
can all understand and that we can

10:50.880 --> 10:52.600 align:start position:0%
all maintain for the long

10:52.600 --> 10:57.880 align:start position:0%
haul. So, one recent

10:57.880 --> 11:01.399 align:start position:0%
development in JIT compiler

11:01.399 --> 11:03.680 align:start position:0%
technology is something called copy-and-

11:03.680 --> 11:05.120 align:start position:0%
-patch compilation, and it actually

11:05.120 --> 11:07.000 align:start position:0%
fulfills many of these goals in a really

11:07.000 --> 11:09.480 align:start position:0%
satisfying way. If you haven't

11:09.480 --> 11:11.639 align:start position:0%
heard about it, which, you know, I hadn't

11:11.639 --> 11:14.279 align:start position:0%
heard about it that long ago, copy-and-patch

11:14.279 --> 11:16.800 align:start position:0%
compilation comes out of a

11:16.800 --> 11:19.880 align:start position:0%
Stanford paper. But if you don't like

11:19.880 --> 11:22.399 align:start position:0%
reading the paper, I highly recommend the

11:22.399 --> 11:24.160 align:start position:0%
blog post. There's a blog post called

11:24.160 --> 11:26.079 align:start position:0%
Building a baseline JIT for Lua

11:26.079 --> 11:27.600 align:start position:0%
automatically. This is by the same author

11:27.600 --> 11:29.079 align:start position:0%
as the paper, and I've actually spoken

11:29.079 --> 11:31.480 align:start position:0%
with him on a couple occasions.

11:31.480 --> 11:35.200 align:start position:0%
Basically, this is a way of turning a

11:35.200 --> 11:38.200 align:start position:0%
C interpreter into a fast template JIT

11:38.200 --> 11:41.279 align:start position:0%
compiler. And what's really really

11:41.279 --> 11:43.560 align:start position:0%
nice is that we are able to maintain

11:43.560 --> 11:45.399 align:start position:0%
that single source of truth for how a

11:45.399 --> 11:47.320 align:start position:0%
bytecode instruction should be implemented.

11:47.320 --> 11:48.880 align:start position:0%
It doesn't require us to hand-write

11:48.880 --> 11:51.160 align:start position:0%
assembly, which means that if you want to

11:51.160 --> 11:53.399 align:start position:0%
fix a bug in the interpreter, and you

11:53.399 --> 11:55.720 align:start position:0%
already know how to fix bugs in the

11:55.720 --> 11:58.000 align:start position:0%
interpreter, the JIT will be fixed too,

11:58.000 --> 11:59.519 align:start position:0%
without you having to actually do

11:59.519 --> 12:01.000 align:start position:0%
anything. We have that one source of

12:01.000 --> 12:02.399 align:start position:0%
truth and everything's built

12:02.399 --> 12:04.360 align:start position:0%
automatically for you, but the JIT itself

12:04.360 --> 12:06.000 align:start position:0%
is still really fast and has good

12:06.000 --> 12:08.519 align:start position:0%
quality code. If you don't believe me,

12:08.519 --> 12:10.399 align:start position:0%
here are some numbers from the paper

12:10.399 --> 12:12.360 align:start position:0%
compared to a WebAssembly baseline

12:12.360 --> 12:14.680 align:start position:0%
compiler. Copy-and-Patch has five

12:14.680 --> 12:17.160 align:start position:0%
times faster code generation and 50%

12:17.160 --> 12:19.560 align:start position:0%
faster code overall. The code quality is

12:19.560 --> 12:21.040 align:start position:0%
really good, and I'll show you why in a

12:21.040 --> 12:24.000 align:start position:0%
second. Compared to a mid-tier

12:24.000 --> 12:27.120 align:start position:0%
compiler, like a traditional JIT

12:27.120 --> 12:29.880 align:start position:0%
toolchain, which would be LLVM with a low

12:29.880 --> 12:32.320 align:start position:0%
optimization level to keep things fast,

12:32.320 --> 12:34.440 align:start position:0%
it has 100 times faster code

12:34.440 --> 12:38.279 align:start position:0%
generation and still 15% faster code. And

12:38.279 --> 12:40.519 align:start position:0%
just to complete the numbers,

12:40.519 --> 12:42.800 align:start position:0%
compared to a full optimizing JIT with

12:42.800 --> 12:44.639 align:start position:0%
handwritten assembly, in this case LuaJIT,

12:44.639 --> 12:47.560 align:start position:0%
a Copy-and-Patch Lua

12:47.560 --> 12:49.920 align:start position:0%
implementation is still faster on some

12:49.920 --> 12:52.120 align:start position:0%
benchmarks, and it's only 35% slower

12:52.120 --> 12:54.279 align:start position:0%
overall, despite being much much simpler

12:54.279 --> 12:55.440 align:start position:0%
to

12:55.440 --> 12:59.399 align:start position:0%
maintain. So how does it work? Well,

12:59.399 --> 13:02.240 align:start position:0%
let's think about the

13:02.240 --> 13:05.320 align:start position:0%
simplest form of a template JIT compiler.

13:05.320 --> 13:07.360 align:start position:0%
If we want to compile a sequence of

13:07.360 --> 13:09.000 align:start position:0%
bytecode instructions to machine code

13:09.000 --> 13:11.600 align:start position:0%
as fast as possible at runtime, what it

13:11.600 --> 13:13.279 align:start position:0%
might look like is walking over that

13:13.279 --> 13:15.199 align:start position:0%
sequence of bytecode instructions and

13:15.199 --> 13:17.839 align:start position:0%
then, for each one, copying over some

13:17.839 --> 13:20.199 align:start position:0%
static pre-compiled machine code into

13:20.199 --> 13:23.240 align:start position:0%
executable memory, and then going through

13:23.240 --> 13:24.760 align:start position:0%
that machine code and patching up

13:24.760 --> 13:26.240 align:start position:0%
instructions that need to have runtime

13:26.240 --> 13:28.639 align:start position:0%
data encoded in them. These would

13:28.639 --> 13:31.079 align:start position:0%
the be things like opargs, constants

13:31.079 --> 13:33.240 align:start position:0%
that we want to burn in, things like

13:33.240 --> 13:35.639 align:start position:0%
that. Now if you look at these two

13:35.639 --> 13:37.760 align:start position:0%
requirements, you'll notice that this

13:37.760 --> 13:39.279 align:start position:0%
sounds a lot like something we already

13:39.279 --> 13:42.199 align:start position:0%
have, which are relocatable object files.

13:42.199 --> 13:44.519 align:start position:0%
I could just as easily say, when

13:44.519 --> 13:46.560 align:start position:0%
linking or loading an ELF file, we want

13:46.560 --> 13:48.519 align:start position:0%
to copy some static pre-compiled machine

13:48.519 --> 13:50.720 align:start position:0%
code into executable memory, and then we

13:50.720 --> 13:51.959 align:start position:0%
want to patch up the instructions that

13:51.959 --> 13:53.480 align:start position:0%
need to have run some data encoded in

13:53.480 --> 13:55.519 align:start position:0%
them. These are relocations for

13:55.519 --> 13:56.480 align:start position:0%
external

13:56.480 --> 13:58.959 align:start position:0%
symbols. And this is how Copy-and-Patch

13:58.959 --> 14:03.519 align:start position:0%
works. Basically, we will use LLVM

14:03.519 --> 14:07.120 align:start position:0%
to build an ELF object file, and then we

14:07.120 --> 14:08.440 align:start position:0%
parse out the stuff that we care about

14:08.440 --> 14:10.519 align:start position:0%
from that ELF object file: namely, the

14:10.519 --> 14:12.440 align:start position:0%
body of the bytecode instruction and

14:12.440 --> 14:14.160 align:start position:0%
any information on how we need to fix up

14:14.160 --> 14:16.279 align:start position:0%
the stuff that we want to fix up. I'm

14:16.279 --> 14:18.040 align:start position:0%
going to give you a concrete example, and

14:18.040 --> 14:19.800 align:start position:0%
by concrete I mean I'm glossing over

14:19.800 --> 14:21.639 align:start position:0%
some details so take everything at

14:21.639 --> 14:25.839 align:start position:0%
~80% face value, okay? So, we have a LOAD_FAST

14:25.839 --> 14:28.240 align:start position:0%
instruction here. We are going to

14:28.240 --> 14:30.000 align:start position:0%
take the body of that LOAD_FAST

14:30.000 --> 14:32.519 align:start position:0%
instruction, we're going to put it inside

14:32.519 --> 14:34.519 align:start position:0%
of some other code, that is going to be

14:34.519 --> 14:36.639 align:start position:0%
the scaffolding that we need to

14:36.639 --> 14:38.079 align:start position:0%
be able to extract the stuff that we

14:38.079 --> 14:39.959 align:start position:0%
care about later, and be able to stitch

14:39.959 --> 14:42.079 align:start position:0%
everything together. In this example,

14:42.079 --> 14:44.399 align:start position:0%
we are going to be burning in the oparg

14:44.399 --> 14:46.839 align:start position:0%
and we are going to be basically jumping

14:46.839 --> 14:48.519 align:start position:0%
into the next bytecode instruction,

14:48.519 --> 14:49.519 align:start position:0%
because we need to make sure that the

14:49.519 --> 14:51.839 align:start position:0%
code is laid out in a way that we can

14:51.839 --> 14:53.839 align:start position:0%
flow from one instruction to the next,

14:53.839 --> 14:55.959 align:start position:0%
and that LLVM won't move things

14:55.959 --> 14:59.920 align:start position:0%
around on us. So see here: I have

14:59.920 --> 15:04.600 align:start position:0%
some placeholders here, some

15:04.600 --> 15:06.920 align:start position:0%
things that I don't define, for magically

15:06.920 --> 15:08.880 align:start position:0%
inserting the oparg and magically

15:08.880 --> 15:10.079 align:start position:0%
continuing

15:10.079 --> 15:12.480 align:start position:0%
execution. Copy-and-patch solves this

15:12.480 --> 15:16.440 align:start position:0%
problem by using externs. Instead of

15:16.440 --> 15:18.720 align:start position:0%
using the value of the extern for our

15:18.720 --> 15:20.680 align:start position:0%
oparg, we use the address of the extern

15:20.680 --> 15:23.360 align:start position:0%
for our oparg, which allows LLVM to

15:23.360 --> 15:25.519 align:start position:0%
generate really efficient code that we

15:25.519 --> 15:27.839 align:start position:0%
can patch very very easily. When you're

15:27.839 --> 15:30.399 align:start position:0%
actually fixing up relocations, typically

15:30.399 --> 15:32.240 align:start position:0%
you're inserting the address of the

15:32.240 --> 15:35.519 align:start position:0%
extern into the relocatable code.

15:35.519 --> 15:37.000 align:start position:0%
With this we don't actually need to

15:37.000 --> 15:38.680 align:start position:0%
dreference the value at that address, we

15:38.680 --> 15:40.600 align:start position:0%
can just use the address directly, and so

15:40.600 --> 15:42.959 align:start position:0%
the code is really efficient. And

15:42.959 --> 15:44.360 align:start position:0%
since we're using clang, we have this

15:44.360 --> 15:46.880 align:start position:0%
beautiful `musttail` attribute on the

15:46.880 --> 15:49.399 align:start position:0%
final continuation call, which means that

15:49.399 --> 15:52.079 align:start position:0%
we will just get a single jump that

15:52.079 --> 15:55.000 align:start position:0%
we can use to flow into the next opcode.

15:55.000 --> 15:57.519 align:start position:0%
And even better, if that

15:57.519 --> 15:59.759 align:start position:0%
jump happens to be of length zero, we can just

15:59.759 --> 16:01.240 align:start position:0%
skip the jump

16:01.240 --> 16:03.720 align:start position:0%
entirely. So, the object file that we get

16:03.720 --> 16:05.839 align:start position:0%
out of this when we compile this to ELF

16:05.839 --> 16:07.120 align:start position:0%
looks a lot like this. We have

16:07.120 --> 16:08.600 align:start position:0%
everything we care about. We have the

16:08.600 --> 16:11.399 align:start position:0%
machine code here highlighted in blue,

16:11.399 --> 16:13.800 align:start position:0%
and we have the relocations and where

16:13.800 --> 16:15.880 align:start position:0%
their data is going to go. We know

16:15.880 --> 16:17.240 align:start position:0%
exactly how the data is going to be

16:17.240 --> 16:19.199 align:start position:0%
patched, and we know exactly where it's

16:19.199 --> 16:21.639 align:start position:0%
going to be. And so we can take this,

16:21.639 --> 16:24.079 align:start position:0%
parse it out and put it in static header

16:24.079 --> 16:27.519 align:start position:0%
files, and now we have all the data that

16:27.519 --> 16:29.600 align:start position:0%
we want to copy and then all the holes

16:29.600 --> 16:31.079 align:start position:0%
that we want to

16:31.079 --> 16:35.000 align:start position:0%
patch. So, I've been working on this

16:35.000 --> 16:37.240 align:start position:0%
for a couple months, and I've done

16:37.240 --> 16:38.720 align:start position:0%
this. If you want to check it out, it's

16:38.720 --> 16:41.680 align:start position:0%
on my fork of CPython. The branch name

16:41.680 --> 16:45.160 align:start position:0%
is justin, as in just-in-time. If you

16:45.160 --> 16:48.360 align:start position:0%
want to check it out, it works! You can

16:48.360 --> 16:50.639 align:start position:0%
also actually look at the code

16:50.639 --> 16:53.720 align:start position:0%
by going to GitHub and checking out

16:53.720 --> 16:54.920 align:start position:0%
my branch

16:54.920 --> 16:58.079 align:start position:0%
there. Just some kind of stats on the

16:58.079 --> 17:01.120 align:start position:0%
implementation itself: at build time

17:01.120 --> 17:03.920 align:start position:0%
it is about 700 lines of complex Python.

17:03.920 --> 17:06.240 align:start position:0%
This is python code that handles

17:06.240 --> 17:09.039 align:start position:0%
actually extracting all the cases,

17:09.039 --> 17:11.039 align:start position:0%
compiling each one, parsing out the elf,

17:11.039 --> 17:13.799 align:start position:0%
and then generating the header files.

17:13.799 --> 17:15.720 align:start position:0%
It has about 100 lines of complex C;

17:15.720 --> 17:17.199 align:start position:0%
those are the templates that I showed

17:17.199 --> 17:19.160 align:start position:0%
you that we actually insert the cases

17:19.160 --> 17:21.280 align:start position:0%
into, so that we can compile and

17:21.280 --> 17:24.600 align:start position:0%
extract them. And there is an LLVM

17:24.600 --> 17:26.160 align:start position:0%
dependency, but importantly this is

17:26.160 --> 17:27.799 align:start position:0%
a build-time dependency, not something

17:27.799 --> 17:30.840 align:start position:0%
that users need to install. Compare

17:30.840 --> 17:33.799 align:start position:0%
this to the runtime requirements.

17:33.799 --> 17:36.720 align:start position:0%
So we have 300 lines of simple C, again

17:36.720 --> 17:38.000 align:start position:0%
the nice thing about the copy-and-patch

17:38.000 --> 17:40.120 align:start position:0%
compiler is that it's really fast but

17:40.120 --> 17:42.280 align:start position:0%
it's also really simple – it's a memcpy

17:42.280 --> 17:43.799 align:start position:0%
and then walking over the relocations

17:43.799 --> 17:47.840 align:start position:0%
and just performing them. And then we

17:47.840 --> 17:50.000 align:start position:0%
have the 3_000 lines of simple generated

17:50.000 --> 17:51.960 align:start position:0%
C. And it truly is just as simple as the

17:51.960 --> 17:53.919 align:start position:0%
code that I showed you on the last

17:53.919 --> 17:57.280 align:start position:0%
slide. And most importantly, no runtime

17:57.280 --> 17:59.880 align:start position:0%
dependencies: everything is fully

17:59.880 --> 18:02.679 align:start position:0%
self-contained. And what I really like

18:02.679 --> 18:05.720 align:start position:0%
about this is that – from a maintainer

18:05.720 --> 18:08.520 align:start position:0%
point of view, I like that all the

18:08.520 --> 18:09.919 align:start position:0%
complexity has been shifted to build-time

18:09.919 --> 18:11.919 align:start position:0%
rather than run-time, and it's been

18:11.919 --> 18:13.880 align:start position:0%
shifted into Python code rather than C

18:13.880 --> 18:17.440 align:start position:0%
code. So we are able to do all of the

18:17.440 --> 18:19.640 align:start position:0%
fancy stuff later – when we

18:19.640 --> 18:21.720 align:start position:0%
actually start making this thing really

18:21.720 --> 18:23.360 align:start position:0%
really fast and really really performant

18:23.360 --> 18:26.760 align:start position:0%
and optimizing the code – in the Python

18:26.760 --> 18:29.440 align:start position:0%
code itself rather than doing most of

18:29.440 --> 18:32.320 align:start position:0%
that work at runtime and in C code. I

18:32.320 --> 18:33.840 align:start position:0%
think we can all agree that we prefer

18:33.840 --> 18:35.600 align:start position:0%
writing python to C. Yeah, Pablo, did you have

18:35.600 --> 18:39.080 align:start position:0%
a question? — Yeah, so I'm curious why you

18:39.080 --> 18:42.600 align:start position:0%
need LLVM dependency.

18:42.600 --> 18:47.640 align:start position:0%
You want to generate the

18:47.640 --> 18:52.520 align:start position:0%
object it into it put into templates but

18:52.520 --> 18:54.440 align:start position:0%
you just use whatever compiler you're

18:54.440 --> 18:57.280 align:start position:0%
using to compile python to just compile

18:57.280 --> 18:59.799 align:start position:0%
maybe this templ and as far as they

18:59.799 --> 19:01.799 align:start position:0%
below yeah so there yeah there are a

19:01.799 --> 19:03.120 align:start position:0%
couple reasons so the first one is that

19:03.120 --> 19:04.640 align:start position:0%
must tail attribute where we get

19:04.640 --> 19:07.080 align:start position:0%
guaranteed tail calls GC GCC doesn't

19:07.080 --> 19:08.400 align:start position:0%
have that and we need tail calls for

19:08.400 --> 19:10.000 align:start position:0%
correctness otherwise we'll blow the

19:10.000 --> 19:13.720 align:start position:0%
stack stud every

19:13.720 --> 19:16.520 align:start position:0%
comp exactly clang is a great cross

19:16.520 --> 19:18.880 align:start position:0%
compiler so it it works lots of places

19:18.880 --> 19:22.280 align:start position:0%
um and we also use some other LM tools

19:22.280 --> 19:23.840 align:start position:0%
for example we don't actually parse the

19:23.840 --> 19:26.520 align:start position:0%
elf um LM has a tool that will dump El

19:26.520 --> 19:29.080 align:start position:0%
elf to Json which is great oh so we

19:29.080 --> 19:30.840 align:start position:0%
actually just parse the Json which is

19:30.840 --> 19:34.080 align:start position:0%
beautiful um it also has uh you know a

19:34.080 --> 19:36.559 align:start position:0%
built-in disassembler so uh the 3,000

19:36.559 --> 19:38.559 align:start position:0%
lines of header file is actually

19:38.559 --> 19:40.960 align:start position:0%
annotated where each above each kind of

19:40.960 --> 19:43.520 align:start position:0%
dump of the assembly um we actually have

19:43.520 --> 19:45.360 align:start position:0%
the human readable assembly output as

19:45.360 --> 19:48.360 align:start position:0%
well that you can audit and look at um

19:48.360 --> 19:51.360 align:start position:0%
and another thing too is uh once we

19:51.360 --> 19:53.000 align:start position:0%
start getting really clever with this uh

19:53.000 --> 19:54.600 align:start position:0%
there are actually really cool things

19:54.600 --> 19:57.760 align:start position:0%
that you can do by using lm's uh like

19:57.760 --> 20:00.480 align:start position:0%
wide VAR iy of calling conventions um so

20:00.480 --> 20:01.559 align:start position:0%
for example they have calling

20:01.559 --> 20:03.559 align:start position:0%
conventions that pass all arguments in

20:03.559 --> 20:05.320 align:start position:0%
registers and have no call E saved

20:05.320 --> 20:07.039 align:start position:0%
registers which is ideal if you want to

20:07.039 --> 20:10.360 align:start position:0%
like pin stack items in registers and uh

20:10.360 --> 20:12.440 align:start position:0%
make the jump at the very end of the

20:12.440 --> 20:14.640 align:start position:0%
continuation really really

20:14.640 --> 20:18.559 align:start position:0%
clean yes separate question um the bill

20:18.559 --> 20:21.240 align:start position:0%
time dependency is that bill time or is

20:21.240 --> 20:24.760 align:start position:0%
it generate files time could we separate

20:24.760 --> 20:28.640 align:start position:0%
that out could for python releases yes

20:28.640 --> 20:31.120 align:start position:0%
yeah the only thing we're using L LM for

20:31.120 --> 20:33.919 align:start position:0%
is to generate one header file um So

20:33.919 --> 20:35.200 align:start position:0%
currently on my Branch that's not

20:35.200 --> 20:36.919 align:start position:0%
checked into the rapo because it's

20:36.919 --> 20:39.280 align:start position:0%
platform specific and even whatever your

20:39.280 --> 20:40.760 align:start position:0%
pie config looks like it can change the

20:40.760 --> 20:42.960 align:start position:0%
way it works okay so it does need to be

20:42.960 --> 20:45.039 align:start position:0%
built yeah we could choose to check

20:45.039 --> 20:46.720 align:start position:0%
those in or host those somewhere or

20:46.720 --> 20:48.760 align:start position:0%
whatever um well if it's if it's

20:48.760 --> 20:51.600 align:start position:0%
configured specific yeah then you can't

20:51.600 --> 20:55.080 align:start position:0%
check them in yeah yeah it it I I choose

20:55.080 --> 20:59.200 align:start position:0%
not to track it um you know uh

20:59.200 --> 21:01.720 align:start position:0%
yeah so it is it is it is technically

21:01.720 --> 21:04.120 align:start position:0%
generate files time but it's not checked

21:04.120 --> 21:06.159 align:start position:0%
in so it's built time effectively well

21:06.159 --> 21:09.159 align:start position:0%
yeah it it also I mean all the other

21:09.159 --> 21:12.039 align:start position:0%
generated files we have are platform

21:12.039 --> 21:14.440 align:start position:0%
agnostic yes yeah yeah I I understand

21:14.440 --> 21:16.360 align:start position:0%
the question now yes it's build time

21:16.360 --> 21:19.000 align:start position:0%
okay yeah you put it in a container like

21:19.000 --> 21:21.760 align:start position:0%
the thing that we using for configure so

21:21.760 --> 21:24.240 align:start position:0%
everyone can run the commands and get

21:24.240 --> 21:26.600 align:start position:0%
the same out no because it depends on

21:26.600 --> 21:28.320 align:start position:0%
the platform so you would need need a

21:28.320 --> 21:30.039 align:start position:0%
container for every you would need a

21:30.039 --> 21:32.360 align:start position:0%
container for your specific platform it

21:32.360 --> 21:34.799 align:start position:0%
would be for every platform every option

21:34.799 --> 21:36.159 align:start position:0%
of whether you have a search turned on

21:36.159 --> 21:38.559 align:start position:0%
or off debug turned on or off by the way

21:38.559 --> 21:40.120 align:start position:0%
you can put asserts and printfs and

21:40.120 --> 21:41.640 align:start position:0%
stuff inside of your cases and they'll

21:41.640 --> 21:43.880 align:start position:0%
just be in the assembly it's

21:43.880 --> 21:46.720 align:start position:0%
awesome how long does it take a build

21:46.720 --> 21:48.640 align:start position:0%
time again it depends you have one of

21:48.640 --> 21:50.760 align:start position:0%
the new Macs because it takes like 30

21:50.760 --> 21:53.440 align:start position:0%
seconds on on slower machines it's less

21:53.440 --> 21:56.320 align:start position:0%
than a minute um and it doesn't uh

21:56.320 --> 21:58.919 align:start position:0%
always rerun so for example I have it

21:58.919 --> 22:00.720 align:start position:0%
cached so that it won't regenerate if

22:00.720 --> 22:02.760 align:start position:0%
the file's already present and the

22:02.760 --> 22:04.760 align:start position:0%
generated cases haven't changed so in

22:04.760 --> 22:05.799 align:start position:0%
practice if you're not modifying The

22:05.799 --> 22:07.880 align:start position:0%
Interpreter you won't see it but um

22:07.880 --> 22:09.919 align:start position:0%
otherwise it takes a few seconds on Fast

22:09.919 --> 22:11.559 align:start position:0%
hardware and no more than a minute on

22:11.559 --> 22:12.520 align:start position:0%
everything

22:12.520 --> 22:16.720 align:start position:0%
else so do windows oh let's talk about

22:16.720 --> 22:20.120 align:start position:0%


22:20.120 --> 22:22.559 align:start position:0%
support Victor you will be happy to know

22:22.559 --> 22:25.080 align:start position:0%
that the the uh the initial

22:25.080 --> 22:27.360 align:start position:0%
implementation supports two platforms it

22:27.360 --> 22:31.320 align:start position:0%


22:31.320 --> 22:33.840 align:start position:0%
windows Micosoft just

22:33.840 --> 22:36.120 align:start position:0%
kidding it supports all tier one

22:36.120 --> 22:37.600 align:start position:0%
platforms if you check it out right now

22:37.600 --> 22:39.559 align:start position:0%
on any of these it'll work in fact it

22:39.559 --> 22:41.520 align:start position:0%
supports all tier one and tier 2

22:41.520 --> 22:44.400 align:start position:0%
platforms right now um except power PC

22:44.400 --> 22:47.159 align:start position:0%
but we don't talk about

22:47.159 --> 22:50.320 align:start position:0%
that um but uh most notably since clang

22:50.320 --> 22:52.600 align:start position:0%
is such a great cross compiler uh the

22:52.600 --> 22:55.320 align:start position:0%
default cross compile setup just works

22:55.320 --> 22:56.760 align:start position:0%
perfectly um if you're doing cross

22:56.760 --> 22:59.120 align:start position:0%
compiles now don't change anything just

22:59.120 --> 23:02.559 align:start position:0%
install lbm 16 nearby um and your

23:02.559 --> 23:04.760 align:start position:0%
regular build your cross build whatever

23:04.760 --> 23:06.279 align:start position:0%
options you're passing to configure

23:06.279 --> 23:08.000 align:start position:0%
things just work.

23:08.500 --> 23:11.000
And, I think that's it!

23:11.100 --> 23:13.000
So, no questions, thank you.

23:13.200 --> 23:18.000 align:start position:0%
[Applause]

23:23.400 --> 23:25.780
Victor? Did you have a question...

23:26.050 --> 23:28.450
Okay, Carol, yeah?  [Carol] No, I was going to say:

23:28.550 --> 23:29.950
How does it compare to Numba?

23:30.050 --> 23:31.400 align:start position:0%
Does it work with GPUs?

23:31.600 --> 23:34.000 align:start position:0%
[Brandt] Uh, how does it to compare in terms of speed?

23:34.039 --> 23:36.159 align:start position:0%
[Carol] Yeah. [Brandt] So currently it is no faster

23:36.159 --> 23:37.480 align:start position:0%
than main when you have this turned on,

23:37.480 --> 23:39.880 align:start position:0%
but that represents a 5% improvement

23:39.880 --> 23:43.080 align:start position:0%
over the Micro Ops that it's based on,

23:43.080 --> 23:45.200 align:start position:0%
and we haven't done any of the fun tricks yet.

23:46.900 --> 23:48.800 align:start position:0%
So it's much slower than Numba.

23:50.150 --> 23:53.000 align:start position:0%
And what was the other question? Numba...

23:53.000 --> 23:54.800 align:start position:0%
[Carol] GPU support.

23:55.000 --> 23:56.725
[Brandt] GPU support,

23:56.725 --> 23:58.450
I would guess just as well as LLVM

23:58.559 --> 24:00.720 align:start position:0%
supports GPU, so I, I'm not doing

24:00.720 --> 24:02.460
anything special. Yeah.

24:02.460 --> 24:04.500
[Unknown] So if they aren CPUs, the resources

24:04.700 --> 24:05.800 align:start position:0%
aren't in the right place, so it's...

24:06.000 --> 24:07.760 align:start position:0%
[Brandt] Yeah, it's nice because for things

24:07.760 --> 24:10.360 align:start position:0%
like platform support or more specific

24:10.360 --> 24:12.559 align:start position:0%
like, hardware integration, we can just

24:12.559 --> 24:14.559 align:start position:0%
piggyback on LLVM. So if there's a way to

24:14.559 --> 24:16.640 align:start position:0%
make LLVM uh use the gpus more

24:16.640 --> 24:18.360 align:start position:0%
effectively then we can harness that too.

24:18.360 --> 24:22.360 align:start position:0%
At least for that build. [Carol] Yes, okay.

24:23.300 --> 24:25.520 align:start position:0%
Victor? [Victor] The thing about container is

24:25.550 --> 24:28.900
it possible on Linux to generate the,

24:29.100 --> 24:32.500
the generated part for all platforms, from Linux?

24:32.500 --> 24:34.800
[Unknown] You can do a cross-compiler container,

24:34.900 --> 24:36.039
with 20 cross-compilers in it, I think.

24:36.039 --> 24:38.500 align:start position:0%
You don't need the container,

24:38.500 --> 24:41.800 align:start position:0%
so if you install the cross-compiler tool chain,

24:42.500 --> 24:43.500 align:start position:0%
LLVM knows how to find that,

24:43.500 --> 24:44.600 align:start position:0%
and you can just build them all.

24:44.800 --> 24:46.400 align:start position:0%
'cause you don't actually need to

24:46.600 --> 24:48.000 align:start position:0%
run anything for this...

24:48.000 --> 24:50.300 align:start position:0%
[Unknown] He really wants to use a container. [Unknown] He does!

24:51.300 --> 24:54.000 align:start position:0%
When you ask people to install LLVM,

24:54.000 --> 24:55.900 align:start position:0%
they get different flavor,

24:55.900 --> 24:59.000 align:start position:0%
different [???], and the output can change,

24:59.200 --> 25:01.880 align:start position:0%
so maybe to configure it, put everything in

25:01.880 --> 25:04.799 align:start position:0%
a container we know that you always get

25:04.799 --> 25:07.200 align:start position:0%
exactly the same output. [Brandt] Yeah, we,

25:07.400 --> 25:09.480 align:start position:0%
that is definitely something important, but again

25:09.480 --> 25:11.080 align:start position:0%
remember this also depends on configure

25:11.080 --> 25:14.520 align:start position:0%
flags, so it's only as stable as those.

25:14.520 --> 25:17.720 align:start position:0%
Also on top of that, I mean, I have test,

25:17.720 --> 25:20.200 align:start position:0%
I do have CI running this on all the

25:20.200 --> 25:21.800 align:start position:0%
platforms I listed there,

25:24.000 --> 25:25.679 align:start position:0%
it's also tested against the full Matrix of

25:25.679 --> 25:28.799 align:start position:0%
LLVM 14, 15, and 16, so for all three of

25:28.799 --> 25:31.200 align:start position:0%
those I've verified that this passes

25:31.200 --> 25:33.200 align:start position:0%
the entire test suite.

25:33.500 --> 25:35.500 align:start position:0%
[Victor] So are you going to checkin this file

25:35.500 --> 25:39.000 align:start position:0%
in Python? [Brandt] I have no plans to.

25:39.800 --> 25:41.800 align:start position:0%
[Unknown] We should. [Victor] We should not...

25:41.800 --> 25:44.500 align:start position:0%
[Brandt] You can host a bunch of them somewhere if you want.

25:46.400 --> 25:47.360 align:start position:0%
[Unknown] It's like, I'm not sure we're going to

25:47.360 --> 25:48.919 align:start position:0%
need a container. Basically it sounds

25:48.919 --> 25:50.400 align:start position:0%
like this is working on a wide variety

25:50.400 --> 25:52.400 align:start position:0%
of things, it's just a matter of...

25:54.000 --> 25:56.000
... is pip installing LLVM, 

25:56.000 --> 25:58.100 align:start position:0%
 problem for people building Python?

26:00.000 --> 26:02.300 align:start position:0%
For the people in this room it's probably not, but...

26:02.300 --> 26:04.559 align:start position:0%
And if you check out my branch, too,

26:04.559 --> 26:07.200 align:start position:0%
there's a README in tools/jit,

26:07.400 --> 26:09.650 align:start position:0%
it tells you how to install LLVM on all

26:09.640 --> 26:11.360 align:start position:0%
platforms and again one thing I want to

26:11.360 --> 26:13.640 align:start position:0%
highlight is you don't need to build

26:13.640 --> 26:15.760 align:start position:0%
CPython itself with LLVM, or even the

26:15.760 --> 26:18.399 align:start position:0%
same version of LLVM. LLVM is only used

26:18.399 --> 26:20.500 align:start position:0%
just for generating that one header file.

26:21.500 --> 26:24.640 align:start position:0%
[Victor] So far, when you get a tarball of Python,

26:24.640 --> 26:28.559 align:start position:0%
you don't need LLVM, so it would be a new dependency?

26:28.900 --> 26:31.000 align:start position:0%
If, if you want to build the JIT, yes.

26:31.000 --> 26:32.919 align:start position:0%
So I imagine this behind a configure

26:32.919 --> 26:36.840 align:start position:0%
flag, where, I mean, just, just,

26:36.840 --> 26:39.760 align:start position:0%
spitballing here: If you don't pass

26:39.760 --> 26:41.080 align:start position:0%
the configure flag and you don't have

26:41.080 --> 26:44.240 align:start position:0%
LLVM installed, we don't do, we just do

26:44.240 --> 26:47.080 align:start position:0%
a normal build. If we smell that LLVM is

26:47.080 --> 26:48.640 align:start position:0%
nearby but you didn't pass the flag we

26:48.640 --> 26:50.159 align:start position:0%
can say: "Hey, by the way, you can build a

26:50.159 --> 26:52.000 align:start position:0%
JIT if you want to." And if you do pass

26:52.000 --> 26:54.600 align:start position:0%
the flag then we build the JIT.

26:56.000 --> 26:59.279 align:start position:0%
[Unknown] You can also leave work for a future of

26:59.279 --> 27:00.100
seeing if you can make something

27:00.100 --> 27:03.000
work on other compilers...

27:03.000 --> 27:05.120
... becomes a section of work for each compiler.

27:05.120 --> 27:09.000 align:start position:0%
[Unknown] Just that making that configure

27:09.000 --> 27:11.000 align:start position:0%
flag an optional thing is pretty much

27:11.000 --> 27:13.800 align:start position:0%
essential for iOS... [Brandt] Or like

27:13.800 --> 27:15.500 align:start position:0%
WebAssembly for example, or any of the list

27:15.520 --> 27:17.080 align:start position:0%
of tier-3 platforms that we

27:17.080 --> 27:20.240 align:start position:0%
absolutely can't build for.

27:20.240 --> 27:23.640 align:start position:0%
Uh, Pablo, sorry, I should say names.

27:23.640 --> 27:25.650 align:start position:0%
[Pablo] Do you need any special, like,

27:25.650 --> 27:27.200 align:start position:0%
magic thingies for macOS, like,

27:27.300 --> 27:29.300
I recall that it has some protections,

27:29.300 --> 27:31.550
and it's like, ...

27:31.520 --> 27:35.120 align:start position:0%
[Brandt] This is, I mean, JITs work on macOS,

27:35.120 --> 27:36.600 align:start position:0%
so you can't have, you can't have

27:36.600 --> 27:38.240 align:start position:0%
writable executable memory, and I think

27:38.240 --> 27:39.960 align:start position:0%
as of Sonoma you can't have readable

27:39.960 --> 27:42.320 align:start position:0%
executable memory, which is something

27:42.320 --> 27:44.039 align:start position:0%
I need to fix. So this won't work on

27:44.039 --> 27:46.120 align:start position:0%
Somoma because currently the memory is

27:46.120 --> 27:47.799 align:start position:0%
read-execute, but that's on my list of

27:47.799 --> 27:49.200
things to fix.

27:49.200 --> 27:51.559
[Unknown] Do we need to, like, to

27:51.559 --> 27:53.960 align:start position:0%
change like the way we need to release

27:53.960 --> 27:56.120 align:start position:0%
this for macOS? I recall that there's a

27:56.120 --> 27:58.159 align:start position:0%
way to ask for it, ...

27:58.159 --> 28:01.320 align:start position:0%
[Brandt] When you map the memory, you ask for

28:01.320 --> 28:05.720 align:start position:0%
the JIT... In the flags when you mmap the

28:05.720 --> 28:08.600 align:start position:0%
memory, you can say mmap JIT, I think,

28:08.600 --> 28:11.640 align:start position:0%
and that says I'm a JIT. [Unknown] I think you

28:11.640 --> 28:13.080 align:start position:0%
may be referring to platform

28:13.080 --> 28:14.679 align:start position:0%
restrictions where you need to actually

28:14.679 --> 28:16.550
set the executable up specially

28:16.550 --> 28:17.500
before you even run it.

28:17.500 --> 28:19.800 align:start position:0%
[Pablo] Let me rephrase: So when we

28:19.800 --> 28:21.940
build the macOS binary, 

28:22.500 --> 28:24.500
because I suppose for the one that you compile is

28:24.700 --> 28:28.399 align:start position:0%
the same you compile yourself (yes),

28:28.399 --> 28:30.840 align:start position:0%
like, do you know if we need to set

28:30.840 --> 28:32.160
anything or ask Apple...

28:32.160 --> 28:33.480
[Brandt] If we do I don't know

28:33.480 --> 28:35.120 align:start position:0%
that we need to, I'm not familiar with

28:35.120 --> 28:37.519 align:start position:0%
how we're actually building macOS

28:37.519 --> 28:39.760 align:start position:0%
releases differently from how I just

28:39.760 --> 28:41.880 align:start position:0%
build it locally. I can vouch for it

28:41.880 --> 28:43.500 align:start position:0%
working locally.

28:44.850 --> 28:47.240 align:start position:0%
[Unknown] Presumably the the release

28:47.240 --> 28:49.300 align:start position:0%
manager needs to use that flag?

28:49.700 --> 28:51.679 align:start position:0%
[Brandt] Yes, there's anything that needs to be done,

28:51.679 --> 28:53.279 align:start position:0%
that sounds like the release manager

28:53.279 --> 28:57.000 align:start position:0%
should do it, but I'm not aware of, yeah...

28:58.000 --> 29:00.900 align:start position:0%
It very well could be... The most,

29:00.900 --> 29:03.279 align:start position:0%
Most of the sort of permissions stuff

29:03.279 --> 29:05.519 align:start position:0%
I've had to debug has been on macOS

29:05.519 --> 29:08.300 align:start position:0%
specifically M1 Mac. Yeah.

29:09.200 --> 29:10.880 align:start position:0%
[Sam] So it sounds like the runtime

29:10.880 --> 29:13.000 align:start position:0%
code generation is super fast. (Yes). Why not

29:13.000 --> 29:17.000 align:start position:0%
just do this, either, for like, tier-1, or

29:17.000 --> 29:20.700 align:start position:0%
I forget what number it starts at, interpreter...

29:20.700 --> 29:22.600
Why only do this for tier-2?

29:22.600 --> 29:23.500
[Brandt] Well we definitely

29:23.500 --> 29:24.360 align:start position:0%
don't want to do it for

29:24.360 --> 29:26.720 align:start position:0%
unspecialized byte-code, right, because the

29:26.720 --> 29:28.519 align:start position:0%
specialized byte-code is, uh, where we're

29:28.519 --> 29:29.919 align:start position:0%
able to actually generate high quality

29:29.919 --> 29:32.080 align:start position:0%
code for, um, and the reason that we want

29:32.080 --> 29:33.960 align:start position:0%
to break it up into tier-2 code is

29:33.960 --> 29:36.039 align:start position:0%
because just by breaking it up we're not

29:36.039 --> 29:38.000 align:start position:0%
actually gaining anything, right?

29:38.000 --> 29:39.519 align:start position:0%
If anything we're losing something because

29:39.519 --> 29:42.600 align:start position:0%
LLVM is able to optimize less over the

29:42.600 --> 29:47.559 align:start position:0%
same context. But the kind of

29:47.559 --> 29:49.399 align:start position:0%
reason to build this on top of tier-2

29:49.399 --> 29:51.080 align:start position:0%
is because ideally we're going to

29:51.080 --> 29:52.960 align:start position:0%
optimize here too, and Ken Jin will talk a

29:52.960 --> 29:54.679 align:start position:0%
little bit more about that. But if

29:54.679 --> 29:56.960 align:start position:0%
we're able to remove guards or reorder

29:56.960 --> 29:59.880 align:start position:0%
things or hoist guards or whatever,

29:59.880 --> 30:01.950 align:start position:0%
then this builds on top of that,

30:01.950 --> 30:03.200 align:start position:0%
and so those guards won't be present

30:03.200 --> 30:04.600
in the generated machine code.

30:05.000 --> 30:06.050
[Sam] I get all that,

30:06.050 --> 30:07.350 align:start position:0%
but like, so the examples you're talking

30:07.360 --> 30:09.080 align:start position:0%
about that are already using this are

30:09.080 --> 30:10.960 align:start position:0%
using this for their baseline, right,

30:10.960 --> 30:12.399 align:start position:0%
they're using this before any

30:12.399 --> 30:15.080 align:start position:0%
optimizations. (Yes.) So wouldn't this be

30:15.080 --> 30:18.100 align:start position:0%
advantageous in the same use case for Python?

30:18.300 --> 30:21.000 align:start position:0%
[Brandt] It could be, I haven't tried it.

30:22.500 --> 30:25.450 align:start position:0%
[Unknown] We currently can't translate every

30:25.480 --> 30:28.279 align:start position:0%
tier-1 byte-code into a corresonding sequence

30:28.279 --> 30:31.240 align:start position:0%
of tier two by codes. [Brandt] Although we have...

30:31.240 --> 30:33.000 align:start position:0%
[Sam] Do you translate every tier-1 byte-code

30:33.000 --> 30:35.799 align:start position:0%
to copy-and-patch? [Brandt] No.

30:35.799 --> 30:37.840 align:start position:0%
No, because needs to

30:37.840 --> 30:43.360 align:start position:0%
be simp we we we could it would just be

30:43.360 --> 30:45.399 align:start position:0%
different

30:45.399 --> 30:55.840 align:start position:0%


30:55.840 --> 30:58.120 align:start position:0%
ahead although have and we want

30:58.120 --> 31:00.039 align:start position:0%
effective profiling that gives us as

31:00.039 --> 31:01.720 align:start position:0%
well so theer

31:01.720 --> 31:04.120 align:start position:0%
oneu because we're effectively

31:04.120 --> 31:17.960 align:start position:0%


31:17.960 --> 31:26.159 align:start position:0%


31:26.159 --> 31:28.519 align:start position:0%
probably another thing too I I realized

31:28.519 --> 31:31.039 align:start position:0%
I didn't mention um the reason that the

31:31.039 --> 31:32.760 align:start position:0%
generated code is such high quality is

31:32.760 --> 31:35.399 align:start position:0%
because we don't care about uh like the

31:35.399 --> 31:36.720 align:start position:0%
compil times when we're actually

31:36.720 --> 31:38.279 align:start position:0%
building this thing so we pull out all

31:38.279 --> 31:39.960 align:start position:0%
the stops and tell lvm to optimize

31:39.960 --> 31:41.320 align:start position:0%
heavily um which is something you

31:41.320 --> 31:43.960 align:start position:0%
wouldn't want to do in a RI time jit yes

31:43.960 --> 31:46.639 align:start position:0%
when youate the machine

31:46.639 --> 31:51.960 align:start position:0%
code can you pass the equivalent to

31:51.960 --> 31:54.919 align:start position:0%
compile we're using

31:54.919 --> 32:00.240 align:start position:0%
clim yes yeah so uh we uh compile first

32:00.240 --> 32:02.559 align:start position:0%
using clang and that turns C code into

32:02.559 --> 32:06.080 align:start position:0%
llvm uh textual IR um the only reason we

32:06.080 --> 32:07.519 align:start position:0%
do that is because we want to fix up the

32:07.519 --> 32:08.960 align:start position:0%
calling convention and clang doesn't

32:08.960 --> 32:10.880 align:start position:0%
actually let let us have this calling

32:10.880 --> 32:12.880 align:start position:0%
convention from C so we fix up the

32:12.880 --> 32:15.720 align:start position:0%
calling convention using a hacky Rex

32:15.720 --> 32:17.639 align:start position:0%
replacement that will change in the

32:17.639 --> 32:21.120 align:start position:0%
future um and uh and then compile again

32:21.120 --> 32:24.240 align:start position:0%


32:24.240 --> 32:27.720 align:start position:0%
elf and you said it was under your or

32:27.720 --> 32:29.399 align:start position:0%
yeah yeah so my user brand Booker it's

32:29.399 --> 32:31.519 align:start position:0%
on my fory python the brand it's on the

32:31.519 --> 32:36.840 align:start position:0%


32:36.840 --> 32:38.840 align:start position:0%
yes uh that's the

32:38.840 --> 32:42.639 align:start position:0%
URL so it's the Justin branch of Bry P

32:42.639 --> 32:46.080 align:start position:0%
that's if you go to uh tools jit there's

32:46.080 --> 32:47.399 align:start position:0%
a read me in there that says how to

32:47.399 --> 32:49.480 align:start position:0%
install lvm

32:49.480 --> 32:51.880 align:start position:0%
sweet it's one a question of the general

32:51.880 --> 32:53.600 align:start position:0%
approach than the what you need so far

32:53.600 --> 32:55.480 align:start position:0%
but once you have a line of tra and you

32:55.480 --> 32:57.919 align:start position:0%
can have individual with this function

32:57.919 --> 33:00.519 align:start position:0%
another obvious things to try is to put

33:00.519 --> 33:02.799 align:start position:0%
all these calls into a cile compile it

33:02.799 --> 33:05.039 align:start position:0%
all together and see what happens yeah

33:05.039 --> 33:07.639 align:start position:0%
have you tried uh no but one thing the

33:07.639 --> 33:09.399 align:start position:0%
paper did have good success with is

33:09.399 --> 33:11.360 align:start position:0%
actually compiling super instructions uh

33:11.360 --> 33:14.480 align:start position:0%
for common pairs or triples because then

33:14.480 --> 33:17.440 align:start position:0%
it really allows lbm to optimize across

33:17.440 --> 33:19.559 align:start position:0%
um especially for for example like

33:19.559 --> 33:21.000 align:start position:0%
obvious things that we may want to look

33:21.000 --> 33:25.639 align:start position:0%
at are um when we so the Micro Ops are

33:25.639 --> 33:27.639 align:start position:0%
kind of expanded from a single

33:27.639 --> 33:30.039 align:start position:0%
instruction um I would imagine that in

33:30.039 --> 33:32.080 align:start position:0%
many cases we aren't able to optimize

33:32.080 --> 33:33.279 align:start position:0%
that very heavily and so it ends up

33:33.279 --> 33:34.600 align:start position:0%
being the equivalent of the original

33:34.600 --> 33:35.799 align:start position:0%
instruction so that'd be sort of low

33:35.799 --> 33:37.279 align:start position:0%
hanging fruit for things that we could

33:37.279 --> 33:39.600 align:start position:0%
compile and again when we're just

33:39.600 --> 33:42.039 align:start position:0%
walking over we can window over and see

33:42.039 --> 33:45.320 align:start position:0%
if we have anything that's entire

33:45.320 --> 33:47.880 align:start position:0%
X involve the compiler

33:47.880 --> 33:52.200 align:start position:0%
and exactly and and right now we have um

33:52.200 --> 33:56.559 align:start position:0%
like we have one uh template for every

33:56.559 --> 33:59.360 align:start position:0%
uh micro op so like 200 some odd

33:59.360 --> 34:01.639 align:start position:0%
templates um in the paper they generated

34:01.639 --> 34:04.720 align:start position:0%
as many as like 10,000 um combinations

34:04.720 --> 34:06.960 align:start position:0%
yes not only for combinations but also

34:06.960 --> 34:09.320 align:start position:0%
like for example if you have uh some

34:09.320 --> 34:12.560 align:start position:0%
instructions for example um CH the

34:12.560 --> 34:14.159 align:start position:0%
control flow changes based on the value

34:14.159 --> 34:16.919 align:start position:0%
of the opar so it may make sense to

34:16.919 --> 34:19.560 align:start position:0%
actually burn in values of the opar not

34:19.560 --> 34:22.040 align:start position:0%
actually at jit time but ahead of time

34:22.040 --> 34:23.760 align:start position:0%
where you hard code those values and LM

34:23.760 --> 34:25.480 align:start position:0%
can optimize based on them and the op AR

34:25.480 --> 34:28.159 align:start position:0%
is completely removed um then there's

34:28.159 --> 34:29.760 align:start position:0%
also super instructions and there

34:29.760 --> 34:31.760 align:start position:0%
there's all sorts of games you can play

34:31.760 --> 34:33.359 align:start position:0%
um another example would be if you're

34:33.359 --> 34:35.960 align:start position:0%
lifting things from uh stack items into

34:35.960 --> 34:39.399 align:start position:0%
registers um if you are kind of keeping

34:39.399 --> 34:41.359 align:start position:0%
that mapping of Stack items to registers

34:41.359 --> 34:42.760 align:start position:0%
you may want to compile variants for

34:42.760 --> 34:44.560 align:start position:0%
different stack sizes um so that you

34:44.560 --> 34:47.240 align:start position:0%
have a finite number of uh mappings but

34:47.240 --> 34:52.000 align:start position:0%


34:52.000 --> 34:55.879 align:start position:0%
simple Victor again so what is your

34:55.879 --> 34:58.760 align:start position:0%
proposal do you want to to match or do

34:58.760 --> 35:02.599 align:start position:0%


35:02.599 --> 35:04.920 align:start position:0%
mainside uh I I didn't really have a

35:04.920 --> 35:08.040 align:start position:0%
proposal today but basically if this is

35:08.040 --> 35:09.720 align:start position:0%
something people would like to see in

35:09.720 --> 35:12.560 align:start position:0%
main off by default um we can get it in

35:12.560 --> 35:14.560 align:start position:0%
main very easily I know we aren't crazy

35:14.560 --> 35:16.079 align:start position:0%
about experiments in Maine which is kind

35:16.079 --> 35:18.520 align:start position:0%
of why I'm floating the idea now if not

35:18.520 --> 35:19.880 align:start position:0%
uh this has been a long live Branch

35:19.880 --> 35:24.160 align:start position:0%
since like May um and so if if if it's

35:24.160 --> 35:25.960 align:start position:0%
any Testament to like how easy it is to

35:25.960 --> 35:27.880 align:start position:0%
maintain this stuff a lot of stuff has

35:27.880 --> 35:30.599 align:start position:0%
landed in Maine since May and uh keeping

35:30.599 --> 35:32.560 align:start position:0%
this Branch up to date and improving

35:32.560 --> 35:34.520 align:start position:0%
during that time has not been very

35:34.520 --> 35:38.839 align:start position:0%
difficult um Ken even borrowed uh he

35:38.839 --> 35:40.400 align:start position:0%
basically merged this Branch into his

35:40.400 --> 35:42.880 align:start position:0%
own Branch a while back when he was uh

35:42.880 --> 35:45.160 align:start position:0%
uh playing around with optimizing stuff

35:45.160 --> 35:46.599 align:start position:0%
and wanted to see what would happen if

35:46.599 --> 35:49.119 align:start position:0%
he jitted it Ken is it easy to like add

35:49.119 --> 35:51.520 align:start position:0%
new bite codes and work with the jit as

35:51.520 --> 35:56.000 align:start position:0%
a like a API this is a r question about

35:56.000 --> 35:57.680 align:start position:0%
yes

35:57.680 --> 36:00.560 align:start position:0%
um yeah the good thing is that you just

36:00.560 --> 36:02.640 align:start position:0%
need to install LM

36:02.640 --> 36:06.839 align:start position:0%
and uh the the script will automatically

36:06.839 --> 36:09.319 align:start position:0%
generate so you don't actually need to

36:09.319 --> 36:12.560 align:start position:0%
know how it works in the background yeah

36:12.560 --> 36:14.520 align:start position:0%
oh and because like you said at one time

36:14.520 --> 36:16.560 align:start position:0%
patching in is really simple so we

36:16.560 --> 36:18.000 align:start position:0%
actually had to modify the patching

36:18.000 --> 36:20.560 align:start position:0%
because our patches were of different

36:20.560 --> 36:24.119 align:start position:0%
types than L tracers but even then like

36:24.119 --> 36:25.400 align:start position:0%
the file is just a for Lo like you

36:25.400 --> 36:27.520 align:start position:0%
mentioned copy so really simple to

36:27.520 --> 36:30.400 align:start position:0%
multiply yeah the actual code that jits

36:30.400 --> 36:33.560 align:start position:0%
and copies and patches like of those 300

36:33.560 --> 36:37.280 align:start position:0%
lines of Fairly uh simple c um like the

36:37.280 --> 36:38.880 align:start position:0%
the hot Loop where we're actually just

36:38.880 --> 36:40.599 align:start position:0%
walking over stuff selecting stencils

36:40.599 --> 36:42.520 align:start position:0%
and patching stuff is like maybe 20

36:42.520 --> 36:44.920 align:start position:0%
lines of code um the rest is sort of

36:44.920 --> 36:47.599 align:start position:0%
like handling permissions on Windows and

36:47.599 --> 36:51.240 align:start position:0%
Mac and all that kind of fun is it

36:51.240 --> 36:54.560 align:start position:0%
possible to to maintain it outside

36:54.560 --> 36:57.680 align:start position:0%
python I mean just technically

36:57.680 --> 37:01.160 align:start position:0%
sense or is it is

37:01.160 --> 37:04.440 align:start position:0%
implementation of I would say that since

37:04.440 --> 37:06.119 align:start position:0%
we are using the same Micro Ops as tier

37:06.119 --> 37:09.119 align:start position:0%
2 um we're pretty tightly coupled to the

37:09.119 --> 37:10.780 align:start position:0%
implementation

37:10.780 --> 37:13.520 align:start position:0%
[Music]

37:13.520 --> 37:17.520 align:start position:0%
um um it could

37:17.520 --> 37:20.520 align:start position:0%
be um one thing that we would need so so

37:20.520 --> 37:25.280 align:start position:0%
when we actually uh compile the code um

37:25.280 --> 37:28.720 align:start position:0%
we basically in those header files if

37:28.720 --> 37:30.040 align:start position:0%
you have a bite code instruction that

37:30.040 --> 37:33.079 align:start position:0%
calls for example p number ad right

37:33.079 --> 37:34.760 align:start position:0%
that's a symbol that you need to link

37:34.760 --> 37:36.760 align:start position:0%
against um and so the way we do that in

37:36.760 --> 37:38.880 align:start position:0%
the header file is we actually just put

37:38.880 --> 37:41.599 align:start position:0%
address of p number ad as an addend for

37:41.599 --> 37:42.560 align:start position:0%
that uh

37:42.560 --> 37:45.599 align:start position:0%
relocation um that works for p number ad

37:45.599 --> 37:48.119 align:start position:0%
but if we were building this separately

37:48.119 --> 37:50.839 align:start position:0%
from cpython itself there's a lot of

37:50.839 --> 37:52.760 align:start position:0%
internal apis that would need to be

37:52.760 --> 37:54.400 align:start position:0%
exposed as public symbols in order for

37:54.400 --> 37:56.040 align:start position:0%
us to link them and actually linking

37:56.040 --> 37:57.800 align:start position:0%
them at run time would be a lot more

37:57.800 --> 38:00.280 align:start position:0%
complicated um we would first probably

38:00.280 --> 38:03.079 align:start position:0%
need to initialize all the stencils when

38:03.079 --> 38:04.760 align:start position:0%
the extension or whatever was first

38:04.760 --> 38:08.640 align:start position:0%
loaded by walking over and uh the

38:08.640 --> 38:10.640 align:start position:0%
stencils and actually resolving all of

38:10.640 --> 38:12.280 align:start position:0%
those symbols finding them in the

38:12.280 --> 38:15.160 align:start position:0%
current process uh with using dlm or

38:15.160 --> 38:17.119 align:start position:0%
whatever the windows equivalent is

38:17.119 --> 38:18.680 align:start position:0%
walking over them and actually fixing up

38:18.680 --> 38:21.720 align:start position:0%
those add-ins and then it would mostly

38:21.720 --> 38:25.359 align:start position:0%
be the same um but that sounds a lot

38:25.359 --> 38:27.599 align:start position:0%
more complicated than and I don't think

38:27.599 --> 38:29.119 align:start position:0%
we want to stick all that stuff as

38:29.119 --> 38:32.880 align:start position:0%
public symbols um so it is doable in

38:32.880 --> 38:34.680 align:start position:0%
theory I think the ergonomics make it

38:34.680 --> 38:37.839 align:start position:0%
like probably not the best option I'm

38:37.839 --> 38:41.440 align:start position:0%


38:41.440 --> 38:47.720 align:start position:0%


38:47.720 --> 38:49.520 align:start position:0%
examp

38:49.520 --> 38:52.839 align:start position:0%
okay don't build

38:52.839 --> 38:55.720 align:start position:0%
the or or I'll build it for you and I'll

38:55.720 --> 39:04.480 align:start position:0%


39:04.480 --> 39:06.359 align:start position:0%
that's behind the configur flag for now

39:06.359 --> 39:08.119 align:start position:0%
the answer to

39:08.119 --> 39:11.440 align:start position:0%
that unknown this very useful find way

39:11.440 --> 39:13.760 align:start position:0%
forward to actually do it you you can't

39:13.760 --> 39:16.079 align:start position:0%
at the same time say that you want the

39:16.079 --> 39:19.160 align:start position:0%
jit and say that you

39:19.160 --> 39:22.400 align:start position:0%
cannot have this dependency right this

39:22.400 --> 39:25.079 align:start position:0%


39:25.079 --> 39:28.640 align:start position:0%
want I want million we can we all want

39:28.640 --> 39:31.119 align:start position:0%
things I get

39:31.119 --> 39:36.000 align:start position:0%
it y did you have your hand up yeah so

39:36.000 --> 39:37.520 align:start position:0%
as far as I understand there's pretty

39:37.520 --> 39:39.160 align:start position:0%
much no alternative to this like if you

39:39.160 --> 39:41.880 align:start position:0%
want to go with the it's either us

39:41.880 --> 39:44.800 align:start position:0%
spending a lot of resources handwriting

39:44.800 --> 39:48.040 align:start position:0%


39:48.040 --> 39:50.680 align:start position:0%
uh handwriting all of this kind of code

39:50.680 --> 39:53.280 align:start position:0%
pass generating them uh which is one of

39:53.280 --> 39:55.040 align:start position:0%
the hardest parts of the gy like this is

39:55.040 --> 39:58.520 align:start position:0%
a nice to a lot of

39:58.520 --> 40:02.200 align:start position:0%
resour it seems like the plan should be

40:02.200 --> 40:09.240 align:start position:0%


40:09.240 --> 40:11.440 align:start position:0%
main am

40:11.440 --> 40:15.560 align:start position:0%
I no that's how I feel as well um and

40:15.560 --> 40:17.400 align:start position:0%
and another thing too just since you

40:17.400 --> 40:19.319 align:start position:0%
mentioned handwriting assembly is that

40:19.319 --> 40:21.000 align:start position:0%
the two are not mutually exclusive so

40:21.000 --> 40:22.640 align:start position:0%
for example if we see that there's a

40:22.640 --> 40:25.119 align:start position:0%
really common op code and we see that we

40:25.119 --> 40:27.720 align:start position:0%
can actually write better than LM can

40:27.720 --> 40:30.040 align:start position:0%
for whatever reason we can do that the

40:30.040 --> 40:31.720 align:start position:0%
the two play very nicely together so it

40:31.720 --> 40:34.440 align:start position:0%
just be in that build script uh the 700

40:34.440 --> 40:36.160 align:start position:0%
lines of python or whatever we just

40:36.160 --> 40:37.480 align:start position:0%
special case that off code and say hey

40:37.480 --> 40:39.920 align:start position:0%
use this assembly file instead yeah Qui

40:39.920 --> 40:41.599 align:start position:0%
question P question on the on the

40:41.599 --> 40:43.359 align:start position:0%
Benchmark numbers that you show one of

40:43.359 --> 40:45.800 align:start position:0%
the slid so basically what they did they

40:45.800 --> 40:48.480 align:start position:0%
just repl so for example in the case of

40:48.480 --> 40:53.560 align:start position:0%
compil they just replaced the G uh Cod

40:53.560 --> 40:56.800 align:start position:0%
assembly and what not where the stop

40:56.800 --> 40:58.640 align:start position:0%
this

40:58.640 --> 41:02.440 align:start position:0%
appro no it was a completely uh like new

41:02.440 --> 41:04.480 align:start position:0%
implementation that they wrote so if you

41:04.480 --> 41:06.160 align:start position:0%
go to the blog post that I linked to

41:06.160 --> 41:09.520 align:start position:0%
earlier um it's a nice long blog post if

41:09.520 --> 41:10.680 align:start position:0%
you don't know anything about jits

41:10.680 --> 41:12.400 align:start position:0%
you'll know how jits work after reading

41:12.400 --> 41:14.520 align:start position:0%
it um and it goes over copy and patch

41:14.520 --> 41:16.119 align:start position:0%
and also things like inline caching and

41:16.119 --> 41:18.359 align:start position:0%
whatever but it's basically him

41:18.359 --> 41:22.400 align:start position:0%
implementing a Lua uh jit okay right and

41:22.400 --> 41:25.880 align:start position:0%
and so it's the so that yeah yeah so so

41:25.880 --> 41:28.160 align:start position:0%
it's it's the comparison of his just

41:28.160 --> 41:30.200 align:start position:0%
from scratch implementation versus an

41:30.200 --> 41:33.000 align:start position:0%
established fast

41:33.000 --> 41:36.800 align:start position:0%
implementation what is that I can put it

41:36.800 --> 41:38.119 align:start position:0%
back up

41:38.119 --> 41:41.040 align:start position:0%
there you could probably find it just by

41:41.040 --> 41:44.000 align:start position:0%
Google for a c yeah if you if you if you

41:44.000 --> 41:46.400 align:start position:0%
search for oh wait did I skip it already

41:46.400 --> 41:49.440 align:start position:0%
hang on I never saw the link to the blog

41:49.440 --> 41:53.599 align:start position:0%
post uh it was underneath the paper it's

41:53.599 --> 41:55.240 align:start position:0%
right

41:55.240 --> 41:59.880 align:start position:0%
here you haven't linked the che that yes

41:59.880 --> 42:04.079 align:start position:0%
I should indeed so the uh the top one is

42:04.079 --> 42:07.599 align:start position:0%
the paper the bottom one is the blog

42:07.599 --> 42:11.200 align:start position:0%
post and I just posted they did a

42:11.200 --> 42:14.440 align:start position:0%
presentation a few months ago as well

42:14.440 --> 42:17.200 align:start position:0%
was that for the paper good slides yeah

42:17.200 --> 42:18.760 align:start position:0%
and just as an

42:18.760 --> 42:21.400 align:start position:0%
FYI like that may be a new paper but we

42:21.400 --> 42:23.079 align:start position:0%
were doing this type of approach for a

42:23.079 --> 42:25.160 align:start position:0%
translator transmeta 20 years ago and I

42:25.160 --> 42:27.599 align:start position:0%
doubt we were the this but templates

42:27.599 --> 42:31.559 align:start position:0%
from regular yeah are very fast to yeah

42:31.559 --> 42:34.640 align:start position:0%
how was your experience with it I sh in

42:34.640 --> 42:40.319 align:start position:0%


42:40.319 --> 42:43.359 align:start position:0%
intermediate yeah I mean it is I kind of

42:43.359 --> 42:46.720 align:start position:0%
view this as a like a baseline but a

42:46.720 --> 42:48.880 align:start position:0%
really good one yeah right and so if we

42:48.880 --> 42:50.559 align:start position:0%
wanted to have another tier where we

42:50.559 --> 42:52.000 align:start position:0%
pull out all the stops on top of this

42:52.000 --> 42:54.119 align:start position:0%
that's a bridge we could cross right

42:54.119 --> 42:56.520 align:start position:0%
this is easy to maintain you don't have

42:56.520 --> 43:02.000 align:start position:0%


43:02.000 --> 43:04.359 align:start position:0%
was another question in terms of the Cod

43:04.359 --> 43:07.319 align:start position:0%
style will will you need to change a lot

43:07.319 --> 43:09.040 align:start position:0%
like I know that you compile some of the

43:09.040 --> 43:12.359 align:start position:0%
functions already but will the Cod style

43:12.359 --> 43:18.839 align:start position:0%


43:18.839 --> 43:22.319 align:start position:0%
same when you say the code style so we

43:22.319 --> 43:25.079 align:start position:0%
extract so basically the way you write

43:25.079 --> 43:29.559 align:start position:0%
code py code

43:29.559 --> 43:32.040 align:start position:0%
yes I'm I'm sure you'll see lots of blog

43:32.040 --> 43:33.960 align:start position:0%
posts of how to get the most out of C

43:33.960 --> 43:37.040 align:start position:0%
Python's new jit you know but those are

43:37.040 --> 43:42.359 align:start position:0%


43:42.359 --> 43:46.839 align:start position:0%


43:46.839 --> 43:49.359 align:start position:0%
yeah I I don't think it'll be any

43:49.359 --> 43:50.680 align:start position:0%
different than the specializing

43:50.680 --> 43:52.640 align:start position:0%
interpreter where it's just we play to

43:52.640 --> 43:54.480 align:start position:0%
the benchmarks the benchmarks we take to

43:54.480 --> 43:56.839 align:start position:0%
be somewhat realistic and we look to

43:56.839 --> 43:59.680 align:start position:0%
confirm that that is true in practice

43:59.680 --> 44:01.880 align:start position:0%
right um and I'm sure that there are

44:01.880 --> 44:04.960 align:start position:0%
people who you know like try to optimize

44:04.960 --> 44:06.640 align:start position:0%
for the specializing interpreter and I'm

44:06.640 --> 44:07.680 align:start position:0%
sure there'll be people who try to

44:07.680 --> 44:09.720 align:start position:0%
optimize for this but I think in general

44:09.720 --> 44:11.280 align:start position:0%
it'll just be a good low overhead way of

44:11.280 --> 44:15.920 align:start position:0%


44:15.920 --> 44:21.000 align:start position:0%
world we already I want everyone discuss

44:21.000 --> 44:24.920 align:start position:0%
so what is theing situation of this like

44:24.920 --> 44:26.520 align:start position:0%
for one of

44:26.520 --> 44:30.440 align:start position:0%


44:30.440 --> 44:40.760 align:start position:0%


44:40.760 --> 44:44.559 align:start position:0%
to yeah um so I don't know enough about

44:44.559 --> 44:46.440 align:start position:0%
unwind tables and that and like dwarf

44:46.440 --> 44:48.440 align:start position:0%
and all of that to give a good answer I

44:48.440 --> 44:50.520 align:start position:0%
can tell you that I don't include any

44:50.520 --> 44:52.559 align:start position:0%
unwind tables or dwarf in the jitted

44:52.559 --> 44:55.680 align:start position:0%
code and we disable frame pointers but

44:55.680 --> 44:56.680 align:start position:0%
if it's it's something that could be

44:56.680 --> 44:59.160 align:start position:0%
reused from the original elf um then

44:59.160 --> 45:00.280 align:start position:0%
that's something that would be easy to

45:00.280 --> 45:02.280 align:start position:0%
harvest uh otherwise we would have to

45:02.280 --> 45:04.920 align:start position:0%
kind of emit it ourselves when way will

45:04.920 --> 45:07.440 align:start position:0%
be maybe to May at the beginning when I

45:07.440 --> 45:10.040 align:start position:0%
mean at the beginning maybe when we are

45:10.040 --> 45:12.760 align:start position:0%
playing with maybe a che way is to allow

45:12.760 --> 45:15.359 align:start position:0%
at least to or detect if you're building

45:15.359 --> 45:17.040 align:start position:0%
python itself with frame pointers and

45:17.040 --> 45:18.800 align:start position:0%
then generating the template with frame

45:18.800 --> 45:21.920 align:start position:0%
pointers yeah I assume going to copy

45:21.920 --> 45:24.000 align:start position:0%
one yeah so we're disabling frame

45:24.000 --> 45:25.400 align:start position:0%
pointers right now just because we're

45:25.400 --> 45:26.960 align:start position:0%
passing argument registers and that's a

45:26.960 --> 45:29.079 align:start position:0%
valuable register um but I mean this

45:29.079 --> 45:30.520 align:start position:0%
argument's been had a million times so

45:30.520 --> 45:33.079 align:start position:0%
we can build with frame pointers you

45:33.079 --> 45:34.880 align:start position:0%
know it's easy enough just to say don't

45:34.880 --> 45:37.440 align:start position:0%
use that register right um and so that

45:37.440 --> 45:40.559 align:start position:0%
could be the first step and then again I

45:40.559 --> 45:41.960 align:start position:0%
I would need to do more research if I

45:41.960 --> 45:43.680 align:start position:0%
were to do it myself well at least

45:43.680 --> 45:47.440 align:start position:0%
having aouch I think a first kind of

45:47.440 --> 45:49.960 align:start position:0%
line

45:49.960 --> 45:54.880 align:start position:0%
cheap useful in you

45:54.880 --> 45:59.520 align:start position:0%


45:59.520 --> 46:04.200 align:start position:0%
side yeah if we were extract like if we

46:04.200 --> 46:06.760 align:start position:0%
could just extract all of this stuff

46:06.760 --> 46:09.079 align:start position:0%
from the elf file is that something that

46:09.079 --> 46:11.680 align:start position:0%
could be reused or would need to be

46:11.680 --> 46:13.720 align:start position:0%
different every time we emit a copy of

46:13.720 --> 46:17.240 align:start position:0%
that stencil you would need toch the

46:17.240 --> 46:18.839 align:start position:0%
relocations as well so there's

46:18.839 --> 46:22.440 align:start position:0%
relocations in the like the unwind

46:22.440 --> 46:24.839 align:start position:0%
tables and stuff the has like what is

46:24.839 --> 46:27.440 align:start position:0%
called and those will change when you

46:27.440 --> 46:29.319 align:start position:0%
place the code in different places so

46:29.319 --> 46:32.319 align:start position:0%
you need to somehow say oh this this

46:32.319 --> 46:36.040 align:start position:0%
code now Lees here so you need to say

46:36.040 --> 46:38.800 align:start position:0%
address things but most of the Annoying

46:38.800 --> 46:41.000 align:start position:0%
stuff to generate you can just copy okay

46:41.000 --> 46:42.960 align:start position:0%
yeah if it's if it's anything like the

46:42.960 --> 46:46.280 align:start position:0%
mechanics of extracting like for example

46:46.280 --> 46:50.559 align:start position:0%
static data BSS data executable text and

46:50.559 --> 46:52.160 align:start position:0%
processing relocations on those then the

46:52.160 --> 46:53.640 align:start position:0%
mechanics are almost identical it sounds

46:53.640 --> 46:54.800 align:start position:0%
like depends on

46:54.800 --> 46:59.079 align:start position:0%
how it to retri it from the file but if

46:59.079 --> 47:02.800 align:start position:0%
very easy and have some outut I suppose

47:02.800 --> 47:04.559 align:start position:0%
yeah like not like something that I

47:04.559 --> 47:07.000 align:start position:0%
think is super super important yeah two

47:07.000 --> 47:09.040 align:start position:0%
flags that I passed to clang currently

47:09.040 --> 47:11.800 align:start position:0%
are omit frame pointer and no

47:11.800 --> 47:16.160 align:start position:0%
asynchronous on wine tables um so if if

47:16.160 --> 47:18.040 align:start position:0%
we if if that's the sort of stuff that

47:18.040 --> 47:19.520 align:start position:0%
just gets dumped in the AL file and is

47:19.520 --> 47:21.440 align:start position:0%
reusable then it sounds like we have a

47:21.440 --> 47:22.920 align:start position:0%
promising path forward for a good

47:22.920 --> 47:24.720 align:start position:0%
debugging

47:24.720 --> 47:28.440 align:start position:0%


47:28.440 --> 47:34.359 align:start position:0%


47:34.359 --> 47:37.079 align:start position:0%
lot oh I didn't see I think we're

47:37.079 --> 47:40.880 align:start position:0%
getting too much into implementation

47:40.880 --> 47:48.559 align:start position:0%

