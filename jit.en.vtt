WEBVTT
Kind: captions
Language: en

00:00:06.480 --> 00:00:08.880 align:start position:0%
all right it's
 

00:00:08.880 --> 00:00:16.279 align:start position:0%
 
 

00:00:16.279 --> 00:00:18.840 align:start position:0%
talk all right so instead of giving this
 

00:00:18.840 --> 00:00:20.199 align:start position:0%
talk tomorrow by the way can everyone
 

00:00:20.199 --> 00:00:23.279 align:start position:0%
hear me or okay cool uh so instead of
 

00:00:23.279 --> 00:00:24.560 align:start position:0%
giving this talk tomorrow I'm giving it
 

00:00:24.560 --> 00:00:26.840 align:start position:0%
today uh I'm going to be sharing a
 

00:00:26.840 --> 00:00:28.760 align:start position:0%
little bit about something I have been
 

00:00:28.760 --> 00:00:30.400 align:start position:0%
thinking quite a bit about for last few
 

00:00:30.400 --> 00:00:32.840 align:start position:0%
months which is what Python's future jit
 

00:00:32.840 --> 00:00:35.440 align:start position:0%
compiler might look like or see Python's
 

00:00:35.440 --> 00:00:38.079 align:start position:0%
uh future jit compiler specifically um
 

00:00:38.079 --> 00:00:39.360 align:start position:0%
so I'm going to start with some
 

00:00:39.360 --> 00:00:42.079 align:start position:0%
background and this kind of um will also
 

00:00:42.079 --> 00:00:43.559 align:start position:0%
be good background for Ken's talk
 

00:00:43.559 --> 00:00:45.280 align:start position:0%
immediately after this on uh
 

00:00:45.280 --> 00:00:47.440 align:start position:0%
optimizations that we hope to perform uh
 

00:00:47.440 --> 00:00:50.440 align:start position:0%
specifically I'm mostly going to be uh
 

00:00:50.440 --> 00:00:52.000 align:start position:0%
kind of talking about some experiments
 

00:00:52.000 --> 00:00:54.280 align:start position:0%
that I've done with actually generating
 

00:00:54.280 --> 00:00:56.600 align:start position:0%
and executing machine code um not
 

00:00:56.600 --> 00:00:58.280 align:start position:0%
necessarily optimizations and things
 

00:00:58.280 --> 00:01:00.120 align:start position:0%
that happen in the meantime however I
 

00:01:00.120 --> 00:01:01.680 align:start position:0%
will be giving some background on that
 

00:01:01.680 --> 00:01:03.120 align:start position:0%
because I think it's really helpful for
 

00:01:03.120 --> 00:01:04.880 align:start position:0%
understanding how everything ties
 

00:01:04.880 --> 00:01:07.799 align:start position:0%
together um so a little recent history
 

00:01:07.799 --> 00:01:09.560 align:start position:0%
in cpython
 

00:01:09.560 --> 00:01:11.720 align:start position:0%
3.11 uh one of the headline features was
 

00:01:11.720 --> 00:01:14.880 align:start position:0%
the specializing adaptive interpreter um
 

00:01:14.880 --> 00:01:17.400 align:start position:0%
and so this delivered uh really good
 

00:01:17.400 --> 00:01:19.080 align:start position:0%
speedups I think the number we quoted
 

00:01:19.080 --> 00:01:22.200 align:start position:0%
most widely was something like 25% um if
 

00:01:22.200 --> 00:01:24.040 align:start position:0%
you want to take that at face value that
 

00:01:24.040 --> 00:01:26.240 align:start position:0%
it was just a one-time performance gain
 

00:01:26.240 --> 00:01:29.640 align:start position:0%
um that was nice to have then sure but
 

00:01:29.640 --> 00:01:31.400 align:start position:0%
if if you think about it and you read a
 

00:01:31.400 --> 00:01:32.600 align:start position:0%
little bit between the lines you
 

00:01:32.600 --> 00:01:33.799 align:start position:0%
understand that we're now collecting
 

00:01:33.799 --> 00:01:37.520 align:start position:0%
runtime profiling data for uh user code
 

00:01:37.520 --> 00:01:38.600 align:start position:0%
and that's something that we can use
 

00:01:38.600 --> 00:01:40.640 align:start position:0%
later if we want to lower that code and
 

00:01:40.640 --> 00:01:42.280 align:start position:0%
make it more statically
 

00:01:42.280 --> 00:01:46.159 align:start position:0%
typed in cpython 3.12 um we got a nice
 

00:01:46.159 --> 00:01:47.840 align:start position:0%
quality of life Improvement as
 

00:01:47.840 --> 00:01:50.600 align:start position:0%
maintainers uh we started generating The
 

00:01:50.600 --> 00:01:53.520 align:start position:0%
Interpreter cases the main switch from a
 

00:01:53.520 --> 00:01:55.759 align:start position:0%
domain specific language um and this
 

00:01:55.759 --> 00:01:59.920 align:start position:0%
allowed us to like an analyze and modify
 

00:01:59.920 --> 00:02:01.240 align:start position:0%
uh parts of The Interpreter at build
 

00:02:01.240 --> 00:02:03.840 align:start position:0%
time um this is really helpful for the
 

00:02:03.840 --> 00:02:05.840 align:start position:0%
people actually working on the bite code
 

00:02:05.840 --> 00:02:09.840 align:start position:0%
because we can uh uh worry less about
 

00:02:09.840 --> 00:02:12.560 align:start position:0%
things like uh error handling reference
 

00:02:12.560 --> 00:02:17.440 align:start position:0%
counts uh uh adding uh counters and
 

00:02:17.440 --> 00:02:19.480 align:start position:0%
stats and all those sorts of things um
 

00:02:19.480 --> 00:02:21.400 align:start position:0%
but at the same time again if you can
 

00:02:21.400 --> 00:02:23.160 align:start position:0%
kind of read between the lines uh we now
 

00:02:23.160 --> 00:02:24.440 align:start position:0%
are able to generate multiple
 

00:02:24.440 --> 00:02:26.160 align:start position:0%
interpreters um from a single source of
 

00:02:26.160 --> 00:02:29.160 align:start position:0%
Truth um and we also are able to
 

00:02:29.160 --> 00:02:31.239 align:start position:0%
generate lots of metadata uh by
 

00:02:31.239 --> 00:02:33.319 align:start position:0%
analyzing that single source of
 

00:02:33.319 --> 00:02:35.480 align:start position:0%
Truth so in
 

00:02:35.480 --> 00:02:38.040 align:start position:0%
313 um and again this is all stuff
 

00:02:38.040 --> 00:02:40.760 align:start position:0%
that's actually currently on Main um we
 

00:02:40.760 --> 00:02:42.680 align:start position:0%
do have an internal pipeline for
 

00:02:42.680 --> 00:02:45.360 align:start position:0%
detecting optimizing and executing hot
 

00:02:45.360 --> 00:02:47.840 align:start position:0%
code paths so this is off by default but
 

00:02:47.840 --> 00:02:50.239 align:start position:0%
if you build Python and you set the
 

00:02:50.239 --> 00:02:51.599 align:start position:0%
right environment variable or pass the
 

00:02:51.599 --> 00:02:54.959 align:start position:0%
right X option it's called uops
 

00:02:54.959 --> 00:02:59.560 align:start position:0%
uops Uh basically cpython will uh find
 

00:02:59.560 --> 00:03:02.239 align:start position:0%
hot Loops in your codee it will
 

00:03:02.239 --> 00:03:05.440 align:start position:0%
basically uh build a trace of that Loop
 

00:03:05.440 --> 00:03:08.840 align:start position:0%
and it will break it up into uh a more
 

00:03:08.840 --> 00:03:09.799 align:start position:0%
efficient
 

00:03:09.799 --> 00:03:12.799 align:start position:0%
representation and uh optimize it do
 

00:03:12.799 --> 00:03:15.120 align:start position:0%
some light optimization and execute it
 

00:03:15.120 --> 00:03:18.440 align:start position:0%
in a second interpreter now currently
 

00:03:18.440 --> 00:03:19.720 align:start position:0%
this is actually a little bit slower so
 

00:03:19.720 --> 00:03:21.000 align:start position:0%
you don't want to turn it on it's like a
 

00:03:21.000 --> 00:03:22.920 align:start position:0%
five or six% slower just because it's
 

00:03:22.920 --> 00:03:24.920 align:start position:0%
kind of the first phase of this entire
 

00:03:24.920 --> 00:03:27.360 align:start position:0%
pipeline um and in the end The
 

00:03:27.360 --> 00:03:29.519 align:start position:0%
Interpreter isn't really what we want to
 

00:03:29.519 --> 00:03:32.040 align:start position:0%
be executing these things I'll get to
 

00:03:32.040 --> 00:03:34.040 align:start position:0%
that later um but basically this
 

00:03:34.040 --> 00:03:35.280 align:start position:0%
wouldn't be possible without either of
 

00:03:35.280 --> 00:03:37.480 align:start position:0%
the first two steps um being able to
 

00:03:37.480 --> 00:03:39.560 align:start position:0%
break uh big complicated bite code
 

00:03:39.560 --> 00:03:41.239 align:start position:0%
instructions down into more simple
 

00:03:41.239 --> 00:03:43.760 align:start position:0%
Atomic steps is only possible because of
 

00:03:43.760 --> 00:03:46.599 align:start position:0%
the changes made in uh 3.11 for
 

00:03:46.599 --> 00:03:49.040 align:start position:0%
specialization and in 3.12 where we're
 

00:03:49.040 --> 00:03:51.720 align:start position:0%
able to Define uh uh bite code
 

00:03:51.720 --> 00:03:54.640 align:start position:0%
instructions in terms of smaller
 

00:03:54.640 --> 00:03:58.400 align:start position:0%
steps so I like uh providing examples
 

00:03:58.400 --> 00:03:59.840 align:start position:0%
just so we can kind of walk through what
 

00:03:59.840 --> 00:04:01.280 align:start position:0%
this pipeline looks like in practice and
 

00:04:01.280 --> 00:04:02.599 align:start position:0%
what it may look like in the future so
 

00:04:02.599 --> 00:04:03.879 align:start position:0%
we're going to look at my Fibonacci
 

00:04:03.879 --> 00:04:05.760 align:start position:0%
function here um it's pretty
 

00:04:05.760 --> 00:04:07.319 align:start position:0%
straightforward and specifically we're
 

00:04:07.319 --> 00:04:09.640 align:start position:0%
going to focus on the inner loop um it's
 

00:04:09.640 --> 00:04:11.280 align:start position:0%
pretty simple we're just looping over
 

00:04:11.280 --> 00:04:13.280 align:start position:0%
the range and then we update the values
 

00:04:13.280 --> 00:04:16.440 align:start position:0%
for A and B by adding A and B
 

00:04:16.440 --> 00:04:19.079 align:start position:0%
together uh so if you look at the bite
 

00:04:19.079 --> 00:04:20.359 align:start position:0%
code for this function it'll look
 

00:04:20.359 --> 00:04:25.120 align:start position:0%
something like this um uh you
 

00:04:25.120 --> 00:04:27.199 align:start position:0%
know if you want to know how the bite
 

00:04:27.199 --> 00:04:28.639 align:start position:0%
code works you can look at the disc
 

00:04:28.639 --> 00:04:30.520 align:start position:0%
documentation um but basically these are
 

00:04:30.520 --> 00:04:33.919 align:start position:0%
generic instructions um that have mostly
 

00:04:33.919 --> 00:04:35.800 align:start position:0%
remained unchanged since the earliest
 

00:04:35.800 --> 00:04:37.199 align:start position:0%
versions of
 

00:04:37.199 --> 00:04:40.560 align:start position:0%
python um however in 311 we got our
 

00:04:40.560 --> 00:04:43.080 align:start position:0%
specialized bite code um so that took
 

00:04:43.080 --> 00:04:45.120 align:start position:0%
generic operations like for iter and
 

00:04:45.120 --> 00:04:48.360 align:start position:0%
binary up and allowed us to specialize
 

00:04:48.360 --> 00:04:50.000 align:start position:0%
those at runtime for example for
 

00:04:50.000 --> 00:04:52.520 align:start position:0%
iterating over a range object or adding
 

00:04:52.520 --> 00:04:54.360 align:start position:0%
two integers
 

00:04:54.360 --> 00:04:58.759 align:start position:0%
together um so that's great um now in
 

00:04:58.759 --> 00:05:02.600 align:start position:0%
313 we're building micro op traces and
 

00:05:02.600 --> 00:05:04.360 align:start position:0%
so these Micro Ops are those smaller
 

00:05:04.360 --> 00:05:06.000 align:start position:0%
more Atomic steps that I was talking
 

00:05:06.000 --> 00:05:07.199 align:start position:0%
about that we're able to break
 

00:05:07.199 --> 00:05:11.360 align:start position:0%
individual instructions uh up into um so
 

00:05:11.360 --> 00:05:13.240 align:start position:0%
as I mentioned before you can actually
 

00:05:13.240 --> 00:05:15.560 align:start position:0%
run these things off of Main by passing
 

00:05:15.560 --> 00:05:18.759 align:start position:0%
The X option uops um and when you do
 

00:05:18.759 --> 00:05:20.600 align:start position:0%
that we will collect a trace for this
 

00:05:20.600 --> 00:05:22.440 align:start position:0%
Loop and we'll actually break each of
 

00:05:22.440 --> 00:05:25.160 align:start position:0%
these instructions up into uh their
 

00:05:25.160 --> 00:05:26.840 align:start position:0%
individual components so you can see
 

00:05:26.840 --> 00:05:28.280 align:start position:0%
that for some of the simpler
 

00:05:28.280 --> 00:05:30.479 align:start position:0%
instructions uh in they may only expand
 

00:05:30.479 --> 00:05:32.960 align:start position:0%
to uh two Micro Ops and that's what we
 

00:05:32.960 --> 00:05:35.440 align:start position:0%
call them Micro Ops um but the more
 

00:05:35.440 --> 00:05:38.319 align:start position:0%
complicated ones like for it range or um
 

00:05:38.319 --> 00:05:40.240 align:start position:0%
the integer addition may have several
 

00:05:40.240 --> 00:05:42.479 align:start position:0%
different parts um and what's nice about
 

00:05:42.479 --> 00:05:44.479 align:start position:0%
breaking those parts up is that if any
 

00:05:44.479 --> 00:05:45.919 align:start position:0%
of the parts are redundant for example
 

00:05:45.919 --> 00:05:47.080 align:start position:0%
if we're checking that something's an
 

00:05:47.080 --> 00:05:48.680 align:start position:0%
integer when we can actually prove that
 

00:05:48.680 --> 00:05:51.520 align:start position:0%
it's an integer then we can remove it um
 

00:05:51.520 --> 00:05:53.319 align:start position:0%
or if we want to move things around
 

00:05:53.319 --> 00:05:55.000 align:start position:0%
that's an option as
 

00:05:55.000 --> 00:05:59.600 align:start position:0%
well uh so another thing that uh 313
 

00:05:59.600 --> 00:06:01.720 align:start position:0%
Maine will currently do for you is we'll
 

00:06:01.720 --> 00:06:03.280 align:start position:0%
do some light optimization on these
 

00:06:03.280 --> 00:06:05.120 align:start position:0%
Micro Ops um So currently the only
 

00:06:05.120 --> 00:06:07.800 align:start position:0%
optimization we perform is we'll find a
 

00:06:07.800 --> 00:06:09.720 align:start position:0%
redundant frame pointer updates
 

00:06:09.720 --> 00:06:11.840 align:start position:0%
basically if we have an operation that
 

00:06:11.840 --> 00:06:14.280 align:start position:0%
cannot fail or the control flow cannot
 

00:06:14.280 --> 00:06:16.280 align:start position:0%
move uh to any other point in the
 

00:06:16.280 --> 00:06:18.680 align:start position:0%
program there's no reason for us to
 

00:06:18.680 --> 00:06:20.039 align:start position:0%
update the frame and say oh we're
 

00:06:20.039 --> 00:06:22.199 align:start position:0%
currently executing this instruction um
 

00:06:22.199 --> 00:06:24.199 align:start position:0%
so it's a very very simple optimization
 

00:06:24.199 --> 00:06:25.880 align:start position:0%
but it does work as a nice proof of
 

00:06:25.880 --> 00:06:28.000 align:start position:0%
concept and so um we will actually
 

00:06:28.000 --> 00:06:30.599 align:start position:0%
identify these four or set IP
 

00:06:30.599 --> 00:06:32.800 align:start position:0%
instructions and uh just remove them for
 

00:06:32.800 --> 00:06:35.080 align:start position:0%
you so that's just pure overhead that uh
 

00:06:35.080 --> 00:06:36.319 align:start position:0%
we're able to
 

00:06:36.319 --> 00:06:39.039 align:start position:0%
remove in the future and Ken will talk a
 

00:06:39.039 --> 00:06:40.440 align:start position:0%
little bit more about this we'll be able
 

00:06:40.440 --> 00:06:42.919 align:start position:0%
to do uh Stronger optimizations uh where
 

00:06:42.919 --> 00:06:44.560 align:start position:0%
we're able to remove more expensive
 

00:06:44.560 --> 00:06:46.800 align:start position:0%
checks so for instance if we can
 

00:06:46.800 --> 00:06:48.520 align:start position:0%
statically prove as we can in the case
 

00:06:48.520 --> 00:06:50.800 align:start position:0%
of this function that for example we're
 

00:06:50.800 --> 00:06:52.479 align:start position:0%
always iterating over a range object
 

00:06:52.479 --> 00:06:54.479 align:start position:0%
once we've entered this Loop and that uh
 

00:06:54.479 --> 00:06:56.400 align:start position:0%
A and B are both integers once we've
 

00:06:56.400 --> 00:06:58.080 align:start position:0%
entered this Loop then we can also
 

00:06:58.080 --> 00:07:00.560 align:start position:0%
remove those as well and what's left is
 

00:07:00.560 --> 00:07:02.199 align:start position:0%
basically the bare minimum amount of
 

00:07:02.199 --> 00:07:05.280 align:start position:0%
work required to uh actually execute
 

00:07:05.280 --> 00:07:06.960 align:start position:0%
this hot Inner Loop and you'll notice
 

00:07:06.960 --> 00:07:08.759 align:start position:0%
that this is entirely statically typed
 

00:07:08.759 --> 00:07:10.759 align:start position:0%
which is great for further
 

00:07:10.759 --> 00:07:14.000 align:start position:0%
lowering so um once we've removed all of
 

00:07:14.000 --> 00:07:15.960 align:start position:0%
that kind of extra stuff that we can
 

00:07:15.960 --> 00:07:19.000 align:start position:0%
prove we don't actually need then comes
 

00:07:19.000 --> 00:07:20.800 align:start position:0%
just in time compilation and that's kind
 

00:07:20.800 --> 00:07:21.800 align:start position:0%
of what I'm going to spend the rest of
 

00:07:21.800 --> 00:07:23.440 align:start position:0%
this uh time talking
 

00:07:23.440 --> 00:07:25.879 align:start position:0%
about um we have a couple different
 

00:07:25.879 --> 00:07:28.000 align:start position:0%
goals with the Justin Time compilation
 

00:07:28.000 --> 00:07:31.120 align:start position:0%
so um our main overarching goal is to
 

00:07:31.120 --> 00:07:33.680 align:start position:0%
remove interpretive overhead so we have
 

00:07:33.680 --> 00:07:37.039 align:start position:0%
removed all the extra sort of uh Dynamic
 

00:07:37.039 --> 00:07:39.599 align:start position:0%
work that needs to take place um but
 

00:07:39.599 --> 00:07:42.280 align:start position:0%
there's still a lot of other kind of
 

00:07:42.280 --> 00:07:43.919 align:start position:0%
overhead that just comes from the way
 

00:07:43.919 --> 00:07:46.280 align:start position:0%
the uh virtual machine is laid out and
 

00:07:46.280 --> 00:07:49.759 align:start position:0%
the way it interacts with data um so we
 

00:07:49.759 --> 00:07:51.520 align:start position:0%
want to remove interpretive overhead by
 

00:07:51.520 --> 00:07:53.639 align:start position:0%
statically compiling these optimized
 

00:07:53.639 --> 00:07:56.319 align:start position:0%
traces um and statically compiling them
 

00:07:56.319 --> 00:07:59.840 align:start position:0%
allows to us to reduce indirection um
 

00:07:59.840 --> 00:08:01.639 align:start position:0%
through a few different ways first of
 

00:08:01.639 --> 00:08:05.199 align:start position:0%
all we can burn in uh basically uh
 

00:08:05.199 --> 00:08:07.879 align:start position:0%
encode directly into the machine code
 

00:08:07.879 --> 00:08:10.599 align:start position:0%
the values of constants caches and uh
 

00:08:10.599 --> 00:08:13.440 align:start position:0%
arguments to instructions so basically
 

00:08:13.440 --> 00:08:16.080 align:start position:0%
uh instead of decoding uh in
 

00:08:16.080 --> 00:08:18.720 align:start position:0%
instructions uh opar every single time
 

00:08:18.720 --> 00:08:20.800 align:start position:0%
we execute that instruction we can
 

00:08:20.800 --> 00:08:23.000 align:start position:0%
instead for example make it an immediate
 

00:08:23.000 --> 00:08:26.159 align:start position:0%
value to uh an instruction in actual
 

00:08:26.159 --> 00:08:29.560 align:start position:0%
machine code um which uh repl is a
 

00:08:29.560 --> 00:08:31.280 align:start position:0%
memory load is a lot more Compact and a
 

00:08:31.280 --> 00:08:32.159 align:start position:0%
lot more
 

00:08:32.159 --> 00:08:34.599 align:start position:0%
efficient um we can also do things like
 

00:08:34.599 --> 00:08:36.320 align:start position:0%
moving data off of frames and into
 

00:08:36.320 --> 00:08:39.360 align:start position:0%
registers so the Micro Ops still execute
 

00:08:39.360 --> 00:08:41.640 align:start position:0%
on a python frame which means that
 

00:08:41.640 --> 00:08:43.360 align:start position:0%
intermediate values that live on the
 

00:08:43.360 --> 00:08:46.519 align:start position:0%
value stack are all still being written
 

00:08:46.519 --> 00:08:48.920 align:start position:0%
to memory and read from memory um so if
 

00:08:48.920 --> 00:08:50.680 align:start position:0%
we can lift all of that stuff out of
 

00:08:50.680 --> 00:08:52.600 align:start position:0%
memory and into actual Hardware
 

00:08:52.600 --> 00:08:55.360 align:start position:0%
registers um that saves a lot of traffic
 

00:08:55.360 --> 00:08:57.519 align:start position:0%
uh to and from uh main memory which is
 

00:08:57.519 --> 00:08:59.680 align:start position:0%
always a good thing um finally we can
 

00:08:59.680 --> 00:09:01.640 align:start position:0%
bring hot code paths in line so instead
 

00:09:01.640 --> 00:09:04.480 align:start position:0%
of having a uh large interpreter where
 

00:09:04.480 --> 00:09:06.720 align:start position:0%
we have all of these different cases uh
 

00:09:06.720 --> 00:09:08.279 align:start position:0%
that all need to be present because we
 

00:09:08.279 --> 00:09:10.880 align:start position:0%
can jump into them at any time um here
 

00:09:10.880 --> 00:09:12.640 align:start position:0%
we can make a straight line code path
 

00:09:12.640 --> 00:09:14.959 align:start position:0%
that executes exactly those instructions
 

00:09:14.959 --> 00:09:16.640 align:start position:0%
that I showed on the previous
 

00:09:16.640 --> 00:09:19.000 align:start position:0%
slide now these need to be weighed
 

00:09:19.000 --> 00:09:22.800 align:start position:0%
against some like practical goals right
 

00:09:22.800 --> 00:09:24.640 align:start position:0%
like I I don't think anyone wants me to
 

00:09:24.640 --> 00:09:27.720 align:start position:0%
dump like a 10,000 line C++ jit on us
 

00:09:27.720 --> 00:09:30.800 align:start position:0%
right so uh the first thing is Broad
 

00:09:30.800 --> 00:09:32.640 align:start position:0%
platform support python runs lots of
 

00:09:32.640 --> 00:09:35.000 align:start position:0%
places and arjit should too um I think
 

00:09:35.000 --> 00:09:36.440 align:start position:0%
that this is an ambitious goal but it's
 

00:09:36.440 --> 00:09:39.959 align:start position:0%
an important one uh I think that uh it
 

00:09:39.959 --> 00:09:42.240 align:start position:0%
should have few runtime dependencies for
 

00:09:42.240 --> 00:09:45.519 align:start position:0%
example I would like for this jit to be
 

00:09:45.519 --> 00:09:48.279 align:start position:0%
in a place where uh for example users
 

00:09:48.279 --> 00:09:50.680 align:start position:0%
wouldn't need to have a full lovm
 

00:09:50.680 --> 00:09:53.040 align:start position:0%
install for example um I don't think
 

00:09:53.040 --> 00:09:55.120 align:start position:0%
that's a good user experience it can
 

00:09:55.120 --> 00:09:56.680 align:start position:0%
maybe be made into a good user
 

00:09:56.680 --> 00:09:58.839 align:start position:0%
experience but I think I'd rather start
 

00:09:58.839 --> 00:10:01.120 align:start position:0%
from a place where you just download
 

00:10:01.120 --> 00:10:03.120 align:start position:0%
python the same way as you always have
 

00:10:03.120 --> 00:10:04.600 align:start position:0%
and everything just
 

00:10:04.600 --> 00:10:07.760 align:start position:0%
works um and finally and perhaps most
 

00:10:07.760 --> 00:10:10.120 align:start position:0%
importantly to me uh low implementation
 

00:10:10.120 --> 00:10:12.480 align:start position:0%
complexity um see python is
 

00:10:12.480 --> 00:10:14.920 align:start position:0%
overwhelmingly maintained by volunteers
 

00:10:14.920 --> 00:10:18.640 align:start position:0%
um and so I think that uh being able to
 

00:10:18.640 --> 00:10:22.120 align:start position:0%
keep the complexity down uh is a really
 

00:10:22.120 --> 00:10:24.279 align:start position:0%
really important goal to keep in mind in
 

00:10:24.279 --> 00:10:27.000 align:start position:0%
fact um I personally feel like it's
 

00:10:27.000 --> 00:10:28.760 align:start position:0%
worth sacrificing Peak Performance in
 

00:10:28.760 --> 00:10:30.880 align:start position:0%
order to keep the implementation as
 

00:10:30.880 --> 00:10:33.120 align:start position:0%
simple easy to maintain and easy to
 

00:10:33.120 --> 00:10:35.480 align:start position:0%
understand and teach and learn as
 

00:10:35.480 --> 00:10:38.760 align:start position:0%
possible um and so these are competing
 

00:10:38.760 --> 00:10:41.000 align:start position:0%
goals right like we want to make things
 

00:10:41.000 --> 00:10:43.600 align:start position:0%
fast but we're also willing to as I said
 

00:10:43.600 --> 00:10:45.639 align:start position:0%
sacrifice Peak Performance to make sure
 

00:10:45.639 --> 00:10:48.160 align:start position:0%
that you know this is something that we
 

00:10:48.160 --> 00:10:50.880 align:start position:0%
can all uh understand and that we can
 

00:10:50.880 --> 00:10:52.600 align:start position:0%
all maintain for the Long
 

00:10:52.600 --> 00:10:57.880 align:start position:0%
Haul so uh one kind of uh recent
 

00:10:57.880 --> 00:11:01.399 align:start position:0%
development uh in jit compiler
 

00:11:01.399 --> 00:11:03.680 align:start position:0%
technology is something called copy and
 

00:11:03.680 --> 00:11:05.120 align:start position:0%
Patch compilation and it actually
 

00:11:05.120 --> 00:11:07.000 align:start position:0%
fulfills many of these goals in a really
 

00:11:07.000 --> 00:11:09.480 align:start position:0%
satisfying way um so if you haven't
 

00:11:09.480 --> 00:11:11.639 align:start position:0%
heard about it which you know I hadn't
 

00:11:11.639 --> 00:11:14.279 align:start position:0%
heard about it that long ago um copy and
 

00:11:14.279 --> 00:11:16.800 align:start position:0%
Patch compilation comes out of a
 

00:11:16.800 --> 00:11:19.880 align:start position:0%
Stanford paper um but if you don't like
 

00:11:19.880 --> 00:11:22.399 align:start position:0%
reading the paper I highly recommend the
 

00:11:22.399 --> 00:11:24.160 align:start position:0%
uh blog post there's a blog post called
 

00:11:24.160 --> 00:11:26.079 align:start position:0%
building a baseline jit for Lua
 

00:11:26.079 --> 00:11:27.600 align:start position:0%
automatically this is by the same author
 

00:11:27.600 --> 00:11:29.079 align:start position:0%
as the paper and I've actually spoken
 

00:11:29.079 --> 00:11:31.480 align:start position:0%
with him on a couple occasions um
 

00:11:31.480 --> 00:11:35.200 align:start position:0%
basically this is a way of uh turning a
 

00:11:35.200 --> 00:11:38.200 align:start position:0%
c interpreter into a fast template jip
 

00:11:38.200 --> 00:11:41.279 align:start position:0%
compiler um and what's really really
 

00:11:41.279 --> 00:11:43.560 align:start position:0%
nice is that we are able to maintain
 

00:11:43.560 --> 00:11:45.399 align:start position:0%
that single source of Truth for how B
 

00:11:45.399 --> 00:11:47.320 align:start position:0%
code instruction should be implemented
 

00:11:47.320 --> 00:11:48.880 align:start position:0%
it doesn't require us to hand write
 

00:11:48.880 --> 00:11:51.160 align:start position:0%
assembly which means that if you want to
 

00:11:51.160 --> 00:11:53.399 align:start position:0%
fix a bug in The Interpreter and you
 

00:11:53.399 --> 00:11:55.720 align:start position:0%
already know how to fix bugs in The
 

00:11:55.720 --> 00:11:58.000 align:start position:0%
Interpreter the jib will be fixed too
 

00:11:58.000 --> 00:11:59.519 align:start position:0%
without you having to actually do
 

00:11:59.519 --> 00:12:01.000 align:start position:0%
anything we have that one source of
 

00:12:01.000 --> 00:12:02.399 align:start position:0%
Truth and everything's built
 

00:12:02.399 --> 00:12:04.360 align:start position:0%
automatically for you but the jit itself
 

00:12:04.360 --> 00:12:06.000 align:start position:0%
is still really fast and has good
 

00:12:06.000 --> 00:12:08.519 align:start position:0%
quality code um if you don't believe me
 

00:12:08.519 --> 00:12:10.399 align:start position:0%
here are some numbers from the paper
 

00:12:10.399 --> 00:12:12.360 align:start position:0%
compared to a web assembly Baseline
 

00:12:12.360 --> 00:12:14.680 align:start position:0%
compiler um copy and Patch has five
 

00:12:14.680 --> 00:12:17.160 align:start position:0%
times faster code generation and 50%
 

00:12:17.160 --> 00:12:19.560 align:start position:0%
faster code overall the code quality is
 

00:12:19.560 --> 00:12:21.040 align:start position:0%
really good and I'll show you why in a
 

00:12:21.040 --> 00:12:24.000 align:start position:0%
second um compared to a mid-tier
 

00:12:24.000 --> 00:12:27.120 align:start position:0%
compiler uh like a traditional J tool
 

00:12:27.120 --> 00:12:29.880 align:start position:0%
tool chain which would be lvm with a low
 

00:12:29.880 --> 00:12:32.320 align:start position:0%
optimization level to keep things fast
 

00:12:32.320 --> 00:12:34.440 align:start position:0%
um it has 100 times faster code
 

00:12:34.440 --> 00:12:38.279 align:start position:0%
generation and still 15% faster code and
 

00:12:38.279 --> 00:12:40.519 align:start position:0%
just to kind of complete the numbers uh
 

00:12:40.519 --> 00:12:42.800 align:start position:0%
compared to a full optimizing jit with
 

00:12:42.800 --> 00:12:44.639 align:start position:0%
handwritten assembly so in this case L
 

00:12:44.639 --> 00:12:47.560 align:start position:0%
jit um a copy and Patch low
 

00:12:47.560 --> 00:12:49.920 align:start position:0%
implementation it's still faster on some
 

00:12:49.920 --> 00:12:52.120 align:start position:0%
benchmarks and it's only 35% slower
 

00:12:52.120 --> 00:12:54.279 align:start position:0%
overall despite being much much simpler
 

00:12:54.279 --> 00:12:55.440 align:start position:0%
to
 

00:12:55.440 --> 00:12:59.399 align:start position:0%
maintain so how does it work well
 

00:12:59.399 --> 00:13:02.240 align:start position:0%
let's think about um the kind of
 

00:13:02.240 --> 00:13:05.320 align:start position:0%
simplest form of a template jit compiler
 

00:13:05.320 --> 00:13:07.360 align:start position:0%
if we want to compile uh sequence of
 

00:13:07.360 --> 00:13:09.000 align:start position:0%
bite code instructions to machine code
 

00:13:09.000 --> 00:13:11.600 align:start position:0%
as fast as possible at runtime what it
 

00:13:11.600 --> 00:13:13.279 align:start position:0%
might look like is walking over that
 

00:13:13.279 --> 00:13:15.199 align:start position:0%
sequence of bite code instructions and
 

00:13:15.199 --> 00:13:17.839 align:start position:0%
then for each one copying over some
 

00:13:17.839 --> 00:13:20.199 align:start position:0%
static pre-compiled machine code into
 

00:13:20.199 --> 00:13:23.240 align:start position:0%
executable memory and then going through
 

00:13:23.240 --> 00:13:24.760 align:start position:0%
that machine code and patching up
 

00:13:24.760 --> 00:13:26.240 align:start position:0%
instructions that need to have runtime
 

00:13:26.240 --> 00:13:28.639 align:start position:0%
data encoded in them um so these would
 

00:13:28.639 --> 00:13:31.079 align:start position:0%
the be things like op bars uh constants
 

00:13:31.079 --> 00:13:33.240 align:start position:0%
that we want to burn in things like
 

00:13:33.240 --> 00:13:35.639 align:start position:0%
that now if you look at these two
 

00:13:35.639 --> 00:13:37.760 align:start position:0%
requirements um you'll notice that this
 

00:13:37.760 --> 00:13:39.279 align:start position:0%
sounds a lot like something we already
 

00:13:39.279 --> 00:13:42.199 align:start position:0%
have which are relocatable object files
 

00:13:42.199 --> 00:13:44.519 align:start position:0%
so uh I could just as easily say when
 

00:13:44.519 --> 00:13:46.560 align:start position:0%
linking or loading an elf file we want
 

00:13:46.560 --> 00:13:48.519 align:start position:0%
to copy some static pre-compiled machine
 

00:13:48.519 --> 00:13:50.720 align:start position:0%
code into executable memory and then we
 

00:13:50.720 --> 00:13:51.959 align:start position:0%
want to patch up the instructions that
 

00:13:51.959 --> 00:13:53.480 align:start position:0%
need to have run some data encoded in
 

00:13:53.480 --> 00:13:55.519 align:start position:0%
them these are relocations for like X
 

00:13:55.519 --> 00:13:56.480 align:start position:0%
turn
 

00:13:56.480 --> 00:13:58.959 align:start position:0%
symbols and so this is how copy and P
 

00:13:58.959 --> 00:14:03.519 align:start position:0%
Works um basically we uh will use llvm
 

00:14:03.519 --> 00:14:07.120 align:start position:0%
to build an elf object file and then we
 

00:14:07.120 --> 00:14:08.440 align:start position:0%
parse out the stuff that we care about
 

00:14:08.440 --> 00:14:10.519 align:start position:0%
from that elf object file namely the
 

00:14:10.519 --> 00:14:12.440 align:start position:0%
body of the bite code instruction and
 

00:14:12.440 --> 00:14:14.160 align:start position:0%
any information on how we need to fix up
 

00:14:14.160 --> 00:14:16.279 align:start position:0%
the stuff that we want to fix out so I'm
 

00:14:16.279 --> 00:14:18.040 align:start position:0%
going to give you a concrete example and
 

00:14:18.040 --> 00:14:19.800 align:start position:0%
by concrete I mean I'm glossing over
 

00:14:19.800 --> 00:14:21.639 align:start position:0%
some details so take everything at like
 

00:14:21.639 --> 00:14:25.839 align:start position:0%
80% face value okay so uh we have a load
 

00:14:25.839 --> 00:14:28.240 align:start position:0%
fast instruction here um we are going to
 

00:14:28.240 --> 00:14:30.000 align:start position:0%
take the body of that load fast
 

00:14:30.000 --> 00:14:32.519 align:start position:0%
instruction we're going to put it inside
 

00:14:32.519 --> 00:14:34.519 align:start position:0%
of some other code that is going to be
 

00:14:34.519 --> 00:14:36.639 align:start position:0%
sort of the scaffolding that we need to
 

00:14:36.639 --> 00:14:38.079 align:start position:0%
be able to extract the stuff that we
 

00:14:38.079 --> 00:14:39.959 align:start position:0%
care about later and be able to stitch
 

00:14:39.959 --> 00:14:42.079 align:start position:0%
everything together so in this example
 

00:14:42.079 --> 00:14:44.399 align:start position:0%
we are going to be burning in the opar
 

00:14:44.399 --> 00:14:46.839 align:start position:0%
and we are going to be basically jumping
 

00:14:46.839 --> 00:14:48.519 align:start position:0%
into the next bite code instruction
 

00:14:48.519 --> 00:14:49.519 align:start position:0%
because we need to make sure that the
 

00:14:49.519 --> 00:14:51.839 align:start position:0%
code is laid out in a way that we can
 

00:14:51.839 --> 00:14:53.839 align:start position:0%
flow from one instruction to the next
 

00:14:53.839 --> 00:14:55.959 align:start position:0%
and that lbm will like move things
 

00:14:55.959 --> 00:14:59.920 align:start position:0%
around on us um so see here I have sort
 

00:14:59.920 --> 00:15:04.600 align:start position:0%
of um some placeholders here uh some uh
 

00:15:04.600 --> 00:15:06.920 align:start position:0%
things that I don't Define for magically
 

00:15:06.920 --> 00:15:08.880 align:start position:0%
inserting the op AR and magically
 

00:15:08.880 --> 00:15:10.079 align:start position:0%
continuing
 

00:15:10.079 --> 00:15:12.480 align:start position:0%
execution uh copy and Patch solves this
 

00:15:12.480 --> 00:15:16.440 align:start position:0%
problem by using xterms so uh instead of
 

00:15:16.440 --> 00:15:18.720 align:start position:0%
uh using the value of the X turn for our
 

00:15:18.720 --> 00:15:20.680 align:start position:0%
off Ark we use the address of the X turn
 

00:15:20.680 --> 00:15:23.360 align:start position:0%
for our off Ark which allows uh lvm to
 

00:15:23.360 --> 00:15:25.519 align:start position:0%
generate really efficient code that we
 

00:15:25.519 --> 00:15:27.839 align:start position:0%
can patch very very easily when you're
 

00:15:27.839 --> 00:15:30.399 align:start position:0%
actually fixing up relocations typically
 

00:15:30.399 --> 00:15:32.240 align:start position:0%
you're inserting the address of the
 

00:15:32.240 --> 00:15:35.519 align:start position:0%
extern into the uh relocatable code and
 

00:15:35.519 --> 00:15:37.000 align:start position:0%
so with this we don't actually need to
 

00:15:37.000 --> 00:15:38.680 align:start position:0%
dreference the value at that address we
 

00:15:38.680 --> 00:15:40.600 align:start position:0%
can just use the address directly and so
 

00:15:40.600 --> 00:15:42.959 align:start position:0%
the code is really efficient um and
 

00:15:42.959 --> 00:15:44.360 align:start position:0%
since we're using clang we have this
 

00:15:44.360 --> 00:15:46.880 align:start position:0%
beautiful must tail attribute on the
 

00:15:46.880 --> 00:15:49.399 align:start position:0%
final continuation call which means that
 

00:15:49.399 --> 00:15:52.079 align:start position:0%
we will just get a single jump um that
 

00:15:52.079 --> 00:15:55.000 align:start position:0%
we can use to flow into the next op code
 

00:15:55.000 --> 00:15:57.519 align:start position:0%
and even better if the next uh if that
 

00:15:57.519 --> 00:15:59.759 align:start position:0%
junp happens to be a l zero we can just
 

00:15:59.759 --> 00:16:01.240 align:start position:0%
skip the jump
 

00:16:01.240 --> 00:16:03.720 align:start position:0%
entirely so the object file that we get
 

00:16:03.720 --> 00:16:05.839 align:start position:0%
out of this when we compile this to elf
 

00:16:05.839 --> 00:16:07.120 align:start position:0%
looks a lot like this and we have
 

00:16:07.120 --> 00:16:08.600 align:start position:0%
everything we care about we have the
 

00:16:08.600 --> 00:16:11.399 align:start position:0%
machine code here highlighted in blue
 

00:16:11.399 --> 00:16:13.800 align:start position:0%
and we have the relocations and where
 

00:16:13.800 --> 00:16:15.880 align:start position:0%
their uh data is going to go we know
 

00:16:15.880 --> 00:16:17.240 align:start position:0%
exactly how the data is going to be
 

00:16:17.240 --> 00:16:19.199 align:start position:0%
patched and we know exactly where it's
 

00:16:19.199 --> 00:16:21.639 align:start position:0%
going to be and so we can take this
 

00:16:21.639 --> 00:16:24.079 align:start position:0%
parse it out and put it in static header
 

00:16:24.079 --> 00:16:27.519 align:start position:0%
files and now we have all the data that
 

00:16:27.519 --> 00:16:29.600 align:start position:0%
we want to copy and then all the holes
 

00:16:29.600 --> 00:16:31.079 align:start position:0%
that we want to
 

00:16:31.079 --> 00:16:35.000 align:start position:0%
patch um so uh I've been working on this
 

00:16:35.000 --> 00:16:37.240 align:start position:0%
for a couple months uh and I've done
 

00:16:37.240 --> 00:16:38.720 align:start position:0%
this so if you want to check it out it's
 

00:16:38.720 --> 00:16:41.680 align:start position:0%
on my Fork of cpython uh the branch name
 

00:16:41.680 --> 00:16:45.160 align:start position:0%
is Justin as in Justin time so uh if you
 

00:16:45.160 --> 00:16:48.360 align:start position:0%
want to check it out it works um you can
 

00:16:48.360 --> 00:16:50.639 align:start position:0%
also just like actually look at The Code
 

00:16:50.639 --> 00:16:53.720 align:start position:0%
by uh going to uh ghub and uh check out
 

00:16:53.720 --> 00:16:54.920 align:start position:0%
my Branch
 

00:16:54.920 --> 00:16:58.079 align:start position:0%
there um just some kind of stats on the
 

00:16:58.079 --> 00:17:01.120 align:start position:0%
implement ation itself um at build time
 

00:17:01.120 --> 00:17:03.920 align:start position:0%
it is about 700 lines of complex python
 

00:17:03.920 --> 00:17:06.240 align:start position:0%
um so this is python code that handles
 

00:17:06.240 --> 00:17:09.039 align:start position:0%
uh actually extracting all the cases
 

00:17:09.039 --> 00:17:11.039 align:start position:0%
compiling each one parsing out the elf
 

00:17:11.039 --> 00:17:13.799 align:start position:0%
and then generating the header files um
 

00:17:13.799 --> 00:17:15.720 align:start position:0%
it has about 100 lines of complex c
 

00:17:15.720 --> 00:17:17.199 align:start position:0%
those are the templates that I showed
 

00:17:17.199 --> 00:17:19.160 align:start position:0%
you that we actually insert the cases
 

00:17:19.160 --> 00:17:21.280 align:start position:0%
into so that we can comp compile and
 

00:17:21.280 --> 00:17:24.600 align:start position:0%
extract them um and there is an lovm
 

00:17:24.600 --> 00:17:26.160 align:start position:0%
dependency but most importantly this is
 

00:17:26.160 --> 00:17:27.799 align:start position:0%
a fill time dependency not something
 

00:17:27.799 --> 00:17:30.840 align:start position:0%
that users need to install um compare
 

00:17:30.840 --> 00:17:33.799 align:start position:0%
this to the uh runtime requirements um
 

00:17:33.799 --> 00:17:36.720 align:start position:0%
so we have 300 lines of simple C again
 

00:17:36.720 --> 00:17:38.000 align:start position:0%
the nice thing about the copy and Patch
 

00:17:38.000 --> 00:17:40.120 align:start position:0%
compiler is that it's really fast but
 

00:17:40.120 --> 00:17:42.280 align:start position:0%
it's also really simple it's a mem copy
 

00:17:42.280 --> 00:17:43.799 align:start position:0%
and then walking over the relocations
 

00:17:43.799 --> 00:17:47.840 align:start position:0%
and just performing them um and then we
 

00:17:47.840 --> 00:17:50.000 align:start position:0%
have the 3,000 lines of simple generated
 

00:17:50.000 --> 00:17:51.960 align:start position:0%
C and it truly is just as simple as the
 

00:17:51.960 --> 00:17:53.919 align:start position:0%
code that I showed you on the last
 

00:17:53.919 --> 00:17:57.280 align:start position:0%
slide um and most importantly no runtime
 

00:17:57.280 --> 00:17:59.880 align:start position:0%
dependencies everything is full fully
 

00:17:59.880 --> 00:18:02.679 align:start position:0%
self-contained um and what I really like
 

00:18:02.679 --> 00:18:05.720 align:start position:0%
about this is that uh from a maintainer
 

00:18:05.720 --> 00:18:08.520 align:start position:0%
point of view I like that uh all the
 

00:18:08.520 --> 00:18:09.919 align:start position:0%
complexity has been shifted to build
 

00:18:09.919 --> 00:18:11.919 align:start position:0%
time rather than run time and it's been
 

00:18:11.919 --> 00:18:13.880 align:start position:0%
shifted into python code rather than C
 

00:18:13.880 --> 00:18:17.440 align:start position:0%
code um so we are able to do all of the
 

00:18:17.440 --> 00:18:19.640 align:start position:0%
kind of fancy stuff later when we
 

00:18:19.640 --> 00:18:21.720 align:start position:0%
actually start making this thing really
 

00:18:21.720 --> 00:18:23.360 align:start position:0%
really fast and really really performant
 

00:18:23.360 --> 00:18:26.760 align:start position:0%
and optimizing the code um in the python
 

00:18:26.760 --> 00:18:29.440 align:start position:0%
code itself um rather than doing most of
 

00:18:29.440 --> 00:18:32.320 align:start position:0%
that work at runtime and in uh C code I
 

00:18:32.320 --> 00:18:33.840 align:start position:0%
think we can all agree that we prefer
 

00:18:33.840 --> 00:18:35.600 align:start position:0%
writing python to C yeah PA did you have
 

00:18:35.600 --> 00:18:39.080 align:start position:0%
a question yeah so I'm curious why you
 

00:18:39.080 --> 00:18:42.600 align:start position:0%
need L dependency
 

00:18:42.600 --> 00:18:47.640 align:start position:0%
like you want to generate the
 

00:18:47.640 --> 00:18:52.520 align:start position:0%
object it into it put into templates but
 

00:18:52.520 --> 00:18:54.440 align:start position:0%
you just use whatever compiler you're
 

00:18:54.440 --> 00:18:57.280 align:start position:0%
using to compile python to just compile
 

00:18:57.280 --> 00:18:59.799 align:start position:0%
maybe this templ and as far as they
 

00:18:59.799 --> 00:19:01.799 align:start position:0%
below yeah so there yeah there are a
 

00:19:01.799 --> 00:19:03.120 align:start position:0%
couple reasons so the first one is that
 

00:19:03.120 --> 00:19:04.640 align:start position:0%
must tail attribute where we get
 

00:19:04.640 --> 00:19:07.080 align:start position:0%
guaranteed tail calls GC GCC doesn't
 

00:19:07.080 --> 00:19:08.400 align:start position:0%
have that and we need tail calls for
 

00:19:08.400 --> 00:19:10.000 align:start position:0%
correctness otherwise we'll blow the
 

00:19:10.000 --> 00:19:13.720 align:start position:0%
stack stud every
 

00:19:13.720 --> 00:19:16.520 align:start position:0%
comp exactly clang is a great cross
 

00:19:16.520 --> 00:19:18.880 align:start position:0%
compiler so it it works lots of places
 

00:19:18.880 --> 00:19:22.280 align:start position:0%
um and we also use some other LM tools
 

00:19:22.280 --> 00:19:23.840 align:start position:0%
for example we don't actually parse the
 

00:19:23.840 --> 00:19:26.520 align:start position:0%
elf um LM has a tool that will dump El
 

00:19:26.520 --> 00:19:29.080 align:start position:0%
elf to Json which is great oh so we
 

00:19:29.080 --> 00:19:30.840 align:start position:0%
actually just parse the Json which is
 

00:19:30.840 --> 00:19:34.080 align:start position:0%
beautiful um it also has uh you know a
 

00:19:34.080 --> 00:19:36.559 align:start position:0%
built-in disassembler so uh the 3,000
 

00:19:36.559 --> 00:19:38.559 align:start position:0%
lines of header file is actually
 

00:19:38.559 --> 00:19:40.960 align:start position:0%
annotated where each above each kind of
 

00:19:40.960 --> 00:19:43.520 align:start position:0%
dump of the assembly um we actually have
 

00:19:43.520 --> 00:19:45.360 align:start position:0%
the human readable assembly output as
 

00:19:45.360 --> 00:19:48.360 align:start position:0%
well that you can audit and look at um
 

00:19:48.360 --> 00:19:51.360 align:start position:0%
and another thing too is uh once we
 

00:19:51.360 --> 00:19:53.000 align:start position:0%
start getting really clever with this uh
 

00:19:53.000 --> 00:19:54.600 align:start position:0%
there are actually really cool things
 

00:19:54.600 --> 00:19:57.760 align:start position:0%
that you can do by using lm's uh like
 

00:19:57.760 --> 00:20:00.480 align:start position:0%
wide VAR iy of calling conventions um so
 

00:20:00.480 --> 00:20:01.559 align:start position:0%
for example they have calling
 

00:20:01.559 --> 00:20:03.559 align:start position:0%
conventions that pass all arguments in
 

00:20:03.559 --> 00:20:05.320 align:start position:0%
registers and have no call E saved
 

00:20:05.320 --> 00:20:07.039 align:start position:0%
registers which is ideal if you want to
 

00:20:07.039 --> 00:20:10.360 align:start position:0%
like pin stack items in registers and uh
 

00:20:10.360 --> 00:20:12.440 align:start position:0%
make the jump at the very end of the
 

00:20:12.440 --> 00:20:14.640 align:start position:0%
continuation really really
 

00:20:14.640 --> 00:20:18.559 align:start position:0%
clean yes separate question um the bill
 

00:20:18.559 --> 00:20:21.240 align:start position:0%
time dependency is that bill time or is
 

00:20:21.240 --> 00:20:24.760 align:start position:0%
it generate files time could we separate
 

00:20:24.760 --> 00:20:28.640 align:start position:0%
that out could for python releases yes
 

00:20:28.640 --> 00:20:31.120 align:start position:0%
yeah the only thing we're using L LM for
 

00:20:31.120 --> 00:20:33.919 align:start position:0%
is to generate one header file um So
 

00:20:33.919 --> 00:20:35.200 align:start position:0%
currently on my Branch that's not
 

00:20:35.200 --> 00:20:36.919 align:start position:0%
checked into the rapo because it's
 

00:20:36.919 --> 00:20:39.280 align:start position:0%
platform specific and even whatever your
 

00:20:39.280 --> 00:20:40.760 align:start position:0%
pie config looks like it can change the
 

00:20:40.760 --> 00:20:42.960 align:start position:0%
way it works okay so it does need to be
 

00:20:42.960 --> 00:20:45.039 align:start position:0%
built yeah we could choose to check
 

00:20:45.039 --> 00:20:46.720 align:start position:0%
those in or host those somewhere or
 

00:20:46.720 --> 00:20:48.760 align:start position:0%
whatever um well if it's if it's
 

00:20:48.760 --> 00:20:51.600 align:start position:0%
configured specific yeah then you can't
 

00:20:51.600 --> 00:20:55.080 align:start position:0%
check them in yeah yeah it it I I choose
 

00:20:55.080 --> 00:20:59.200 align:start position:0%
not to track it um you know uh
 

00:20:59.200 --> 00:21:01.720 align:start position:0%
yeah so it is it is it is technically
 

00:21:01.720 --> 00:21:04.120 align:start position:0%
generate files time but it's not checked
 

00:21:04.120 --> 00:21:06.159 align:start position:0%
in so it's built time effectively well
 

00:21:06.159 --> 00:21:09.159 align:start position:0%
yeah it it also I mean all the other
 

00:21:09.159 --> 00:21:12.039 align:start position:0%
generated files we have are platform
 

00:21:12.039 --> 00:21:14.440 align:start position:0%
agnostic yes yeah yeah I I understand
 

00:21:14.440 --> 00:21:16.360 align:start position:0%
the question now yes it's build time
 

00:21:16.360 --> 00:21:19.000 align:start position:0%
okay yeah you put it in a container like
 

00:21:19.000 --> 00:21:21.760 align:start position:0%
the thing that we using for configure so
 

00:21:21.760 --> 00:21:24.240 align:start position:0%
everyone can run the commands and get
 

00:21:24.240 --> 00:21:26.600 align:start position:0%
the same out no because it depends on
 

00:21:26.600 --> 00:21:28.320 align:start position:0%
the platform so you would need need a
 

00:21:28.320 --> 00:21:30.039 align:start position:0%
container for every you would need a
 

00:21:30.039 --> 00:21:32.360 align:start position:0%
container for your specific platform it
 

00:21:32.360 --> 00:21:34.799 align:start position:0%
would be for every platform every option
 

00:21:34.799 --> 00:21:36.159 align:start position:0%
of whether you have a search turned on
 

00:21:36.159 --> 00:21:38.559 align:start position:0%
or off debug turned on or off by the way
 

00:21:38.559 --> 00:21:40.120 align:start position:0%
you can put asserts and printfs and
 

00:21:40.120 --> 00:21:41.640 align:start position:0%
stuff inside of your cases and they'll
 

00:21:41.640 --> 00:21:43.880 align:start position:0%
just be in the assembly it's
 

00:21:43.880 --> 00:21:46.720 align:start position:0%
awesome how long does it take a build
 

00:21:46.720 --> 00:21:48.640 align:start position:0%
time again it depends you have one of
 

00:21:48.640 --> 00:21:50.760 align:start position:0%
the new Macs because it takes like 30
 

00:21:50.760 --> 00:21:53.440 align:start position:0%
seconds on on slower machines it's less
 

00:21:53.440 --> 00:21:56.320 align:start position:0%
than a minute um and it doesn't uh
 

00:21:56.320 --> 00:21:58.919 align:start position:0%
always rerun so for example I have it
 

00:21:58.919 --> 00:22:00.720 align:start position:0%
cached so that it won't regenerate if
 

00:22:00.720 --> 00:22:02.760 align:start position:0%
the file's already present and the
 

00:22:02.760 --> 00:22:04.760 align:start position:0%
generated cases haven't changed so in
 

00:22:04.760 --> 00:22:05.799 align:start position:0%
practice if you're not modifying The
 

00:22:05.799 --> 00:22:07.880 align:start position:0%
Interpreter you won't see it but um
 

00:22:07.880 --> 00:22:09.919 align:start position:0%
otherwise it takes a few seconds on Fast
 

00:22:09.919 --> 00:22:11.559 align:start position:0%
hardware and no more than a minute on
 

00:22:11.559 --> 00:22:12.520 align:start position:0%
everything
 

00:22:12.520 --> 00:22:16.720 align:start position:0%
else so do windows oh let's talk about
 

00:22:16.720 --> 00:22:20.120 align:start position:0%
 
 

00:22:20.120 --> 00:22:22.559 align:start position:0%
support Victor you will be happy to know
 

00:22:22.559 --> 00:22:25.080 align:start position:0%
that the the uh the initial
 

00:22:25.080 --> 00:22:27.360 align:start position:0%
implementation supports two platforms it
 

00:22:27.360 --> 00:22:31.320 align:start position:0%
 
 

00:22:31.320 --> 00:22:33.840 align:start position:0%
windows Micosoft just
 

00:22:33.840 --> 00:22:36.120 align:start position:0%
kidding it supports all tier one
 

00:22:36.120 --> 00:22:37.600 align:start position:0%
platforms if you check it out right now
 

00:22:37.600 --> 00:22:39.559 align:start position:0%
on any of these it'll work in fact it
 

00:22:39.559 --> 00:22:41.520 align:start position:0%
supports all tier one and tier 2
 

00:22:41.520 --> 00:22:44.400 align:start position:0%
platforms right now um except power PC
 

00:22:44.400 --> 00:22:47.159 align:start position:0%
but we don't talk about
 

00:22:47.159 --> 00:22:50.320 align:start position:0%
that um but uh most notably since clang
 

00:22:50.320 --> 00:22:52.600 align:start position:0%
is such a great cross compiler uh the
 

00:22:52.600 --> 00:22:55.320 align:start position:0%
default cross compile setup just works
 

00:22:55.320 --> 00:22:56.760 align:start position:0%
perfectly um if you're doing cross
 

00:22:56.760 --> 00:22:59.120 align:start position:0%
compiles now don't change anything just
 

00:22:59.120 --> 00:23:02.559 align:start position:0%
install lbm 16 nearby um and your
 

00:23:02.559 --> 00:23:04.760 align:start position:0%
regular build your cross build whatever
 

00:23:04.760 --> 00:23:06.279 align:start position:0%
options you're passing to configure
 

00:23:06.279 --> 00:23:08.000 align:start position:0%
things just
 

00:23:08.000 --> 00:23:11.720 align:start position:0%
work and I think that's it so no
 

00:23:11.720 --> 00:23:16.510 align:start position:0%
 
 

00:23:16.510 --> 00:23:20.840 align:start position:0%
 
 

00:23:20.840 --> 00:23:24.120 align:start position:0%
you uh sorry
 

00:23:24.120 --> 00:23:27.440 align:start position:0%
Victor did you have a question okay yeah
 

00:23:27.440 --> 00:23:29.480 align:start position:0%
no I was to say how does it compare to
 

00:23:29.480 --> 00:23:32.039 align:start position:0%
number does it work with gpus uh how
 

00:23:32.039 --> 00:23:34.039 align:start position:0%
does it to compare in terms of speed
 

00:23:34.039 --> 00:23:36.159 align:start position:0%
yeah uh So currently it is no faster
 

00:23:36.159 --> 00:23:37.480 align:start position:0%
than main when you have this turned on
 

00:23:37.480 --> 00:23:39.880 align:start position:0%
but that represents a 5% improvement
 

00:23:39.880 --> 00:23:43.080 align:start position:0%
over the Micro Ops that it's based on um
 

00:23:43.080 --> 00:23:44.440 align:start position:0%
and we haven't done any of the fun
 

00:23:44.440 --> 00:23:48.120 align:start position:0%
tricks yet okay um so it's much slower
 

00:23:48.120 --> 00:23:51.520 align:start position:0%
than number um and what was the other
 

00:23:51.520 --> 00:23:55.760 align:start position:0%
question number a GPU support GPU
 

00:23:55.760 --> 00:23:58.559 align:start position:0%
support I would guess just as well as LM
 

00:23:58.559 --> 00:24:00.720 align:start position:0%
supports gpus so I I have I'm not doing
 

00:24:00.720 --> 00:24:04.200 align:start position:0%
anything special yeah they aren CPUs
 

00:24:04.200 --> 00:24:05.720 align:start position:0%
resources AR in the right place so it's
 

00:24:05.720 --> 00:24:07.760 align:start position:0%
we yeah it's nice because for things
 

00:24:07.760 --> 00:24:10.360 align:start position:0%
like platform support or more specific
 

00:24:10.360 --> 00:24:12.559 align:start position:0%
like Hardware integration we can just
 

00:24:12.559 --> 00:24:14.559 align:start position:0%
piggy back on LM so if there's a way to
 

00:24:14.559 --> 00:24:16.640 align:start position:0%
make lbm uh use the gpus more
 

00:24:16.640 --> 00:24:18.360 align:start position:0%
effectively then we can harness that too
 

00:24:18.360 --> 00:24:22.360 align:start position:0%
at least for that build yes okay
 

00:24:22.360 --> 00:24:25.520 align:start position:0%
yeah Victor the thing about container is
 

00:24:25.520 --> 00:24:36.039 align:start position:0%
 
 

00:24:36.039 --> 00:24:38.000 align:start position:0%
theats you don't you don't need the
 

00:24:38.000 --> 00:24:40.200 align:start position:0%
container so if you install the cross
 

00:24:40.200 --> 00:24:43.120 align:start position:0%
compiler tool chain um LM knows how to
 

00:24:43.120 --> 00:24:44.480 align:start position:0%
find that and you can just build them
 

00:24:44.480 --> 00:24:46.000 align:start position:0%
all because you you don't actually need
 

00:24:46.000 --> 00:24:48.360 align:start position:0%
to run anything for this he really wants
 

00:24:48.360 --> 00:24:50.559 align:start position:0%
to use a
 

00:24:50.559 --> 00:24:53.520 align:start position:0%
container when you ask people to install
 

00:24:53.520 --> 00:24:56.360 align:start position:0%
LM they get different flavor different
 

00:24:56.360 --> 00:24:59.200 align:start position:0%
FL and output can
 

00:24:59.200 --> 00:25:01.880 align:start position:0%
change config to put everything in
 

00:25:01.880 --> 00:25:04.799 align:start position:0%
container we know that you always get
 

00:25:04.799 --> 00:25:07.919 align:start position:0%
exactly the same yeah we that is
 

00:25:07.919 --> 00:25:09.480 align:start position:0%
definitely something important but again
 

00:25:09.480 --> 00:25:11.080 align:start position:0%
remember this also depends on configure
 

00:25:11.080 --> 00:25:14.520 align:start position:0%
flag so it's only as stable as those um
 

00:25:14.520 --> 00:25:17.720 align:start position:0%
also on top of that I I mean I have test
 

00:25:17.720 --> 00:25:20.200 align:start position:0%
I do have CI running this on all the
 

00:25:20.200 --> 00:25:24.120 align:start position:0%
platforms I listed there um and uh it's
 

00:25:24.120 --> 00:25:25.679 align:start position:0%
also tested against the full Matrix of
 

00:25:25.679 --> 00:25:28.799 align:start position:0%
LM 14 15 and 16 so for all three of
 

00:25:28.799 --> 00:25:31.200 align:start position:0%
those um I've verified that this passes
 

00:25:31.200 --> 00:25:32.679 align:start position:0%
the entire test
 

00:25:32.679 --> 00:25:36.399 align:start position:0%
Suite so are you going to checking
 

00:25:36.399 --> 00:25:38.679 align:start position:0%
this I have no plans
 

00:25:38.679 --> 00:25:40.960 align:start position:0%
to we
 

00:25:40.960 --> 00:25:42.880 align:start position:0%
should you can host a bunch of them
 

00:25:42.880 --> 00:25:45.440 align:start position:0%
 
 

00:25:45.440 --> 00:25:47.360 align:start position:0%
want like I'm not sure we're going to
 

00:25:47.360 --> 00:25:48.919 align:start position:0%
need a container basically it sounds
 

00:25:48.919 --> 00:25:52.000 align:start position:0%
like this is working on things
 

00:25:52.000 --> 00:25:55.399 align:start position:0%
syst get yeah and if you
 

00:25:55.399 --> 00:25:58.760 align:start position:0%
checking problem for people building
 

00:25:58.760 --> 00:26:01.520 align:start position:0%
and yeah people in this room probably
 

00:26:01.520 --> 00:26:04.559 align:start position:0%
not and if you check out my Branch too
 

00:26:04.559 --> 00:26:07.679 align:start position:0%
uh there's a read me in tools jit um it
 

00:26:07.679 --> 00:26:09.640 align:start position:0%
tells you how to install lvm on all
 

00:26:09.640 --> 00:26:11.360 align:start position:0%
platforms and again one thing I want to
 

00:26:11.360 --> 00:26:13.640 align:start position:0%
highlight is you don't need to build
 

00:26:13.640 --> 00:26:15.760 align:start position:0%
cpython itself with lovm or even the
 

00:26:15.760 --> 00:26:18.399 align:start position:0%
same version of lovm lovm is only used
 

00:26:18.399 --> 00:26:20.279 align:start position:0%
for just for generating that one header
 

00:26:20.279 --> 00:26:24.640 align:start position:0%
file um so when you get a t of python
 

00:26:24.640 --> 00:26:28.559 align:start position:0%
you don't need LM so it would be
 

00:26:28.559 --> 00:26:31.000 align:start position:0%
yes if if you want to build the jit yes
 

00:26:31.000 --> 00:26:32.919 align:start position:0%
um so I imagine this behind a configure
 

00:26:32.919 --> 00:26:36.840 align:start position:0%
flag um where I mean just just
 

00:26:36.840 --> 00:26:39.760 align:start position:0%
spitballing here um if you don't pass
 

00:26:39.760 --> 00:26:41.080 align:start position:0%
the configure flag and you don't have
 

00:26:41.080 --> 00:26:44.240 align:start position:0%
lovm installed um we don't do we just do
 

00:26:44.240 --> 00:26:47.080 align:start position:0%
a normal build if we smell that lovm is
 

00:26:47.080 --> 00:26:48.640 align:start position:0%
nearby but you didn't pass the flag we
 

00:26:48.640 --> 00:26:50.159 align:start position:0%
can say hey by the way you can build a
 

00:26:50.159 --> 00:26:52.000 align:start position:0%
jit if you want to and if you do pass
 

00:26:52.000 --> 00:26:55.039 align:start position:0%
the flag then we build the
 

00:26:55.039 --> 00:26:59.279 align:start position:0%
jit you can also leave work for fure of
 

00:26:59.279 --> 00:27:05.120 align:start position:0%
 
 

00:27:05.120 --> 00:27:09.000 align:start position:0%
comp just just that making that configur
 

00:27:09.000 --> 00:27:11.000 align:start position:0%
flag an optional thing is pretty much
 

00:27:11.000 --> 00:27:14.000 align:start position:0%
Essential for iOS because or or like web
 

00:27:14.000 --> 00:27:15.520 align:start position:0%
assembly for example or any of the list
 

00:27:15.520 --> 00:27:17.080 align:start position:0%
of tier three platforms that we
 

00:27:17.080 --> 00:27:20.240 align:start position:0%
absolutely can't build for
 

00:27:20.240 --> 00:27:23.640 align:start position:0%
yeah uh public sorry I should say names
 

00:27:23.640 --> 00:27:25.520 align:start position:0%
do you need any special
 

00:27:25.520 --> 00:27:28.679 align:start position:0%
like for mic like call that they has
 

00:27:28.679 --> 00:27:31.520 align:start position:0%
some protections
 

00:27:31.520 --> 00:27:35.120 align:start position:0%
like this is I mean jits work on Mac OS
 

00:27:35.120 --> 00:27:36.600 align:start position:0%
so you can't have you can't have
 

00:27:36.600 --> 00:27:38.240 align:start position:0%
writable executable memory and I think
 

00:27:38.240 --> 00:27:39.960 align:start position:0%
as of Sonoma you can't have readable
 

00:27:39.960 --> 00:27:42.320 align:start position:0%
executable memory um which is something
 

00:27:42.320 --> 00:27:44.039 align:start position:0%
I need to fix so this won't work on
 

00:27:44.039 --> 00:27:46.120 align:start position:0%
somoma because currently the memory is
 

00:27:46.120 --> 00:27:47.799 align:start position:0%
read execute but that's on my list of
 

00:27:47.799 --> 00:27:51.559 align:start position:0%
things to fix like do we need to like to
 

00:27:51.559 --> 00:27:53.960 align:start position:0%
change like the way we need to release
 

00:27:53.960 --> 00:27:56.120 align:start position:0%
this for like I I recall that there's a
 

00:27:56.120 --> 00:27:58.159 align:start position:0%
way to ask for it
 

00:27:58.159 --> 00:28:01.320 align:start position:0%
say when you map the memory you ask for
 

00:28:01.320 --> 00:28:05.720 align:start position:0%
the jit uh in the flags when you map the
 

00:28:05.720 --> 00:28:08.600 align:start position:0%
memory you can say map jit I think yeah
 

00:28:08.600 --> 00:28:11.640 align:start position:0%
yeah and that says I'm AIT I I think you
 

00:28:11.640 --> 00:28:13.080 align:start position:0%
may be referring to platform
 

00:28:13.080 --> 00:28:14.679 align:start position:0%
restrictions where you need to actually
 

00:28:14.679 --> 00:28:17.399 align:start position:0%
set the exe up speci before you even run
 

00:28:17.399 --> 00:28:21.440 align:start position:0%
it let me let me ref so when we the
 

00:28:21.440 --> 00:28:24.080 align:start position:0%
mic because I supp one that you compile
 

00:28:24.080 --> 00:28:28.399 align:start position:0%
is the same you compile right we need to
 

00:28:28.399 --> 00:28:30.840 align:start position:0%
like do you know if we need to set
 

00:28:30.840 --> 00:28:33.480 align:start position:0%
anything or ask if we do I don't know
 

00:28:33.480 --> 00:28:35.120 align:start position:0%
that we need to I'm not familiar with
 

00:28:35.120 --> 00:28:37.519 align:start position:0%
how we're actually building Mac OS
 

00:28:37.519 --> 00:28:39.760 align:start position:0%
releases differently from how I just
 

00:28:39.760 --> 00:28:41.880 align:start position:0%
build it locally um I can vouch for it
 

00:28:41.880 --> 00:28:44.080 align:start position:0%
working
 

00:28:44.080 --> 00:28:47.240 align:start position:0%
locally presumably the the release
 

00:28:47.240 --> 00:28:50.279 align:start position:0%
manager needs to use that flag yes if
 

00:28:50.279 --> 00:28:51.679 align:start position:0%
there's anything that needs to be done
 

00:28:51.679 --> 00:28:53.279 align:start position:0%
that sounds like the release manager
 

00:28:53.279 --> 00:28:58.000 align:start position:0%
should do it but I'm not aware of yeah
 

00:28:58.000 --> 00:29:00.960 align:start position:0%
it it very well could be the most the
 

00:29:00.960 --> 00:29:03.279 align:start position:0%
most of the sort of permissions stuff
 

00:29:03.279 --> 00:29:05.519 align:start position:0%
I've had to debug has been on Mac OS
 

00:29:05.519 --> 00:29:08.320 align:start position:0%
specifically M1 Mac
 

00:29:08.320 --> 00:29:10.880 align:start position:0%
yeah so it sounds like the Run
 

00:29:10.880 --> 00:29:13.000 align:start position:0%
generation is super fast yes why not
 

00:29:13.000 --> 00:29:17.000 align:start position:0%
just do this either for like tier one or
 

00:29:17.000 --> 00:29:21.039 align:start position:0%
I what number starts at interpret why
 

00:29:21.039 --> 00:29:23.360 align:start position:0%
only do this for tier two well we don't
 

00:29:23.360 --> 00:29:24.360 align:start position:0%
definitely don't want to do it for
 

00:29:24.360 --> 00:29:26.720 align:start position:0%
unspecialized bik code right because the
 

00:29:26.720 --> 00:29:28.519 align:start position:0%
specialized B code is uh where we're
 

00:29:28.519 --> 00:29:29.919 align:start position:0%
able to actually generate high quality
 

00:29:29.919 --> 00:29:32.080 align:start position:0%
code for um and the reason that we want
 

00:29:32.080 --> 00:29:33.960 align:start position:0%
to break it up into tier 2 code is
 

00:29:33.960 --> 00:29:36.039 align:start position:0%
because just by breaking it up we're not
 

00:29:36.039 --> 00:29:38.200 align:start position:0%
actually gaining anything right um if
 

00:29:38.200 --> 00:29:39.519 align:start position:0%
anything we're losing something because
 

00:29:39.519 --> 00:29:42.600 align:start position:0%
lvm is able to optimize less over the
 

00:29:42.600 --> 00:29:47.559 align:start position:0%
same context um but uh the kind of
 

00:29:47.559 --> 00:29:49.399 align:start position:0%
reason to build this on top of tier two
 

00:29:49.399 --> 00:29:51.080 align:start position:0%
is because ideally we're going to
 

00:29:51.080 --> 00:29:52.960 align:start position:0%
optimiz here to and Ken Jen will talk a
 

00:29:52.960 --> 00:29:54.679 align:start position:0%
little bit more about that um but if
 

00:29:54.679 --> 00:29:56.960 align:start position:0%
we're able to remove guards or reorder
 

00:29:56.960 --> 00:29:59.880 align:start position:0%
things or hoist guards or whatever um
 

00:29:59.880 --> 00:30:02.039 align:start position:0%
then this Builds on top of that um and
 

00:30:02.039 --> 00:30:03.399 align:start position:0%
so those guards won't be present in the
 

00:30:03.399 --> 00:30:05.919 align:start position:0%
generated machine code I get all that
 

00:30:05.919 --> 00:30:07.360 align:start position:0%
but like so the examples you're talking
 

00:30:07.360 --> 00:30:09.080 align:start position:0%
about that are already using this are
 

00:30:09.080 --> 00:30:10.960 align:start position:0%
using this for their Baseline right
 

00:30:10.960 --> 00:30:12.399 align:start position:0%
they're using this before any
 

00:30:12.399 --> 00:30:15.080 align:start position:0%
optimizations yes so wouldn't this be
 

00:30:15.080 --> 00:30:17.760 align:start position:0%
advantageous in the same use case for
 

00:30:17.760 --> 00:30:21.720 align:start position:0%
python it could be I haven't tried
 

00:30:21.720 --> 00:30:25.480 align:start position:0%
it we we currently can't translate every
 

00:30:25.480 --> 00:30:28.279 align:start position:0%
tier one by code corresonding sequence
 

00:30:28.279 --> 00:30:31.240 align:start position:0%
of tier two by codes although we have
 

00:30:31.240 --> 00:30:33.799 align:start position:0%
translate every tier one by code to copy
 

00:30:33.799 --> 00:30:35.799 align:start position:0%
and Patch no
 

00:30:35.799 --> 00:30:37.840 align:start position:0%
because needs to
 

00:30:37.840 --> 00:30:43.360 align:start position:0%
be simp we we we could it would just be
 

00:30:43.360 --> 00:30:45.399 align:start position:0%
different
 

00:30:45.399 --> 00:30:55.840 align:start position:0%
 
 

00:30:55.840 --> 00:30:58.120 align:start position:0%
ahead although have and we want
 

00:30:58.120 --> 00:31:00.039 align:start position:0%
effective profiling that gives us as
 

00:31:00.039 --> 00:31:01.720 align:start position:0%
well so theer
 

00:31:01.720 --> 00:31:04.120 align:start position:0%
oneu because we're effectively
 

00:31:04.120 --> 00:31:17.960 align:start position:0%
 
 

00:31:17.960 --> 00:31:26.159 align:start position:0%
 
 

00:31:26.159 --> 00:31:28.519 align:start position:0%
probably another thing too I I realized
 

00:31:28.519 --> 00:31:31.039 align:start position:0%
I didn't mention um the reason that the
 

00:31:31.039 --> 00:31:32.760 align:start position:0%
generated code is such high quality is
 

00:31:32.760 --> 00:31:35.399 align:start position:0%
because we don't care about uh like the
 

00:31:35.399 --> 00:31:36.720 align:start position:0%
compil times when we're actually
 

00:31:36.720 --> 00:31:38.279 align:start position:0%
building this thing so we pull out all
 

00:31:38.279 --> 00:31:39.960 align:start position:0%
the stops and tell lvm to optimize
 

00:31:39.960 --> 00:31:41.320 align:start position:0%
heavily um which is something you
 

00:31:41.320 --> 00:31:43.960 align:start position:0%
wouldn't want to do in a RI time jit yes
 

00:31:43.960 --> 00:31:46.639 align:start position:0%
when youate the machine
 

00:31:46.639 --> 00:31:51.960 align:start position:0%
code can you pass the equivalent to
 

00:31:51.960 --> 00:31:54.919 align:start position:0%
compile we're using
 

00:31:54.919 --> 00:32:00.240 align:start position:0%
clim yes yeah so uh we uh compile first
 

00:32:00.240 --> 00:32:02.559 align:start position:0%
using clang and that turns C code into
 

00:32:02.559 --> 00:32:06.080 align:start position:0%
llvm uh textual IR um the only reason we
 

00:32:06.080 --> 00:32:07.519 align:start position:0%
do that is because we want to fix up the
 

00:32:07.519 --> 00:32:08.960 align:start position:0%
calling convention and clang doesn't
 

00:32:08.960 --> 00:32:10.880 align:start position:0%
actually let let us have this calling
 

00:32:10.880 --> 00:32:12.880 align:start position:0%
convention from C so we fix up the
 

00:32:12.880 --> 00:32:15.720 align:start position:0%
calling convention using a hacky Rex
 

00:32:15.720 --> 00:32:17.639 align:start position:0%
replacement that will change in the
 

00:32:17.639 --> 00:32:21.120 align:start position:0%
future um and uh and then compile again
 

00:32:21.120 --> 00:32:24.240 align:start position:0%
 
 

00:32:24.240 --> 00:32:27.720 align:start position:0%
elf and you said it was under your or
 

00:32:27.720 --> 00:32:29.399 align:start position:0%
yeah yeah so my user brand Booker it's
 

00:32:29.399 --> 00:32:31.519 align:start position:0%
on my fory python the brand it's on the
 

00:32:31.519 --> 00:32:36.840 align:start position:0%
 
 

00:32:36.840 --> 00:32:38.840 align:start position:0%
yes uh that's the
 

00:32:38.840 --> 00:32:42.639 align:start position:0%
URL so it's the Justin branch of Bry P
 

00:32:42.639 --> 00:32:46.080 align:start position:0%
that's if you go to uh tools jit there's
 

00:32:46.080 --> 00:32:47.399 align:start position:0%
a read me in there that says how to
 

00:32:47.399 --> 00:32:49.480 align:start position:0%
install lvm
 

00:32:49.480 --> 00:32:51.880 align:start position:0%
sweet it's one a question of the general
 

00:32:51.880 --> 00:32:53.600 align:start position:0%
approach than the what you need so far
 

00:32:53.600 --> 00:32:55.480 align:start position:0%
but once you have a line of tra and you
 

00:32:55.480 --> 00:32:57.919 align:start position:0%
can have individual with this function
 

00:32:57.919 --> 00:33:00.519 align:start position:0%
another obvious things to try is to put
 

00:33:00.519 --> 00:33:02.799 align:start position:0%
all these calls into a cile compile it
 

00:33:02.799 --> 00:33:05.039 align:start position:0%
all together and see what happens yeah
 

00:33:05.039 --> 00:33:07.639 align:start position:0%
have you tried uh no but one thing the
 

00:33:07.639 --> 00:33:09.399 align:start position:0%
paper did have good success with is
 

00:33:09.399 --> 00:33:11.360 align:start position:0%
actually compiling super instructions uh
 

00:33:11.360 --> 00:33:14.480 align:start position:0%
for common pairs or triples because then
 

00:33:14.480 --> 00:33:17.440 align:start position:0%
it really allows lbm to optimize across
 

00:33:17.440 --> 00:33:19.559 align:start position:0%
um especially for for example like
 

00:33:19.559 --> 00:33:21.000 align:start position:0%
obvious things that we may want to look
 

00:33:21.000 --> 00:33:25.639 align:start position:0%
at are um when we so the Micro Ops are
 

00:33:25.639 --> 00:33:27.639 align:start position:0%
kind of expanded from a single
 

00:33:27.639 --> 00:33:30.039 align:start position:0%
instruction um I would imagine that in
 

00:33:30.039 --> 00:33:32.080 align:start position:0%
many cases we aren't able to optimize
 

00:33:32.080 --> 00:33:33.279 align:start position:0%
that very heavily and so it ends up
 

00:33:33.279 --> 00:33:34.600 align:start position:0%
being the equivalent of the original
 

00:33:34.600 --> 00:33:35.799 align:start position:0%
instruction so that'd be sort of low
 

00:33:35.799 --> 00:33:37.279 align:start position:0%
hanging fruit for things that we could
 

00:33:37.279 --> 00:33:39.600 align:start position:0%
compile and again when we're just
 

00:33:39.600 --> 00:33:42.039 align:start position:0%
walking over we can window over and see
 

00:33:42.039 --> 00:33:45.320 align:start position:0%
if we have anything that's entire
 

00:33:45.320 --> 00:33:47.880 align:start position:0%
X involve the compiler
 

00:33:47.880 --> 00:33:52.200 align:start position:0%
and exactly and and right now we have um
 

00:33:52.200 --> 00:33:56.559 align:start position:0%
like we have one uh template for every
 

00:33:56.559 --> 00:33:59.360 align:start position:0%
uh micro op so like 200 some odd
 

00:33:59.360 --> 00:34:01.639 align:start position:0%
templates um in the paper they generated
 

00:34:01.639 --> 00:34:04.720 align:start position:0%
as many as like 10,000 um combinations
 

00:34:04.720 --> 00:34:06.960 align:start position:0%
yes not only for combinations but also
 

00:34:06.960 --> 00:34:09.320 align:start position:0%
like for example if you have uh some
 

00:34:09.320 --> 00:34:12.560 align:start position:0%
instructions for example um CH the
 

00:34:12.560 --> 00:34:14.159 align:start position:0%
control flow changes based on the value
 

00:34:14.159 --> 00:34:16.919 align:start position:0%
of the opar so it may make sense to
 

00:34:16.919 --> 00:34:19.560 align:start position:0%
actually burn in values of the opar not
 

00:34:19.560 --> 00:34:22.040 align:start position:0%
actually at jit time but ahead of time
 

00:34:22.040 --> 00:34:23.760 align:start position:0%
where you hard code those values and LM
 

00:34:23.760 --> 00:34:25.480 align:start position:0%
can optimize based on them and the op AR
 

00:34:25.480 --> 00:34:28.159 align:start position:0%
is completely removed um then there's
 

00:34:28.159 --> 00:34:29.760 align:start position:0%
also super instructions and there
 

00:34:29.760 --> 00:34:31.760 align:start position:0%
there's all sorts of games you can play
 

00:34:31.760 --> 00:34:33.359 align:start position:0%
um another example would be if you're
 

00:34:33.359 --> 00:34:35.960 align:start position:0%
lifting things from uh stack items into
 

00:34:35.960 --> 00:34:39.399 align:start position:0%
registers um if you are kind of keeping
 

00:34:39.399 --> 00:34:41.359 align:start position:0%
that mapping of Stack items to registers
 

00:34:41.359 --> 00:34:42.760 align:start position:0%
you may want to compile variants for
 

00:34:42.760 --> 00:34:44.560 align:start position:0%
different stack sizes um so that you
 

00:34:44.560 --> 00:34:47.240 align:start position:0%
have a finite number of uh mappings but
 

00:34:47.240 --> 00:34:52.000 align:start position:0%
 
 

00:34:52.000 --> 00:34:55.879 align:start position:0%
simple Victor again so what is your
 

00:34:55.879 --> 00:34:58.760 align:start position:0%
proposal do you want to to match or do
 

00:34:58.760 --> 00:35:02.599 align:start position:0%
 
 

00:35:02.599 --> 00:35:04.920 align:start position:0%
mainside uh I I didn't really have a
 

00:35:04.920 --> 00:35:08.040 align:start position:0%
proposal today but basically if this is
 

00:35:08.040 --> 00:35:09.720 align:start position:0%
something people would like to see in
 

00:35:09.720 --> 00:35:12.560 align:start position:0%
main off by default um we can get it in
 

00:35:12.560 --> 00:35:14.560 align:start position:0%
main very easily I know we aren't crazy
 

00:35:14.560 --> 00:35:16.079 align:start position:0%
about experiments in Maine which is kind
 

00:35:16.079 --> 00:35:18.520 align:start position:0%
of why I'm floating the idea now if not
 

00:35:18.520 --> 00:35:19.880 align:start position:0%
uh this has been a long live Branch
 

00:35:19.880 --> 00:35:24.160 align:start position:0%
since like May um and so if if if it's
 

00:35:24.160 --> 00:35:25.960 align:start position:0%
any Testament to like how easy it is to
 

00:35:25.960 --> 00:35:27.880 align:start position:0%
maintain this stuff a lot of stuff has
 

00:35:27.880 --> 00:35:30.599 align:start position:0%
landed in Maine since May and uh keeping
 

00:35:30.599 --> 00:35:32.560 align:start position:0%
this Branch up to date and improving
 

00:35:32.560 --> 00:35:34.520 align:start position:0%
during that time has not been very
 

00:35:34.520 --> 00:35:38.839 align:start position:0%
difficult um Ken even borrowed uh he
 

00:35:38.839 --> 00:35:40.400 align:start position:0%
basically merged this Branch into his
 

00:35:40.400 --> 00:35:42.880 align:start position:0%
own Branch a while back when he was uh
 

00:35:42.880 --> 00:35:45.160 align:start position:0%
uh playing around with optimizing stuff
 

00:35:45.160 --> 00:35:46.599 align:start position:0%
and wanted to see what would happen if
 

00:35:46.599 --> 00:35:49.119 align:start position:0%
he jitted it Ken is it easy to like add
 

00:35:49.119 --> 00:35:51.520 align:start position:0%
new bite codes and work with the jit as
 

00:35:51.520 --> 00:35:56.000 align:start position:0%
a like a API this is a r question about
 

00:35:56.000 --> 00:35:57.680 align:start position:0%
yes
 

00:35:57.680 --> 00:36:00.560 align:start position:0%
um yeah the good thing is that you just
 

00:36:00.560 --> 00:36:02.640 align:start position:0%
need to install LM
 

00:36:02.640 --> 00:36:06.839 align:start position:0%
and uh the the script will automatically
 

00:36:06.839 --> 00:36:09.319 align:start position:0%
generate so you don't actually need to
 

00:36:09.319 --> 00:36:12.560 align:start position:0%
know how it works in the background yeah
 

00:36:12.560 --> 00:36:14.520 align:start position:0%
oh and because like you said at one time
 

00:36:14.520 --> 00:36:16.560 align:start position:0%
patching in is really simple so we
 

00:36:16.560 --> 00:36:18.000 align:start position:0%
actually had to modify the patching
 

00:36:18.000 --> 00:36:20.560 align:start position:0%
because our patches were of different
 

00:36:20.560 --> 00:36:24.119 align:start position:0%
types than L tracers but even then like
 

00:36:24.119 --> 00:36:25.400 align:start position:0%
the file is just a for Lo like you
 

00:36:25.400 --> 00:36:27.520 align:start position:0%
mentioned copy so really simple to
 

00:36:27.520 --> 00:36:30.400 align:start position:0%
multiply yeah the actual code that jits
 

00:36:30.400 --> 00:36:33.560 align:start position:0%
and copies and patches like of those 300
 

00:36:33.560 --> 00:36:37.280 align:start position:0%
lines of Fairly uh simple c um like the
 

00:36:37.280 --> 00:36:38.880 align:start position:0%
the hot Loop where we're actually just
 

00:36:38.880 --> 00:36:40.599 align:start position:0%
walking over stuff selecting stencils
 

00:36:40.599 --> 00:36:42.520 align:start position:0%
and patching stuff is like maybe 20
 

00:36:42.520 --> 00:36:44.920 align:start position:0%
lines of code um the rest is sort of
 

00:36:44.920 --> 00:36:47.599 align:start position:0%
like handling permissions on Windows and
 

00:36:47.599 --> 00:36:51.240 align:start position:0%
Mac and all that kind of fun is it
 

00:36:51.240 --> 00:36:54.560 align:start position:0%
possible to to maintain it outside
 

00:36:54.560 --> 00:36:57.680 align:start position:0%
python I mean just technically
 

00:36:57.680 --> 00:37:01.160 align:start position:0%
sense or is it is
 

00:37:01.160 --> 00:37:04.440 align:start position:0%
implementation of I would say that since
 

00:37:04.440 --> 00:37:06.119 align:start position:0%
we are using the same Micro Ops as tier
 

00:37:06.119 --> 00:37:09.119 align:start position:0%
2 um we're pretty tightly coupled to the
 

00:37:09.119 --> 00:37:10.780 align:start position:0%
implementation
 

00:37:10.780 --> 00:37:13.520 align:start position:0%
[Music]
 

00:37:13.520 --> 00:37:17.520 align:start position:0%
um um it could
 

00:37:17.520 --> 00:37:20.520 align:start position:0%
be um one thing that we would need so so
 

00:37:20.520 --> 00:37:25.280 align:start position:0%
when we actually uh compile the code um
 

00:37:25.280 --> 00:37:28.720 align:start position:0%
we basically in those header files if
 

00:37:28.720 --> 00:37:30.040 align:start position:0%
you have a bite code instruction that
 

00:37:30.040 --> 00:37:33.079 align:start position:0%
calls for example p number ad right
 

00:37:33.079 --> 00:37:34.760 align:start position:0%
that's a symbol that you need to link
 

00:37:34.760 --> 00:37:36.760 align:start position:0%
against um and so the way we do that in
 

00:37:36.760 --> 00:37:38.880 align:start position:0%
the header file is we actually just put
 

00:37:38.880 --> 00:37:41.599 align:start position:0%
address of p number ad as an addend for
 

00:37:41.599 --> 00:37:42.560 align:start position:0%
that uh
 

00:37:42.560 --> 00:37:45.599 align:start position:0%
relocation um that works for p number ad
 

00:37:45.599 --> 00:37:48.119 align:start position:0%
but if we were building this separately
 

00:37:48.119 --> 00:37:50.839 align:start position:0%
from cpython itself there's a lot of
 

00:37:50.839 --> 00:37:52.760 align:start position:0%
internal apis that would need to be
 

00:37:52.760 --> 00:37:54.400 align:start position:0%
exposed as public symbols in order for
 

00:37:54.400 --> 00:37:56.040 align:start position:0%
us to link them and actually linking
 

00:37:56.040 --> 00:37:57.800 align:start position:0%
them at run time would be a lot more
 

00:37:57.800 --> 00:38:00.280 align:start position:0%
complicated um we would first probably
 

00:38:00.280 --> 00:38:03.079 align:start position:0%
need to initialize all the stencils when
 

00:38:03.079 --> 00:38:04.760 align:start position:0%
the extension or whatever was first
 

00:38:04.760 --> 00:38:08.640 align:start position:0%
loaded by walking over and uh the
 

00:38:08.640 --> 00:38:10.640 align:start position:0%
stencils and actually resolving all of
 

00:38:10.640 --> 00:38:12.280 align:start position:0%
those symbols finding them in the
 

00:38:12.280 --> 00:38:15.160 align:start position:0%
current process uh with using dlm or
 

00:38:15.160 --> 00:38:17.119 align:start position:0%
whatever the windows equivalent is
 

00:38:17.119 --> 00:38:18.680 align:start position:0%
walking over them and actually fixing up
 

00:38:18.680 --> 00:38:21.720 align:start position:0%
those add-ins and then it would mostly
 

00:38:21.720 --> 00:38:25.359 align:start position:0%
be the same um but that sounds a lot
 

00:38:25.359 --> 00:38:27.599 align:start position:0%
more complicated than and I don't think
 

00:38:27.599 --> 00:38:29.119 align:start position:0%
we want to stick all that stuff as
 

00:38:29.119 --> 00:38:32.880 align:start position:0%
public symbols um so it is doable in
 

00:38:32.880 --> 00:38:34.680 align:start position:0%
theory I think the ergonomics make it
 

00:38:34.680 --> 00:38:37.839 align:start position:0%
like probably not the best option I'm
 

00:38:37.839 --> 00:38:41.440 align:start position:0%
 
 

00:38:41.440 --> 00:38:47.720 align:start position:0%
 
 

00:38:47.720 --> 00:38:49.520 align:start position:0%
examp
 

00:38:49.520 --> 00:38:52.839 align:start position:0%
okay don't build
 

00:38:52.839 --> 00:38:55.720 align:start position:0%
the or or I'll build it for you and I'll
 

00:38:55.720 --> 00:39:04.480 align:start position:0%
 
 

00:39:04.480 --> 00:39:06.359 align:start position:0%
that's behind the configur flag for now
 

00:39:06.359 --> 00:39:08.119 align:start position:0%
the answer to
 

00:39:08.119 --> 00:39:11.440 align:start position:0%
that unknown this very useful find way
 

00:39:11.440 --> 00:39:13.760 align:start position:0%
forward to actually do it you you can't
 

00:39:13.760 --> 00:39:16.079 align:start position:0%
at the same time say that you want the
 

00:39:16.079 --> 00:39:19.160 align:start position:0%
jit and say that you
 

00:39:19.160 --> 00:39:22.400 align:start position:0%
cannot have this dependency right this
 

00:39:22.400 --> 00:39:25.079 align:start position:0%
 
 

00:39:25.079 --> 00:39:28.640 align:start position:0%
want I want million we can we all want
 

00:39:28.640 --> 00:39:31.119 align:start position:0%
things I get
 

00:39:31.119 --> 00:39:36.000 align:start position:0%
it y did you have your hand up yeah so
 

00:39:36.000 --> 00:39:37.520 align:start position:0%
as far as I understand there's pretty
 

00:39:37.520 --> 00:39:39.160 align:start position:0%
much no alternative to this like if you
 

00:39:39.160 --> 00:39:41.880 align:start position:0%
want to go with the it's either us
 

00:39:41.880 --> 00:39:44.800 align:start position:0%
spending a lot of resources handwriting
 

00:39:44.800 --> 00:39:48.040 align:start position:0%
 
 

00:39:48.040 --> 00:39:50.680 align:start position:0%
uh handwriting all of this kind of code
 

00:39:50.680 --> 00:39:53.280 align:start position:0%
pass generating them uh which is one of
 

00:39:53.280 --> 00:39:55.040 align:start position:0%
the hardest parts of the gy like this is
 

00:39:55.040 --> 00:39:58.520 align:start position:0%
a nice to a lot of
 

00:39:58.520 --> 00:40:02.200 align:start position:0%
resour it seems like the plan should be
 

00:40:02.200 --> 00:40:09.240 align:start position:0%
 
 

00:40:09.240 --> 00:40:11.440 align:start position:0%
main am
 

00:40:11.440 --> 00:40:15.560 align:start position:0%
I no that's how I feel as well um and
 

00:40:15.560 --> 00:40:17.400 align:start position:0%
and another thing too just since you
 

00:40:17.400 --> 00:40:19.319 align:start position:0%
mentioned handwriting assembly is that
 

00:40:19.319 --> 00:40:21.000 align:start position:0%
the two are not mutually exclusive so
 

00:40:21.000 --> 00:40:22.640 align:start position:0%
for example if we see that there's a
 

00:40:22.640 --> 00:40:25.119 align:start position:0%
really common op code and we see that we
 

00:40:25.119 --> 00:40:27.720 align:start position:0%
can actually write better than LM can
 

00:40:27.720 --> 00:40:30.040 align:start position:0%
for whatever reason we can do that the
 

00:40:30.040 --> 00:40:31.720 align:start position:0%
the two play very nicely together so it
 

00:40:31.720 --> 00:40:34.440 align:start position:0%
just be in that build script uh the 700
 

00:40:34.440 --> 00:40:36.160 align:start position:0%
lines of python or whatever we just
 

00:40:36.160 --> 00:40:37.480 align:start position:0%
special case that off code and say hey
 

00:40:37.480 --> 00:40:39.920 align:start position:0%
use this assembly file instead yeah Qui
 

00:40:39.920 --> 00:40:41.599 align:start position:0%
question P question on the on the
 

00:40:41.599 --> 00:40:43.359 align:start position:0%
Benchmark numbers that you show one of
 

00:40:43.359 --> 00:40:45.800 align:start position:0%
the slid so basically what they did they
 

00:40:45.800 --> 00:40:48.480 align:start position:0%
just repl so for example in the case of
 

00:40:48.480 --> 00:40:53.560 align:start position:0%
compil they just replaced the G uh Cod
 

00:40:53.560 --> 00:40:56.800 align:start position:0%
assembly and what not where the stop
 

00:40:56.800 --> 00:40:58.640 align:start position:0%
this
 

00:40:58.640 --> 00:41:02.440 align:start position:0%
appro no it was a completely uh like new
 

00:41:02.440 --> 00:41:04.480 align:start position:0%
implementation that they wrote so if you
 

00:41:04.480 --> 00:41:06.160 align:start position:0%
go to the blog post that I linked to
 

00:41:06.160 --> 00:41:09.520 align:start position:0%
earlier um it's a nice long blog post if
 

00:41:09.520 --> 00:41:10.680 align:start position:0%
you don't know anything about jits
 

00:41:10.680 --> 00:41:12.400 align:start position:0%
you'll know how jits work after reading
 

00:41:12.400 --> 00:41:14.520 align:start position:0%
it um and it goes over copy and patch
 

00:41:14.520 --> 00:41:16.119 align:start position:0%
and also things like inline caching and
 

00:41:16.119 --> 00:41:18.359 align:start position:0%
whatever but it's basically him
 

00:41:18.359 --> 00:41:22.400 align:start position:0%
implementing a Lua uh jit okay right and
 

00:41:22.400 --> 00:41:25.880 align:start position:0%
and so it's the so that yeah yeah so so
 

00:41:25.880 --> 00:41:28.160 align:start position:0%
it's it's the comparison of his just
 

00:41:28.160 --> 00:41:30.200 align:start position:0%
from scratch implementation versus an
 

00:41:30.200 --> 00:41:33.000 align:start position:0%
established fast
 

00:41:33.000 --> 00:41:36.800 align:start position:0%
implementation what is that I can put it
 

00:41:36.800 --> 00:41:38.119 align:start position:0%
back up
 

00:41:38.119 --> 00:41:41.040 align:start position:0%
there you could probably find it just by
 

00:41:41.040 --> 00:41:44.000 align:start position:0%
Google for a c yeah if you if you if you
 

00:41:44.000 --> 00:41:46.400 align:start position:0%
search for oh wait did I skip it already
 

00:41:46.400 --> 00:41:49.440 align:start position:0%
hang on I never saw the link to the blog
 

00:41:49.440 --> 00:41:53.599 align:start position:0%
post uh it was underneath the paper it's
 

00:41:53.599 --> 00:41:55.240 align:start position:0%
right
 

00:41:55.240 --> 00:41:59.880 align:start position:0%
here you haven't linked the che that yes
 

00:41:59.880 --> 00:42:04.079 align:start position:0%
I should indeed so the uh the top one is
 

00:42:04.079 --> 00:42:07.599 align:start position:0%
the paper the bottom one is the blog
 

00:42:07.599 --> 00:42:11.200 align:start position:0%
post and I just posted they did a
 

00:42:11.200 --> 00:42:14.440 align:start position:0%
presentation a few months ago as well
 

00:42:14.440 --> 00:42:17.200 align:start position:0%
was that for the paper good slides yeah
 

00:42:17.200 --> 00:42:18.760 align:start position:0%
and just as an
 

00:42:18.760 --> 00:42:21.400 align:start position:0%
FYI like that may be a new paper but we
 

00:42:21.400 --> 00:42:23.079 align:start position:0%
were doing this type of approach for a
 

00:42:23.079 --> 00:42:25.160 align:start position:0%
translator transmeta 20 years ago and I
 

00:42:25.160 --> 00:42:27.599 align:start position:0%
doubt we were the this but templates
 

00:42:27.599 --> 00:42:31.559 align:start position:0%
from regular yeah are very fast to yeah
 

00:42:31.559 --> 00:42:34.640 align:start position:0%
how was your experience with it I sh in
 

00:42:34.640 --> 00:42:40.319 align:start position:0%
 
 

00:42:40.319 --> 00:42:43.359 align:start position:0%
intermediate yeah I mean it is I kind of
 

00:42:43.359 --> 00:42:46.720 align:start position:0%
view this as a like a baseline but a
 

00:42:46.720 --> 00:42:48.880 align:start position:0%
really good one yeah right and so if we
 

00:42:48.880 --> 00:42:50.559 align:start position:0%
wanted to have another tier where we
 

00:42:50.559 --> 00:42:52.000 align:start position:0%
pull out all the stops on top of this
 

00:42:52.000 --> 00:42:54.119 align:start position:0%
that's a bridge we could cross right
 

00:42:54.119 --> 00:42:56.520 align:start position:0%
this is easy to maintain you don't have
 

00:42:56.520 --> 00:43:02.000 align:start position:0%
 
 

00:43:02.000 --> 00:43:04.359 align:start position:0%
was another question in terms of the Cod
 

00:43:04.359 --> 00:43:07.319 align:start position:0%
style will will you need to change a lot
 

00:43:07.319 --> 00:43:09.040 align:start position:0%
like I know that you compile some of the
 

00:43:09.040 --> 00:43:12.359 align:start position:0%
functions already but will the Cod style
 

00:43:12.359 --> 00:43:18.839 align:start position:0%
 
 

00:43:18.839 --> 00:43:22.319 align:start position:0%
same when you say the code style so we
 

00:43:22.319 --> 00:43:25.079 align:start position:0%
extract so basically the way you write
 

00:43:25.079 --> 00:43:29.559 align:start position:0%
code py code
 

00:43:29.559 --> 00:43:32.040 align:start position:0%
yes I'm I'm sure you'll see lots of blog
 

00:43:32.040 --> 00:43:33.960 align:start position:0%
posts of how to get the most out of C
 

00:43:33.960 --> 00:43:37.040 align:start position:0%
Python's new jit you know but those are
 

00:43:37.040 --> 00:43:42.359 align:start position:0%
 
 

00:43:42.359 --> 00:43:46.839 align:start position:0%
 
 

00:43:46.839 --> 00:43:49.359 align:start position:0%
yeah I I don't think it'll be any
 

00:43:49.359 --> 00:43:50.680 align:start position:0%
different than the specializing
 

00:43:50.680 --> 00:43:52.640 align:start position:0%
interpreter where it's just we play to
 

00:43:52.640 --> 00:43:54.480 align:start position:0%
the benchmarks the benchmarks we take to
 

00:43:54.480 --> 00:43:56.839 align:start position:0%
be somewhat realistic and we look to
 

00:43:56.839 --> 00:43:59.680 align:start position:0%
confirm that that is true in practice
 

00:43:59.680 --> 00:44:01.880 align:start position:0%
right um and I'm sure that there are
 

00:44:01.880 --> 00:44:04.960 align:start position:0%
people who you know like try to optimize
 

00:44:04.960 --> 00:44:06.640 align:start position:0%
for the specializing interpreter and I'm
 

00:44:06.640 --> 00:44:07.680 align:start position:0%
sure there'll be people who try to
 

00:44:07.680 --> 00:44:09.720 align:start position:0%
optimize for this but I think in general
 

00:44:09.720 --> 00:44:11.280 align:start position:0%
it'll just be a good low overhead way of
 

00:44:11.280 --> 00:44:15.920 align:start position:0%
 
 

00:44:15.920 --> 00:44:21.000 align:start position:0%
world we already I want everyone discuss
 

00:44:21.000 --> 00:44:24.920 align:start position:0%
so what is theing situation of this like
 

00:44:24.920 --> 00:44:26.520 align:start position:0%
for one of
 

00:44:26.520 --> 00:44:30.440 align:start position:0%
 
 

00:44:30.440 --> 00:44:40.760 align:start position:0%
 
 

00:44:40.760 --> 00:44:44.559 align:start position:0%
to yeah um so I don't know enough about
 

00:44:44.559 --> 00:44:46.440 align:start position:0%
unwind tables and that and like dwarf
 

00:44:46.440 --> 00:44:48.440 align:start position:0%
and all of that to give a good answer I
 

00:44:48.440 --> 00:44:50.520 align:start position:0%
can tell you that I don't include any
 

00:44:50.520 --> 00:44:52.559 align:start position:0%
unwind tables or dwarf in the jitted
 

00:44:52.559 --> 00:44:55.680 align:start position:0%
code and we disable frame pointers but
 

00:44:55.680 --> 00:44:56.680 align:start position:0%
if it's it's something that could be
 

00:44:56.680 --> 00:44:59.160 align:start position:0%
reused from the original elf um then
 

00:44:59.160 --> 00:45:00.280 align:start position:0%
that's something that would be easy to
 

00:45:00.280 --> 00:45:02.280 align:start position:0%
harvest uh otherwise we would have to
 

00:45:02.280 --> 00:45:04.920 align:start position:0%
kind of emit it ourselves when way will
 

00:45:04.920 --> 00:45:07.440 align:start position:0%
be maybe to May at the beginning when I
 

00:45:07.440 --> 00:45:10.040 align:start position:0%
mean at the beginning maybe when we are
 

00:45:10.040 --> 00:45:12.760 align:start position:0%
playing with maybe a che way is to allow
 

00:45:12.760 --> 00:45:15.359 align:start position:0%
at least to or detect if you're building
 

00:45:15.359 --> 00:45:17.040 align:start position:0%
python itself with frame pointers and
 

00:45:17.040 --> 00:45:18.800 align:start position:0%
then generating the template with frame
 

00:45:18.800 --> 00:45:21.920 align:start position:0%
pointers yeah I assume going to copy
 

00:45:21.920 --> 00:45:24.000 align:start position:0%
one yeah so we're disabling frame
 

00:45:24.000 --> 00:45:25.400 align:start position:0%
pointers right now just because we're
 

00:45:25.400 --> 00:45:26.960 align:start position:0%
passing argument registers and that's a
 

00:45:26.960 --> 00:45:29.079 align:start position:0%
valuable register um but I mean this
 

00:45:29.079 --> 00:45:30.520 align:start position:0%
argument's been had a million times so
 

00:45:30.520 --> 00:45:33.079 align:start position:0%
we can build with frame pointers you
 

00:45:33.079 --> 00:45:34.880 align:start position:0%
know it's easy enough just to say don't
 

00:45:34.880 --> 00:45:37.440 align:start position:0%
use that register right um and so that
 

00:45:37.440 --> 00:45:40.559 align:start position:0%
could be the first step and then again I
 

00:45:40.559 --> 00:45:41.960 align:start position:0%
I would need to do more research if I
 

00:45:41.960 --> 00:45:43.680 align:start position:0%
were to do it myself well at least
 

00:45:43.680 --> 00:45:47.440 align:start position:0%
having aouch I think a first kind of
 

00:45:47.440 --> 00:45:49.960 align:start position:0%
line
 

00:45:49.960 --> 00:45:54.880 align:start position:0%
cheap useful in you
 

00:45:54.880 --> 00:45:59.520 align:start position:0%
 
 

00:45:59.520 --> 00:46:04.200 align:start position:0%
side yeah if we were extract like if we
 

00:46:04.200 --> 00:46:06.760 align:start position:0%
could just extract all of this stuff
 

00:46:06.760 --> 00:46:09.079 align:start position:0%
from the elf file is that something that
 

00:46:09.079 --> 00:46:11.680 align:start position:0%
could be reused or would need to be
 

00:46:11.680 --> 00:46:13.720 align:start position:0%
different every time we emit a copy of
 

00:46:13.720 --> 00:46:17.240 align:start position:0%
that stencil you would need toch the
 

00:46:17.240 --> 00:46:18.839 align:start position:0%
relocations as well so there's
 

00:46:18.839 --> 00:46:22.440 align:start position:0%
relocations in the like the unwind
 

00:46:22.440 --> 00:46:24.839 align:start position:0%
tables and stuff the has like what is
 

00:46:24.839 --> 00:46:27.440 align:start position:0%
called and those will change when you
 

00:46:27.440 --> 00:46:29.319 align:start position:0%
place the code in different places so
 

00:46:29.319 --> 00:46:32.319 align:start position:0%
you need to somehow say oh this this
 

00:46:32.319 --> 00:46:36.040 align:start position:0%
code now Lees here so you need to say
 

00:46:36.040 --> 00:46:38.800 align:start position:0%
address things but most of the Annoying
 

00:46:38.800 --> 00:46:41.000 align:start position:0%
stuff to generate you can just copy okay
 

00:46:41.000 --> 00:46:42.960 align:start position:0%
yeah if it's if it's anything like the
 

00:46:42.960 --> 00:46:46.280 align:start position:0%
mechanics of extracting like for example
 

00:46:46.280 --> 00:46:50.559 align:start position:0%
static data BSS data executable text and
 

00:46:50.559 --> 00:46:52.160 align:start position:0%
processing relocations on those then the
 

00:46:52.160 --> 00:46:53.640 align:start position:0%
mechanics are almost identical it sounds
 

00:46:53.640 --> 00:46:54.800 align:start position:0%
like depends on
 

00:46:54.800 --> 00:46:59.079 align:start position:0%
how it to retri it from the file but if
 

00:46:59.079 --> 00:47:02.800 align:start position:0%
very easy and have some outut I suppose
 

00:47:02.800 --> 00:47:04.559 align:start position:0%
yeah like not like something that I
 

00:47:04.559 --> 00:47:07.000 align:start position:0%
think is super super important yeah two
 

00:47:07.000 --> 00:47:09.040 align:start position:0%
flags that I passed to clang currently
 

00:47:09.040 --> 00:47:11.800 align:start position:0%
are omit frame pointer and no
 

00:47:11.800 --> 00:47:16.160 align:start position:0%
asynchronous on wine tables um so if if
 

00:47:16.160 --> 00:47:18.040 align:start position:0%
we if if that's the sort of stuff that
 

00:47:18.040 --> 00:47:19.520 align:start position:0%
just gets dumped in the AL file and is
 

00:47:19.520 --> 00:47:21.440 align:start position:0%
reusable then it sounds like we have a
 

00:47:21.440 --> 00:47:22.920 align:start position:0%
promising path forward for a good
 

00:47:22.920 --> 00:47:24.720 align:start position:0%
debugging
 

00:47:24.720 --> 00:47:28.440 align:start position:0%
 
 

00:47:28.440 --> 00:47:34.359 align:start position:0%
 
 

00:47:34.359 --> 00:47:37.079 align:start position:0%
lot oh I didn't see I think we're
 

00:47:37.079 --> 00:47:40.880 align:start position:0%
getting too much into implementation
 

00:47:40.880 --> 00:47:48.559 align:start position:0%
 
 

