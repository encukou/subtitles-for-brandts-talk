WEBVTT
Kind: captions
Language: en

00:06.480 --> 00:08.880 align:start position:0%
All right, it's time!

00:08.880 --> 00:16.279 align:start position:0%
Here's Brandt with his talk!

00:16.279 --> 00:18.840 align:start position:0%
All right, so, instead of giving this

00:18.840 --> 00:20.199 align:start position:0%
talk tomorrow… By the way, can everyone

00:20.199 --> 00:23.279 align:start position:0%
hear me? Okay, cool. So, instead of

00:23.279 --> 00:24.560 align:start position:0%
giving this talk tomorrow I'm giving it

00:24.560 --> 00:26.840 align:start position:0%
today. I'm going to be sharing a

00:26.840 --> 00:28.760 align:start position:0%
little bit about something I have been

00:28.760 --> 00:30.400 align:start position:0%
thinking quite a bit about for last few

00:30.400 --> 00:32.840 align:start position:0%
months which is what Python's future JIT

00:32.840 --> 00:35.440 align:start position:0%
compiler might look like. Or, CPython's

00:35.440 --> 00:38.079 align:start position:0%
future JIT compiler, specifically.

00:38.079 --> 00:39.360 align:start position:0%
So I'm going to start with some

00:39.360 --> 00:42.079 align:start position:0%
background and this will also

00:42.079 --> 00:43.559 align:start position:0%
be good background for Ken's talk

00:43.559 --> 00:45.280 align:start position:0%
immediately after this, on

00:45.280 --> 00:47.440 align:start position:0%
optimizations that we hope to perform.

00:47.440 --> 00:50.440 align:start position:0%
Specifically, I'm mostly going to be

00:50.440 --> 00:52.000 align:start position:0%
talking about some experiments

00:52.000 --> 00:54.280 align:start position:0%
that I've done with actually generating

00:54.280 --> 00:56.600 align:start position:0%
and executing machine code, not

00:56.600 --> 00:58.280 align:start position:0%
necessarily optimizations and things

00:58.280 --> 01:00.120 align:start position:0%
that happen in the meantime. However, I

01:00.120 --> 01:01.680 align:start position:0%
will be giving some background on that

01:01.680 --> 01:03.120 align:start position:0%
because I think it's really helpful for

01:03.120 --> 01:04.880 align:start position:0%
understanding how everything ties

01:04.880 --> 01:07.799 align:start position:0%
together. So, a little recent history:

01:07.799 --> 01:09.560 align:start position:0%
In CPython

01:09.560 --> 01:11.720 align:start position:0%
3.11, one of the headline features was

01:11.720 --> 01:14.880 align:start position:0%
the specializing adaptive interpreter.

01:14.880 --> 01:17.400 align:start position:0%
This delivered really good

01:17.400 --> 01:19.080 align:start position:0%
speedups; I think the number we quoted

01:19.080 --> 01:22.200 align:start position:0%
most widely was something like 25%. If

01:22.200 --> 01:24.040 align:start position:0%
you want to take that at face value, that

01:24.040 --> 01:26.240 align:start position:0%
it was just a one-time performance gain

01:26.240 --> 01:29.640 align:start position:0%
that was nice to have, then sure, but

01:29.640 --> 01:31.400 align:start position:0%
if you think about it and you read a

01:31.400 --> 01:32.600 align:start position:0%
little bit between the lines you

01:32.600 --> 01:33.799 align:start position:0%
understand that we're now collecting

01:33.799 --> 01:37.520 align:start position:0%
runtime profiling data for user code.

01:37.520 --> 01:38.600 align:start position:0%
And that's something that we can use

01:38.600 --> 01:40.640 align:start position:0%
later if we want to lower that code and

01:40.640 --> 01:42.280 align:start position:0%
make it more statically typed.

01:42.280 --> 01:46.159 align:start position:0%
In CPython 3.12, we got a nice

01:46.159 --> 01:47.840 align:start position:0%
quality of life improvement as

01:47.840 --> 01:50.600 align:start position:0%
maintainers. We started generating the

01:50.600 --> 01:53.520 align:start position:0%
interpreter cases, the main `switch`, from a

01:53.520 --> 01:55.759 align:start position:0%
domain specific language. This

01:55.759 --> 01:59.920 align:start position:0%
allowed us to analyze and modify

01:59.920 --> 02:01.240 align:start position:0%
parts of the interpreter at build

02:01.240 --> 02:03.840 align:start position:0%
time. This is really helpful for the

02:03.840 --> 02:05.840 align:start position:0%
people actually working on the bytecode,

02:05.840 --> 02:09.840 align:start position:0%
because we can worry less about

02:09.840 --> 02:12.560 align:start position:0%
things like error handling, reference

02:12.560 --> 02:17.440 align:start position:0%
counts, adding counters,

02:17.440 --> 02:19.480 align:start position:0%
stats, and all those sorts of things.

02:19.480 --> 02:21.400 align:start position:0%
But at the same time, again if you can

02:21.400 --> 02:23.160 align:start position:0%
kind of read between the lines, we now

02:23.160 --> 02:24.440 align:start position:0%
are able to generate multiple

02:24.440 --> 02:26.160 align:start position:0%
interpreters from a single source of

02:26.160 --> 02:29.160 align:start position:0%
truth. And we also are able to

02:29.160 --> 02:31.239 align:start position:0%
generate lots of metadata by

02:31.239 --> 02:33.319 align:start position:0%
analyzing that single source of

02:33.319 --> 02:35.480 align:start position:0%
truth. So in

02:35.480 --> 02:38.040 align:start position:0%
3.13 – and again this is all stuff

02:38.040 --> 02:40.760 align:start position:0%
that's actually currently on main – we

02:40.760 --> 02:42.680 align:start position:0%
do have an internal pipeline for

02:42.680 --> 02:45.360 align:start position:0%
detecting, optimizing, and executing hot

02:45.360 --> 02:47.840 align:start position:0%
code paths. This is off by default, but

02:47.840 --> 02:50.239 align:start position:0%
if you build Python and you set the

02:50.239 --> 02:51.599 align:start position:0%
right environment variable or pass the

02:51.599 --> 02:54.959 align:start position:0%
right -X option – it's called uops,

02:54.959 --> 02:59.560 align:start position:0%
basically, CPython will find

02:59.560 --> 03:02.239 align:start position:0%
hot loops in your code, it will

03:02.239 --> 03:05.440 align:start position:0%
build a trace of that loop,

03:05.440 --> 03:08.840 align:start position:0%
and it will break it up into a more

03:08.840 --> 03:09.799 align:start position:0%
efficient

03:09.799 --> 03:12.799 align:start position:0%
representation, and optimize it – do

03:12.799 --> 03:15.120 align:start position:0%
some light optimization – and execute it

03:15.120 --> 03:18.440 align:start position:0%
in a second interpreter. Now, currently,

03:18.440 --> 03:19.720 align:start position:0%
this is actually a little bit slower,

03:19.720 --> 03:21.000 align:start position:0%
so you don't want to turn it on. It's like

03:21.000 --> 03:22.920 align:start position:0%
5% or 6% slower, just because it's

03:22.920 --> 03:24.920 align:start position:0%
kind of the first phase of this entire

03:24.920 --> 03:27.360 align:start position:0%
pipeline, and in the end the

03:27.360 --> 03:29.519 align:start position:0%
interpreter isn't really what we want to

03:29.519 --> 03:32.040 align:start position:0%
be executing these things. I'll get to

03:32.040 --> 03:34.040 align:start position:0%
that later. Basically, this

03:34.040 --> 03:35.280 align:start position:0%
wouldn't be possible without either of

03:35.280 --> 03:37.480 align:start position:0%
the first two steps. Being able to

03:37.480 --> 03:39.560 align:start position:0%
break big complicated bytecode

03:39.560 --> 03:41.239 align:start position:0%
instructions down into more simple

03:41.239 --> 03:43.760 align:start position:0%
atomic steps is only possible because of

03:43.760 --> 03:46.599 align:start position:0%
the changes made in 3.11 for

03:46.599 --> 03:49.040 align:start position:0%
specialization, and in 3.12 where we're

03:49.040 --> 03:51.720 align:start position:0%
able to define bytecode

03:51.720 --> 03:54.640 align:start position:0%
instructions in terms of smaller

03:54.640 --> 03:58.400 align:start position:0%
steps. So, I like providing examples,

03:58.400 --> 03:59.840 align:start position:0%
just so we can walk through what

03:59.840 --> 04:01.280 align:start position:0%
this pipeline looks like in practice and

04:01.280 --> 04:02.599 align:start position:0%
what it may look like in the future. So,

04:02.599 --> 04:03.879 align:start position:0%
we're going to look at my Fibonacci

04:03.879 --> 04:05.760 align:start position:0%
function here. It's pretty

04:05.760 --> 04:07.319 align:start position:0%
straightforward, and specifically, we're

04:07.319 --> 04:09.640 align:start position:0%
going to focus on the inner loop. It's

04:09.640 --> 04:11.280 align:start position:0%
pretty simple: we're looping over

04:11.280 --> 04:13.280 align:start position:0%
the range and then we update the values

04:13.280 --> 04:16.440 align:start position:0%
for `a` and `b` by adding `a` and `b`

04:16.440 --> 04:19.079 align:start position:0%
together. If you look at the bytecode

04:19.079 --> 04:20.359 align:start position:0%
for this function, it'll look

04:20.359 --> 04:25.120 align:start position:0%
something like this.

04:25.120 --> 04:27.199 align:start position:0%
If you want to know how the bytecode

04:27.199 --> 04:28.639 align:start position:0%
works you can look at the `dis`

04:28.639 --> 04:30.520 align:start position:0%
documentation. Basically, these are

04:30.520 --> 04:33.919 align:start position:0%
generic instructions that have mostly

04:33.919 --> 04:35.800 align:start position:0%
remained unchanged since the earliest

04:35.800 --> 04:37.199 align:start position:0%
versions of

04:37.199 --> 04:40.560 align:start position:0%
Python. However, in 3.11, we got our

04:40.560 --> 04:43.080 align:start position:0%
specialized bytecode. That took

04:43.080 --> 04:45.120 align:start position:0%
generic operations like FOR_ITER and

04:45.120 --> 04:48.360 align:start position:0%
BINARY_OP and allowed us to specialize

04:48.360 --> 04:50.000 align:start position:0%
those at runtime, for example, for

04:50.000 --> 04:52.520 align:start position:0%
iterating over a range object or adding

04:52.520 --> 04:54.360 align:start position:0%
two integers

04:54.360 --> 04:58.759 align:start position:0%
together. So that's great! Now, in

04:58.759 --> 05:02.600 align:start position:0%
3.13 we're building micro-op traces.

05:02.600 --> 05:04.360 align:start position:0%
These micro-ops are those smaller,

05:04.360 --> 05:06.000 align:start position:0%
more atomic steps that I was talking

05:06.000 --> 05:07.199 align:start position:0%
about that we're able to break

05:07.199 --> 05:11.360 align:start position:0%
individual instructions up into.

05:11.360 --> 05:13.240 align:start position:0%
As I mentioned before, you can actually

05:13.240 --> 05:15.560 align:start position:0%
run these things off of main by passing

05:15.560 --> 05:18.759 align:start position:0%
`-X uops`, and when you do

05:18.759 --> 05:20.600 align:start position:0%
that we will collect a trace for this

05:20.600 --> 05:22.440 align:start position:0%
loop and we'll actually break each of

05:22.440 --> 05:25.160 align:start position:0%
these instructions up into their

05:25.160 --> 05:26.840 align:start position:0%
individual components. So you can see

05:26.840 --> 05:28.280 align:start position:0%
that for some of the simpler

05:28.280 --> 05:30.479 align:start position:0%
instructions, they may only expand

05:30.479 --> 05:32.960 align:start position:0%
to two micro-ops (and that's what we

05:32.960 --> 05:35.440 align:start position:0%
call them, micro-ops), but the more

05:35.440 --> 05:38.319 align:start position:0%
complicated ones, like FOR_ITER_RANGE or

05:38.319 --> 05:40.240 align:start position:0%
the integer addition, may have several

05:40.240 --> 05:42.479 align:start position:0%
different parts. And what's nice about

05:42.479 --> 05:44.479 align:start position:0%
breaking those parts up is that if any

05:44.479 --> 05:45.919 align:start position:0%
of the parts are redundant, for example

05:45.919 --> 05:47.080 align:start position:0%
if we're checking that something's an

05:47.080 --> 05:48.680 align:start position:0%
integer when we can actually prove that

05:48.680 --> 05:51.520 align:start position:0%
it's an integer, then we can remove it.

05:51.520 --> 05:53.319 align:start position:0%
Or if we want to move things around,

05:53.319 --> 05:55.000 align:start position:0%
that's an option as

05:55.000 --> 05:59.600 align:start position:0%
well. So another thing that 3.13

05:59.600 --> 06:01.720 align:start position:0%
main will currently do for you is we'll

06:01.720 --> 06:03.280 align:start position:0%
do some light optimization on these

06:03.280 --> 06:05.120 align:start position:0%
micro-ops. Currently, the only

06:05.120 --> 06:07.800 align:start position:0%
optimization we perform is we'll find

06:07.800 --> 06:09.720 align:start position:0%
redundant frame pointer updates.

06:09.720 --> 06:11.840 align:start position:0%
Basically, if we have an operation that

06:11.840 --> 06:14.280 align:start position:0%
cannot fail, or the control flow cannot

06:14.280 --> 06:16.280 align:start position:0%
move to any other point in the

06:16.280 --> 06:18.680 align:start position:0%
program, there's no reason for us to

06:18.680 --> 06:20.039 align:start position:0%
update the frame and say “oh we're

06:20.039 --> 06:22.199 align:start position:0%
currently executing this instruction”.

06:22.199 --> 06:24.199 align:start position:0%
So it's a very very simple optimization,

06:24.199 --> 06:25.880 align:start position:0%
but it does work as a nice proof of

06:25.880 --> 06:28.000 align:start position:0%
concept. So, we will actually

06:28.000 --> 06:30.599 align:start position:0%
identify these four _SET_IP

06:30.599 --> 06:32.800 align:start position:0%
instructions, and just remove them for

06:32.800 --> 06:35.080 align:start position:0%
you. That's just pure overhead that

06:35.080 --> 06:36.319 align:start position:0%
we're able to

06:36.319 --> 06:39.039 align:start position:0%
remove. In the future, and Ken will talk a

06:39.039 --> 06:40.440 align:start position:0%
little bit more about this, we'll be able

06:40.440 --> 06:42.919 align:start position:0%
to do stronger optimizations, where

06:42.919 --> 06:44.560 align:start position:0%
we're able to remove more expensive

06:44.560 --> 06:46.800 align:start position:0%
checks. So for instance, if we can

06:46.800 --> 06:48.520 align:start position:0%
statically prove – as we can in the case

06:48.520 --> 06:50.800 align:start position:0%
of this function – that, for example, we're

06:50.800 --> 06:52.479 align:start position:0%
always iterating over a range object

06:52.479 --> 06:54.479 align:start position:0%
once we've entered this loop, and that

06:54.479 --> 06:56.400 align:start position:0%
`a` and `b` are both integers once we've

06:56.400 --> 06:58.080 align:start position:0%
entered this loop, then we can also

06:58.080 --> 07:00.560 align:start position:0%
remove those as well, and what's left is

07:00.560 --> 07:02.199 align:start position:0%
basically the bare minimum amount of

07:02.199 --> 07:05.280 align:start position:0%
work required to actually execute

07:05.280 --> 07:06.960 align:start position:0%
this hot inner loop. And you'll notice

07:06.960 --> 07:08.759 align:start position:0%
that this is entirely statically typed,

07:08.759 --> 07:10.759 align:start position:0%
which is great for further

07:10.759 --> 07:14.000 align:start position:0%
lowering. So, once we've removed all of

07:14.000 --> 07:15.960 align:start position:0%
that extra stuff that we can

07:15.960 --> 07:19.000 align:start position:0%
prove we don't actually need, then comes

07:19.000 --> 07:20.800 align:start position:0%
just-in-time compilation. And that's

07:20.800 --> 07:21.800 align:start position:0%
what I'm going to spend the rest of

07:21.800 --> 07:23.440 align:start position:0%
this time talking

07:23.440 --> 07:25.879 align:start position:0%
about. We have a couple different

07:25.879 --> 07:28.000 align:start position:0%
goals with the just-in-time compilation.

07:28.000 --> 07:31.120 align:start position:0%
Our main overarching goal is to

07:31.120 --> 07:33.680 align:start position:0%
remove interpretive overhead. So, we have

07:33.680 --> 07:37.039 align:start position:0%
removed all the extra dynamic

07:37.039 --> 07:39.599 align:start position:0%
work that needs to take place, but

07:39.599 --> 07:42.280 align:start position:0%
there's still a lot of other

07:42.280 --> 07:43.919 align:start position:0%
overhead that just comes from the way

07:43.919 --> 07:46.280 align:start position:0%
the virtual machine is laid out and

07:46.280 --> 07:49.759 align:start position:0%
the way it interacts with data. So, we

07:49.759 --> 07:51.520 align:start position:0%
want to remove interpretive overhead by

07:51.520 --> 07:53.639 align:start position:0%
statically compiling these optimized

07:53.639 --> 07:56.319 align:start position:0%
traces, and statically compiling them

07:56.319 --> 07:59.840 align:start position:0%
allows to us to reduce indirection

07:59.840 --> 08:01.639 align:start position:0%
through a few different ways. First of

08:01.639 --> 08:05.199 align:start position:0%
all, we can burn in – basically,

08:05.199 --> 08:07.879 align:start position:0%
encode directly into the machine code –

08:07.879 --> 08:10.599 align:start position:0%
the values of constants, caches and

08:10.599 --> 08:13.440 align:start position:0%
arguments to instructions. So basically,

08:13.440 --> 08:16.080 align:start position:0%
instead of decoding an

08:16.080 --> 08:18.720 align:start position:0%
instruction's oparg every single time

08:18.720 --> 08:20.800 align:start position:0%
we execute that instruction, we can

08:20.800 --> 08:23.000 align:start position:0%
instead, for example, make it an immediate

08:23.000 --> 08:26.159 align:start position:0%
value to an instruction in actual

08:26.159 --> 08:29.560 align:start position:0%
machine code, which replaces a

08:29.560 --> 08:31.280 align:start position:0%
memory load, is a lot more compact, and a

08:31.280 --> 08:32.159 align:start position:0%
lot more

08:32.159 --> 08:34.599 align:start position:0%
efficient. We can also do things like

08:34.599 --> 08:36.320 align:start position:0%
moving data off of frames and into

08:36.320 --> 08:39.360 align:start position:0%
registers. The micro-ops still execute

08:39.360 --> 08:41.640 align:start position:0%
on a Python frame, which means that

08:41.640 --> 08:43.360 align:start position:0%
intermediate values that live on the

08:43.360 --> 08:46.519 align:start position:0%
value stack are all still being written

08:46.519 --> 08:48.920 align:start position:0%
to memory and read from memory. If

08:48.920 --> 08:50.680 align:start position:0%
we can lift all of that stuff out of

08:50.680 --> 08:52.600 align:start position:0%
memory and into actual hardware

08:52.600 --> 08:55.360 align:start position:0%
registers, that saves a lot of traffic

08:55.360 --> 08:57.519 align:start position:0%
to and from main memory, which is

08:57.519 --> 08:59.680 align:start position:0%
always a good thing. Finally, we can

08:59.680 --> 09:01.640 align:start position:0%
bring hot code paths inline, so instead

09:01.640 --> 09:04.480 align:start position:0%
of having a large interpreter where

09:04.480 --> 09:06.720 align:start position:0%
we have all of these different cases

09:06.720 --> 09:08.279 align:start position:0%
that all need to be present because we

09:08.279 --> 09:10.880 align:start position:0%
can jump into them at any time, here

09:10.880 --> 09:12.640 align:start position:0%
we can make a straight line code path

09:12.640 --> 09:14.959 align:start position:0%
that executes exactly those instructions

09:14.959 --> 09:16.640 align:start position:0%
that I showed on the previous

09:16.640 --> 09:19.000 align:start position:0%
slide. Now, these need to be weighed

09:19.000 --> 09:22.800 align:start position:0%
against some practical goals, right?

09:22.800 --> 09:24.640 align:start position:0%
I don't think anyone wants me to

09:24.640 --> 09:27.720 align:start position:0%
dump a 10_000 line C++ JIT on us,

09:27.720 --> 09:30.800 align:start position:0%
right? So, the first thing is broad

09:30.800 --> 09:32.640 align:start position:0%
platform support. Python runs on lots of

09:32.640 --> 09:35.000 align:start position:0%
places and our JIT should too. I think

09:35.000 --> 09:36.440 align:start position:0%
that this is an ambitious goal, but it's

09:36.440 --> 09:39.959 align:start position:0%
an important one. I think that it

09:39.959 --> 09:42.240 align:start position:0%
should have few runtime dependencies, for

09:42.240 --> 09:45.519 align:start position:0%
example, I would like for this JIT to be

09:45.519 --> 09:48.279 align:start position:0%
in a place where, for example, users

09:48.279 --> 09:50.680 align:start position:0%
wouldn't need to have a full LLVM

09:50.680 --> 09:53.040 align:start position:0%
install. I don't think

09:53.040 --> 09:55.120 align:start position:0%
that's a good user experience. It can

09:55.120 --> 09:56.680 align:start position:0%
maybe be made into a good user

09:56.680 --> 09:58.839 align:start position:0%
experience, but I think I'd rather start

09:58.839 --> 10:01.120 align:start position:0%
from a place where you just download

10:01.120 --> 10:03.120 align:start position:0%
Python the same way as you always have

10:03.120 --> 10:04.600 align:start position:0%
and everything just

10:04.600 --> 10:07.760 align:start position:0%
works. And finally, and perhaps most

10:07.760 --> 10:10.120 align:start position:0%
importantly to me, low implementation

10:10.120 --> 10:12.480 align:start position:0%
complexity. CPython is

10:12.480 --> 10:14.920 align:start position:0%
overwhelmingly maintained by volunteers,

10:14.920 --> 10:18.640 align:start position:0%
and so I think that being able to

10:18.640 --> 10:22.120 align:start position:0%
keep the complexity down is a really

10:22.120 --> 10:24.279 align:start position:0%
really important goal to keep in mind. In

10:24.279 --> 10:27.000 align:start position:0%
fact, I personally feel like it's

10:27.000 --> 10:28.760 align:start position:0%
worth sacrificing peak performance in

10:28.760 --> 10:30.880 align:start position:0%
order to keep the implementation as

10:30.880 --> 10:33.120 align:start position:0%
simple, easy to maintain, and easy to

10:33.120 --> 10:35.480 align:start position:0%
understand and teach and learn as

10:35.480 --> 10:38.760 align:start position:0%
possible. So, these are competing

10:38.760 --> 10:41.000 align:start position:0%
goals, right? We want to make things

10:41.000 --> 10:43.600 align:start position:0%
fast but we're also willing to, as I said,

10:43.600 --> 10:45.639 align:start position:0%
sacrifice peak performance to make sure

10:45.639 --> 10:48.160 align:start position:0%
that this is something that we

10:48.160 --> 10:50.880 align:start position:0%
can all understand and that we can

10:50.880 --> 10:52.600 align:start position:0%
all maintain for the long

10:52.600 --> 10:57.880 align:start position:0%
haul. So, one recent

10:57.880 --> 11:01.399 align:start position:0%
development in JIT compiler

11:01.399 --> 11:03.680 align:start position:0%
technology is something called copy-and-

11:03.680 --> 11:05.120 align:start position:0%
-patch compilation, and it actually

11:05.120 --> 11:07.000 align:start position:0%
fulfills many of these goals in a really

11:07.000 --> 11:09.480 align:start position:0%
satisfying way. If you haven't

11:09.480 --> 11:11.639 align:start position:0%
heard about it, which, you know, I hadn't

11:11.639 --> 11:14.279 align:start position:0%
heard about it that long ago, copy-and-patch

11:14.279 --> 11:16.800 align:start position:0%
compilation comes out of a

11:16.800 --> 11:19.880 align:start position:0%
Stanford paper. But if you don't like

11:19.880 --> 11:22.399 align:start position:0%
reading the paper, I highly recommend the

11:22.399 --> 11:24.160 align:start position:0%
blog post. There's a blog post called

11:24.160 --> 11:26.079 align:start position:0%
Building a baseline JIT for Lua

11:26.079 --> 11:27.600 align:start position:0%
automatically. This is by the same author

11:27.600 --> 11:29.079 align:start position:0%
as the paper, and I've actually spoken

11:29.079 --> 11:31.480 align:start position:0%
with him on a couple occasions.

11:31.480 --> 11:35.200 align:start position:0%
Basically, this is a way of turning a

11:35.200 --> 11:38.200 align:start position:0%
C interpreter into a fast template JIT

11:38.200 --> 11:41.279 align:start position:0%
compiler. And what's really really

11:41.279 --> 11:43.560 align:start position:0%
nice is that we are able to maintain

11:43.560 --> 11:45.399 align:start position:0%
that single source of truth for how a

11:45.399 --> 11:47.320 align:start position:0%
bytecode instruction should be implemented.

11:47.320 --> 11:48.880 align:start position:0%
It doesn't require us to hand-write

11:48.880 --> 11:51.160 align:start position:0%
assembly, which means that if you want to

11:51.160 --> 11:53.399 align:start position:0%
fix a bug in the interpreter, and you

11:53.399 --> 11:55.720 align:start position:0%
already know how to fix bugs in the

11:55.720 --> 11:58.000 align:start position:0%
interpreter, the JIT will be fixed too,

11:58.000 --> 11:59.519 align:start position:0%
without you having to actually do

11:59.519 --> 12:01.000 align:start position:0%
anything. We have that one source of

12:01.000 --> 12:02.399 align:start position:0%
truth and everything's built

12:02.399 --> 12:04.360 align:start position:0%
automatically for you, but the JIT itself

12:04.360 --> 12:06.000 align:start position:0%
is still really fast and has good

12:06.000 --> 12:08.519 align:start position:0%
quality code. If you don't believe me,

12:08.519 --> 12:10.399 align:start position:0%
here are some numbers from the paper

12:10.399 --> 12:12.360 align:start position:0%
compared to a WebAssembly baseline

12:12.360 --> 12:14.680 align:start position:0%
compiler. Copy-and-Patch has five

12:14.680 --> 12:17.160 align:start position:0%
times faster code generation and 50%

12:17.160 --> 12:19.560 align:start position:0%
faster code overall. The code quality is

12:19.560 --> 12:21.040 align:start position:0%
really good, and I'll show you why in a

12:21.040 --> 12:24.000 align:start position:0%
second. Compared to a mid-tier

12:24.000 --> 12:27.120 align:start position:0%
compiler, like a traditional JIT

12:27.120 --> 12:29.880 align:start position:0%
toolchain, which would be LLVM with a low

12:29.880 --> 12:32.320 align:start position:0%
optimization level to keep things fast,

12:32.320 --> 12:34.440 align:start position:0%
it has 100 times faster code

12:34.440 --> 12:38.279 align:start position:0%
generation and still 15% faster code. And

12:38.279 --> 12:40.519 align:start position:0%
just to complete the numbers,

12:40.519 --> 12:42.800 align:start position:0%
compared to a full optimizing JIT with

12:42.800 --> 12:44.639 align:start position:0%
handwritten assembly, in this case LuaJIT,

12:44.639 --> 12:47.560 align:start position:0%
a Copy-and-Patch Lua

12:47.560 --> 12:49.920 align:start position:0%
implementation is still faster on some

12:49.920 --> 12:52.120 align:start position:0%
benchmarks, and it's only 35% slower

12:52.120 --> 12:54.279 align:start position:0%
overall, despite being much much simpler

12:54.279 --> 12:55.440 align:start position:0%
to maintain.

12:55.440 --> 12:59.399 align:start position:0%
So; how does it work? Well,

12:59.399 --> 13:02.240 align:start position:0%
let's think about the

13:02.240 --> 13:05.320 align:start position:0%
simplest form of a template JIT compiler.

13:05.320 --> 13:07.360 align:start position:0%
If we want to compile a sequence of

13:07.360 --> 13:09.000 align:start position:0%
bytecode instructions to machine code

13:09.000 --> 13:11.600 align:start position:0%
as fast as possible at runtime, what it

13:11.600 --> 13:13.279 align:start position:0%
might look like is walking over that

13:13.279 --> 13:15.199 align:start position:0%
sequence of bytecode instructions and

13:15.199 --> 13:17.839 align:start position:0%
then, for each one, copying over some

13:17.839 --> 13:20.199 align:start position:0%
static pre-compiled machine code into

13:20.199 --> 13:23.240 align:start position:0%
executable memory, and then going through

13:23.240 --> 13:24.760 align:start position:0%
that machine code and patching up

13:24.760 --> 13:26.240 align:start position:0%
instructions that need to have runtime

13:26.240 --> 13:28.639 align:start position:0%
data encoded in them. These would

13:28.639 --> 13:31.079 align:start position:0%
the be things like opargs, constants

13:31.079 --> 13:33.240 align:start position:0%
that we want to burn in, things like

13:33.240 --> 13:35.639 align:start position:0%
that. Now if you look at these two

13:35.639 --> 13:37.760 align:start position:0%
requirements, you'll notice that this

13:37.760 --> 13:39.279 align:start position:0%
sounds a lot like something we already

13:39.279 --> 13:42.199 align:start position:0%
have, which are relocatable object files.

13:42.199 --> 13:44.519 align:start position:0%
I could just as easily say, when

13:44.519 --> 13:46.560 align:start position:0%
linking or loading an ELF file, we want

13:46.560 --> 13:48.519 align:start position:0%
to copy some static pre-compiled machine

13:48.519 --> 13:50.720 align:start position:0%
code into executable memory, and then we

13:50.720 --> 13:51.959 align:start position:0%
want to patch up the instructions that

13:51.959 --> 13:53.480 align:start position:0%
need to have run some data encoded in

13:53.480 --> 13:55.519 align:start position:0%
them. These are relocations for

13:55.519 --> 13:56.480 align:start position:0%
extern symbols.

13:56.480 --> 13:58.959 align:start position:0%
And this is how Copy-and-Patch

13:58.959 --> 14:03.519 align:start position:0%
works. Basically, we will use LLVM

14:03.519 --> 14:07.120 align:start position:0%
to build an ELF object file, and then we

14:07.120 --> 14:08.440 align:start position:0%
parse out the stuff that we care about

14:08.440 --> 14:10.519 align:start position:0%
from that ELF object file: namely, the

14:10.519 --> 14:12.440 align:start position:0%
body of the bytecode instruction and

14:12.440 --> 14:14.160 align:start position:0%
any information on how we need to fix up

14:14.160 --> 14:16.279 align:start position:0%
the stuff that we want to fix up. I'm

14:16.279 --> 14:18.040 align:start position:0%
going to give you a concrete example, and

14:18.040 --> 14:19.800 align:start position:0%
by concrete I mean I'm glossing over

14:19.800 --> 14:21.639 align:start position:0%
some details so take everything at

14:21.639 --> 14:25.839 align:start position:0%
~80% face value, okay? So, we have a LOAD_FAST

14:25.839 --> 14:28.240 align:start position:0%
instruction here. We are going to

14:28.240 --> 14:30.000 align:start position:0%
take the body of that LOAD_FAST

14:30.000 --> 14:32.519 align:start position:0%
instruction, we're going to put it inside

14:32.519 --> 14:34.519 align:start position:0%
of some other code, that is going to be

14:34.519 --> 14:36.639 align:start position:0%
the scaffolding that we need to

14:36.639 --> 14:38.079 align:start position:0%
be able to extract the stuff that we

14:38.079 --> 14:39.959 align:start position:0%
care about later, and be able to stitch

14:39.959 --> 14:42.079 align:start position:0%
everything together. In this example,

14:42.079 --> 14:44.399 align:start position:0%
we are going to be burning in the oparg

14:44.399 --> 14:46.839 align:start position:0%
and we are going to be basically jumping

14:46.839 --> 14:48.519 align:start position:0%
into the next bytecode instruction,

14:48.519 --> 14:49.519 align:start position:0%
because we need to make sure that the

14:49.519 --> 14:51.839 align:start position:0%
code is laid out in a way that we can

14:51.839 --> 14:53.839 align:start position:0%
flow from one instruction to the next,

14:53.839 --> 14:55.959 align:start position:0%
and that LLVM won't move things

14:55.959 --> 14:59.920 align:start position:0%
around on us. So see here: I have

14:59.920 --> 15:04.600 align:start position:0%
some placeholders here, some

15:04.600 --> 15:06.920 align:start position:0%
things that I don't define, for magically

15:06.920 --> 15:08.880 align:start position:0%
inserting the oparg and magically

15:08.880 --> 15:10.079 align:start position:0%
continuing

15:10.079 --> 15:12.480 align:start position:0%
execution. Copy-and-patch solves this

15:12.480 --> 15:16.440 align:start position:0%
problem by using externs. So instead of

15:16.440 --> 15:18.720 align:start position:0%
using the value of the extern for our

15:18.720 --> 15:20.680 align:start position:0%
oparg, we use the address of the extern

15:20.680 --> 15:23.360 align:start position:0%
for our oparg, which allows LLVM to

15:23.360 --> 15:25.519 align:start position:0%
generate really efficient code that we

15:25.519 --> 15:27.839 align:start position:0%
can patch very very easily. When you're

15:27.839 --> 15:30.399 align:start position:0%
actually fixing up relocations, typically

15:30.399 --> 15:32.240 align:start position:0%
you're inserting the address of the

15:32.240 --> 15:35.519 align:start position:0%
extern into the relocatable code.

15:35.519 --> 15:37.000 align:start position:0%
With this we don't actually need to

15:37.000 --> 15:38.680 align:start position:0%
dreference the value at that address, we

15:38.680 --> 15:40.600 align:start position:0%
can just use the address directly, and so

15:40.600 --> 15:42.959 align:start position:0%
the code is really efficient. And

15:42.959 --> 15:44.360 align:start position:0%
since we're using clang, we have this

15:44.360 --> 15:46.880 align:start position:0%
beautiful `musttail` attribute on the

15:46.880 --> 15:49.399 align:start position:0%
final continuation call, which means that

15:49.399 --> 15:52.079 align:start position:0%
we will just get a single jump that

15:52.079 --> 15:55.000 align:start position:0%
we can use to flow into the next opcode.

15:55.000 --> 15:57.519 align:start position:0%
And even better, if that

15:57.519 --> 15:59.759 align:start position:0%
jump happens to be of length zero, we can just

15:59.759 --> 16:01.240 align:start position:0%
skip the jump

16:01.240 --> 16:03.720 align:start position:0%
entirely. So, the object file that we get

16:03.720 --> 16:05.839 align:start position:0%
out of this when we compile this to ELF

16:05.839 --> 16:07.120 align:start position:0%
looks a lot like this. We have

16:07.120 --> 16:08.600 align:start position:0%
everything we care about. We have the

16:08.600 --> 16:11.399 align:start position:0%
machine code here highlighted in blue,

16:11.399 --> 16:13.800 align:start position:0%
and we have the relocations and where

16:13.800 --> 16:15.880 align:start position:0%
their data is going to go. We know

16:15.880 --> 16:17.240 align:start position:0%
exactly how the data is going to be

16:17.240 --> 16:19.199 align:start position:0%
patched, and we know exactly where it's

16:19.199 --> 16:21.639 align:start position:0%
going to be. And so we can take this,

16:21.639 --> 16:24.079 align:start position:0%
parse it out and put it in static header

16:24.079 --> 16:27.519 align:start position:0%
files, and now we have all the data that

16:27.519 --> 16:29.600 align:start position:0%
we want to copy and then all the holes

16:29.600 --> 16:31.079 align:start position:0%
that we want to

16:31.079 --> 16:35.000 align:start position:0%
patch. So, I've been working on this

16:35.000 --> 16:37.240 align:start position:0%
for a couple months, and I've done

16:37.240 --> 16:38.720 align:start position:0%
this. If you want to check it out, it's

16:38.720 --> 16:41.680 align:start position:0%
on my fork of CPython. The branch name

16:41.680 --> 16:45.160 align:start position:0%
is justin, as in just-in-time. If you

16:45.160 --> 16:48.360 align:start position:0%
want to check it out, it works! You can

16:48.360 --> 16:50.639 align:start position:0%
also actually look at the code

16:50.639 --> 16:53.720 align:start position:0%
by going to GitHub and checking out

16:53.720 --> 16:54.920 align:start position:0%
my branch there.

16:54.920 --> 16:58.079 align:start position:0%
Just some kind of stats on the

16:58.079 --> 17:01.120 align:start position:0%
implementation itself: at build time

17:01.120 --> 17:03.920 align:start position:0%
it is about 700 lines of complex Python.

17:03.920 --> 17:06.240 align:start position:0%
This is python code that handles

17:06.240 --> 17:09.039 align:start position:0%
actually extracting all the cases,

17:09.039 --> 17:11.039 align:start position:0%
compiling each one, parsing out the elf,

17:11.039 --> 17:13.799 align:start position:0%
and then generating the header files.

17:13.799 --> 17:15.720 align:start position:0%
It has about 100 lines of complex C;

17:15.720 --> 17:17.199 align:start position:0%
those are the templates that I showed

17:17.199 --> 17:19.160 align:start position:0%
you that we actually insert the cases

17:19.160 --> 17:21.280 align:start position:0%
into, so that we can compile and

17:21.280 --> 17:24.600 align:start position:0%
extract them. And there is an LLVM

17:24.600 --> 17:26.160 align:start position:0%
dependency, but importantly this is

17:26.160 --> 17:27.799 align:start position:0%
a build-time dependency, not something

17:27.799 --> 17:30.840 align:start position:0%
that users need to install. Compare

17:30.840 --> 17:33.799 align:start position:0%
this to the runtime requirements.

17:33.799 --> 17:36.720 align:start position:0%
So we have 300 lines of simple C, again

17:36.720 --> 17:38.000 align:start position:0%
the nice thing about the copy-and-patch

17:38.000 --> 17:40.120 align:start position:0%
compiler is that it's really fast but

17:40.120 --> 17:42.280 align:start position:0%
it's also really simple – it's a memcpy

17:42.280 --> 17:43.799 align:start position:0%
and then walking over the relocations

17:43.799 --> 17:47.840 align:start position:0%
and just performing them. And then we

17:47.840 --> 17:50.000 align:start position:0%
have the 3,000 lines of simple generated

17:50.000 --> 17:51.960 align:start position:0%
C. And it truly is just as simple as the

17:51.960 --> 17:54.200 align:start position:0%
code that I showed you on the last slide.

17:54.800 --> 17:57.280 align:start position:0%
And most importantly, no runtime

17:57.280 --> 17:58.750 align:start position:0%
dependencies: everything is fully

17:58.750 --> 18:02.679 align:start position:0%
self-contained. And what I really like

18:02.679 --> 18:05.720 align:start position:0%
about this is that – from a maintainer

18:05.720 --> 18:08.520 align:start position:0%
point of view, I like that all the

18:08.520 --> 18:10.250 align:start position:0%
complexity has been shifted to build-time

18:10.250 --> 18:11.919 align:start position:0%
rather than run-time, and it's been

18:11.919 --> 18:13.880 align:start position:0%
shifted into Python code rather than C

18:13.880 --> 18:17.440 align:start position:0%
code. So we are able to do all of the

18:17.440 --> 18:19.640 align:start position:0%
fancy stuff later – when we

18:19.640 --> 18:21.720 align:start position:0%
actually start making this thing really

18:21.720 --> 18:23.360 align:start position:0%
really fast and really really performant

18:23.360 --> 18:26.760 align:start position:0%
and optimizing the code – in the Python

18:26.760 --> 18:29.440 align:start position:0%
code itself, rather than doing most of

18:29.440 --> 18:32.320 align:start position:0%
that work at runtime and in C code. I

18:32.320 --> 18:33.840 align:start position:0%
think we can all agree that we prefer

18:33.840 --> 18:35.600 align:start position:0%
writing python to C. Yeah, Pablo, did you have

18:35.600 --> 18:39.080 align:start position:0%
a question? — [Pablo] Yeah, so I'm curious why you

18:39.080 --> 18:42.600 align:start position:0%
need LLVM as a dependency. If I understand correctly,

18:42.600 --> 18:46.200 align:start position:0%
what you want is to generate the

18:46.200 --> 18:49.435
the object file (the ELF, yeah) ...

18:49.435 --> 18:52.000
parse it and put it into these templates,

18:52.000 --> 18:54.300 align:start position:0%
but couldn't you just use whatever compiler

18:54.300 --> 18:57.280 align:start position:0%
you're using to compile Python, to compile

18:57.280 --> 18:58.650
these templates and just

18:58.650 --> 19:00.100
parse the whole thing out?

19:00.100 --> 19:01.799 align:start position:0%
[Brandt] Yeah, so there are a

19:01.799 --> 19:03.120 align:start position:0%
couple reasons. The first one is that

19:03.120 --> 19:04.640 align:start position:0%
musttail attribute where we get

19:04.640 --> 19:07.080 align:start position:0%
guaranteed tail calls. GCC doesn't

19:07.080 --> 19:08.400 align:start position:0%
have that and we need tail calls for

19:08.400 --> 19:10.000 align:start position:0%
correctness, otherwise we'll blow the stack.

19:10.000 --> 19:11.800 align:start position:0%
[Greg] And you need Visual Studio to do it,

19:11.800 --> 19:14.700
like, every compiler would need this [???].

19:14.700 --> 19:16.520
[Brandt] Exactly. Clang is a great cross-

19:16.520 --> 19:18.880 align:start position:0%
compiler so it works in lots of places,

19:18.880 --> 19:22.280 align:start position:0%
and we also use some other LLVM tools.

19:22.280 --> 19:23.840 align:start position:0%
For example, we don't actually parse the

19:23.840 --> 19:26.520 align:start position:0%
ELF. LLVM has a tool that will dump

19:26.520 --> 19:29.080 align:start position:0%
ELF to JSON, which is great, so we

19:29.080 --> 19:30.840 align:start position:0%
actually just parse the JSON, which is

19:30.840 --> 19:34.080 align:start position:0%
beautiful. It also has a

19:34.080 --> 19:36.559 align:start position:0%
built-in disassembler, so the 3,000

19:36.559 --> 19:38.559 align:start position:0%
lines of header file is actually

19:38.559 --> 19:40.960 align:start position:0%
annotated, where above each

19:40.960 --> 19:43.520 align:start position:0%
dump of the assembly we actually have

19:43.520 --> 19:45.360 align:start position:0%
the human-readable assembly output as

19:45.360 --> 19:48.360 align:start position:0%
well, that you can audit and look at.

19:48.360 --> 19:51.360 align:start position:0%
And another thing: Once we

19:51.360 --> 19:53.000 align:start position:0%
start getting really clever with this,

19:53.000 --> 19:54.600 align:start position:0%
there are actually really cool things

19:54.600 --> 19:57.760 align:start position:0%
that you can do by using LLVM's

19:57.760 --> 20:00.480 align:start position:0%
wide variety of calling conventions.

20:00.480 --> 20:01.559 align:start position:0%
For example, they have calling

20:01.559 --> 20:03.559 align:start position:0%
conventions that pass all arguments in

20:03.559 --> 20:05.320 align:start position:0%
registers and have no callee-saved

20:05.320 --> 20:07.039 align:start position:0%
registers, which is ideal if you want to

20:07.039 --> 20:10.360 align:start position:0%
pin stack items in registers, and

20:10.360 --> 20:12.440 align:start position:0%
make the jump at the very end of the

20:12.440 --> 20:14.400 align:start position:0%
continuation really, really clean.

20:15.200 --> 20:17.000
Yes? [Thomas] Separate question:

20:17.800 --> 20:19.400
The build-time dependency,

20:19.400 --> 20:21.500 align:start position:0%
is that build-time or is it

20:21.700 --> 20:24.760 align:start position:0%
generate-files-time? Could we separate

20:24.760 --> 20:28.640 align:start position:0%
that out for CPython releases? [Brandt] Yes.

20:28.640 --> 20:31.120 align:start position:0%
The only thing we're using LLVM for

20:31.120 --> 20:33.919 align:start position:0%
is to generate one header file.

20:33.919 --> 20:35.200 align:start position:0%
Currently on my branch that's not

20:35.200 --> 20:36.919 align:start position:0%
checked into the repo because it's

20:36.919 --> 20:39.280 align:start position:0%
platform specific and even whatever your

20:39.280 --> 20:40.760 align:start position:0%
pyconfig looks like, it can change the

20:40.760 --> 20:42.960 align:start position:0%
way it works. [Thomas] Okay, so it does need to be

20:42.960 --> 20:45.039 align:start position:0%
built. [Brandt] Yeah, we could choose to check

20:45.039 --> 20:46.720 align:start position:0%
those in or host those somewhere or

20:46.720 --> 20:48.760 align:start position:0%
whatever. [Thomas] Well, if it's

20:48.760 --> 20:51.600 align:start position:0%
configure-specific, then you can't

20:51.600 --> 20:55.080 align:start position:0%
check them in. [Brandt] Yeah. I choose

20:55.080 --> 20:59.200 align:start position:0%
not to track it…

20:59.200 --> 21:01.720 align:start position:0%
So, it is technically

21:01.720 --> 21:04.120 align:start position:0%
generate-files-time, but it's not checked

21:04.120 --> 21:06.159 align:start position:0%
in, so it's built-time effectively.

21:06.159 --> 21:09.159 align:start position:0%
[Thomas] Yeah, also all the other

21:09.159 --> 21:12.039 align:start position:0%
generated files we have are platform

21:12.039 --> 21:14.440 align:start position:0%
agnostic. [Brandt] Yes. Yeah, I understand

21:14.440 --> 21:16.360 align:start position:0%
the question now. Yes, it's build time.

21:16.360 --> 21:19.000 align:start position:0%
[Victor] Can you put it in a container, like

21:19.000 --> 21:21.760 align:start position:0%
the thing that we using for configure? So

21:21.760 --> 21:24.240 align:start position:0%
everyone can run the commands and get

21:24.240 --> 21:26.600 align:start position:0%
the same output? [Thomas] No, because it depends on

21:26.600 --> 21:28.320 align:start position:0%
the platform. You would need need a

21:28.320 --> 21:29.800 align:start position:0%
container for every...

21:29.800 --> 21:32.250 align:start position:0%
You would need a container for your specific platform.

21:32.250 --> 21:34.300 align:start position:0%
[Brandt] It would be for every platform,

21:34.300 --> 21:36.159 align:start position:0%
every option of whether you have asserts turned

21:36.159 --> 21:38.559 align:start position:0%
on or off, debug turned on or off... By the way,

21:38.559 --> 21:40.120 align:start position:0%
you can put asserts and `printf`s and

21:40.120 --> 21:41.550 align:start position:0%
stuff inside of your cases and they'll

21:41.550 --> 21:44.000 align:start position:0%
just be in the assembly! It's awesome.

21:44.200 --> 21:46.720 align:start position:0%
[Guido] How long does it take at build

21:46.720 --> 21:48.050
time again? [Brandt] It depends.

21:48.050 --> 21:49.550
Do you have one of the new Macs?

21:49.550 --> 21:51.400 align:start position:0%
Because it takes like 30 seconds.

21:51.800 --> 21:53.440 align:start position:0%
On slower machines it's less

21:53.440 --> 21:56.320 align:start position:0%
than a minute. And it doesn't

21:56.320 --> 21:58.919 align:start position:0%
always rerun, so for example I have it

21:58.919 --> 22:00.720 align:start position:0%
cached so that it won't regenerate if

22:00.720 --> 22:02.760 align:start position:0%
the file's already present and the

22:02.760 --> 22:04.760 align:start position:0%
generated cases haven't changed. So in

22:04.760 --> 22:05.799 align:start position:0%
practice, if you're not modifying the

22:05.799 --> 22:07.880 align:start position:0%
interpreter, you won't see it. But

22:07.880 --> 22:09.919 align:start position:0%
otherwise it takes a few seconds on fast

22:09.919 --> 22:11.559 align:start position:0%
hardware and no more than a minute on

22:11.559 --> 22:12.800 align:start position:0%
everything else.

22:13.200 --> 22:15.500
[Victor] So, how does it work on Windows?

22:15.700 --> 22:17.750
[Brandt] Oh! Let's talk about platform support.

22:17.750 --> 22:20.500
[laughter]

22:20.800 --> 22:22.559 align:start position:0%
Victor, you will be happy to know

22:22.559 --> 22:25.080 align:start position:0%
that the initial

22:25.080 --> 22:27.360 align:start position:0%
implementation supports two platforms: It

22:27.360 --> 22:31.320 align:start position:0%
supports 32-bit Windows and 64-bit Windows.

22:31.320 --> 22:33.840 align:start position:0%
[Laughter] Micosoft!

22:33.840 --> 22:36.120 align:start position:0%
[Brandt] Just kidding. It supports all tier 1

22:36.120 --> 22:37.600 align:start position:0%
platforms. If you check it out right now

22:37.600 --> 22:39.559 align:start position:0%
on any of these, it'll work. In fact, it

22:39.559 --> 22:41.520 align:start position:0%
supports all tier 1 and tier 2

22:41.520 --> 22:44.400 align:start position:0%
platforms right now, except power PC.

22:44.400 --> 22:48.200 align:start position:0%
But we don't talk about that. [laughter]

22:48.500 --> 22:50.320 align:start position:0%
But, most notably, since clang

22:50.320 --> 22:52.600 align:start position:0%
is such a great cross-compiler, the

22:52.600 --> 22:55.320 align:start position:0%
default cross-compile setup just works

22:55.320 --> 22:56.760 align:start position:0%
perfectly. If you're doing cross-compiles

22:56.760 --> 22:59.120 align:start position:0%
now, don't change anything. Just

22:59.120 --> 23:02.559 align:start position:0%
install LLVM 16 nearby, and your

23:02.559 --> 23:04.760 align:start position:0%
regular build, your cross build, whatever

23:04.760 --> 23:06.279 align:start position:0%
options you're passing to configure...

23:06.279 --> 23:08.000 align:start position:0%
things just work.

23:08.500 --> 23:11.000
And, I think that's it!

23:11.100 --> 23:13.000
So, no questions, thank you.

23:13.200 --> 23:18.000 align:start position:0%
[Applause]

23:23.400 --> 23:25.780
Victor? Did you have a question...

23:26.050 --> 23:28.450
Okay, Carol, yeah?  [Carol] No, I was going to say:

23:28.550 --> 23:29.950
How does it compare to Numba?

23:30.050 --> 23:31.400 align:start position:0%
Does it work with GPUs?

23:31.600 --> 23:34.000 align:start position:0%
[Brandt] Uh, how does it to compare in terms of speed?

23:34.039 --> 23:36.159 align:start position:0%
[Carol] Yeah. [Brandt] So currently it is no faster

23:36.159 --> 23:37.480 align:start position:0%
than main when you have this turned on,

23:37.480 --> 23:39.880 align:start position:0%
but that represents a 5% improvement

23:39.880 --> 23:43.080 align:start position:0%
over the Micro Ops that it's based on,

23:43.080 --> 23:45.200 align:start position:0%
and we haven't done any of the fun tricks yet.

23:46.900 --> 23:48.800 align:start position:0%
So it's much slower than Numba.

23:50.150 --> 23:53.000 align:start position:0%
And what was the other question? Numba...

23:53.000 --> 23:54.800 align:start position:0%
[Carol] GPU support.

23:55.000 --> 23:56.725
[Brandt] GPU support,

23:56.725 --> 23:58.450
I would guess just as well as LLVM

23:58.559 --> 24:00.720 align:start position:0%
supports GPU, so I, I'm not doing

24:00.720 --> 24:02.460
anything special. Yeah.

24:02.460 --> 24:04.500
[Unknown] So if they aren CPUs, the resources

24:04.700 --> 24:05.800 align:start position:0%
aren't in the right place, so it's...

24:06.000 --> 24:07.760 align:start position:0%
[Brandt] Yeah, it's nice because for things

24:07.760 --> 24:10.360 align:start position:0%
like platform support or more specific

24:10.360 --> 24:12.559 align:start position:0%
like, hardware integration, we can just

24:12.559 --> 24:14.559 align:start position:0%
piggyback on LLVM. So if there's a way to

24:14.559 --> 24:16.640 align:start position:0%
make LLVM uh use the gpus more

24:16.640 --> 24:18.360 align:start position:0%
effectively then we can harness that too.

24:18.360 --> 24:22.360 align:start position:0%
At least for that build. [Carol] Yes, okay.

24:23.300 --> 24:25.520 align:start position:0%
Victor? [Victor] The thing about container is

24:25.550 --> 24:28.900
it possible on Linux to generate the,

24:29.100 --> 24:32.500
the generated part for all platforms, from Linux?

24:32.500 --> 24:34.800
[Unknown] You can do a cross-compiler container,

24:34.900 --> 24:36.039
with 20 cross-compilers in it, I think.

24:36.039 --> 24:38.500 align:start position:0%
You don't need the container,

24:38.500 --> 24:41.800 align:start position:0%
so if you install the cross-compiler tool chain,

24:42.500 --> 24:43.500 align:start position:0%
LLVM knows how to find that,

24:43.500 --> 24:44.600 align:start position:0%
and you can just build them all.

24:44.800 --> 24:46.400 align:start position:0%
'cause you don't actually need to

24:46.600 --> 24:48.000 align:start position:0%
run anything for this...

24:48.000 --> 24:50.300 align:start position:0%
[Unknown] He really wants to use a container. [Unknown] He does!

24:51.300 --> 24:54.000 align:start position:0%
When you ask people to install LLVM,

24:54.000 --> 24:55.900 align:start position:0%
they get different flavor,

24:55.900 --> 24:59.000 align:start position:0%
different [???], and the output can change,

24:59.200 --> 25:01.880 align:start position:0%
so maybe to configure it, put everything in

25:01.880 --> 25:04.799 align:start position:0%
a container we know that you always get

25:04.799 --> 25:07.200 align:start position:0%
exactly the same output. [Brandt] Yeah, we,

25:07.400 --> 25:09.480 align:start position:0%
that is definitely something important, but again

25:09.480 --> 25:11.080 align:start position:0%
remember this also depends on configure

25:11.080 --> 25:14.520 align:start position:0%
flags, so it's only as stable as those.

25:14.520 --> 25:17.720 align:start position:0%
Also on top of that, I mean, I have test,

25:17.720 --> 25:20.200 align:start position:0%
I do have CI running this on all the

25:20.200 --> 25:21.800 align:start position:0%
platforms I listed there,

25:24.000 --> 25:25.679 align:start position:0%
it's also tested against the full Matrix of

25:25.679 --> 25:28.799 align:start position:0%
LLVM 14, 15, and 16, so for all three of

25:28.799 --> 25:31.200 align:start position:0%
those I've verified that this passes

25:31.200 --> 25:33.200 align:start position:0%
the entire test suite.

25:33.500 --> 25:35.500 align:start position:0%
[Victor] So are you going to checkin this file

25:35.500 --> 25:39.000 align:start position:0%
in Python? [Brandt] I have no plans to.

25:39.800 --> 25:41.800 align:start position:0%
[Unknown] We should. [Victor] We should not...

25:41.800 --> 25:44.500 align:start position:0%
[Brandt] You can host a bunch of them somewhere if you want.

25:46.400 --> 25:47.360 align:start position:0%
[Unknown] It's like, I'm not sure we're going to

25:47.360 --> 25:48.919 align:start position:0%
need a container. Basically it sounds

25:48.919 --> 25:50.400 align:start position:0%
like this is working on a wide variety

25:50.400 --> 25:52.400 align:start position:0%
of things, it's just a matter of...

25:54.000 --> 25:56.000
... is pip installing LLVM, 

25:56.000 --> 25:58.100 align:start position:0%
 problem for people building Python?

26:00.000 --> 26:02.300 align:start position:0%
For the people in this room it's probably not, but...

26:02.300 --> 26:04.559 align:start position:0%
And if you check out my branch, too,

26:04.559 --> 26:07.200 align:start position:0%
there's a README in tools/jit,

26:07.400 --> 26:09.650 align:start position:0%
it tells you how to install LLVM on all

26:09.640 --> 26:11.360 align:start position:0%
platforms and again one thing I want to

26:11.360 --> 26:13.640 align:start position:0%
highlight is you don't need to build

26:13.640 --> 26:15.760 align:start position:0%
CPython itself with LLVM, or even the

26:15.760 --> 26:18.399 align:start position:0%
same version of LLVM. LLVM is only used

26:18.399 --> 26:20.500 align:start position:0%
just for generating that one header file.

26:21.500 --> 26:24.640 align:start position:0%
[Victor] So far, when you get a tarball of Python,

26:24.640 --> 26:28.559 align:start position:0%
you don't need LLVM, so it would be a new dependency?

26:28.900 --> 26:31.000 align:start position:0%
If, if you want to build the JIT, yes.

26:31.000 --> 26:32.919 align:start position:0%
So I imagine this behind a configure

26:32.919 --> 26:36.840 align:start position:0%
flag, where, I mean, just, just,

26:36.840 --> 26:39.760 align:start position:0%
spitballing here: If you don't pass

26:39.760 --> 26:41.080 align:start position:0%
the configure flag and you don't have

26:41.080 --> 26:44.240 align:start position:0%
LLVM installed, we don't do, we just do

26:44.240 --> 26:47.080 align:start position:0%
a normal build. If we smell that LLVM is

26:47.080 --> 26:48.640 align:start position:0%
nearby but you didn't pass the flag we

26:48.640 --> 26:50.159 align:start position:0%
can say: "Hey, by the way, you can build a

26:50.159 --> 26:52.000 align:start position:0%
JIT if you want to." And if you do pass

26:52.000 --> 26:54.600 align:start position:0%
the flag then we build the JIT.

26:56.000 --> 26:59.279 align:start position:0%
[Unknown] You can also leave work for a future of

26:59.279 --> 27:00.100
seeing if you can make something

27:00.100 --> 27:03.000
work on other compilers...

27:03.000 --> 27:05.120
... becomes a section of work for each compiler.

27:05.120 --> 27:09.000 align:start position:0%
[Unknown] Just that making that configure

27:09.000 --> 27:11.000 align:start position:0%
flag an optional thing is pretty much

27:11.000 --> 27:13.800 align:start position:0%
essential for iOS... [Brandt] Or like

27:13.800 --> 27:15.500 align:start position:0%
WebAssembly for example, or any of the list

27:15.520 --> 27:17.080 align:start position:0%
of tier-3 platforms that we

27:17.080 --> 27:20.240 align:start position:0%
absolutely can't build for.

27:20.240 --> 27:23.640 align:start position:0%
Uh, Pablo, sorry, I should say names.

27:23.640 --> 27:25.650 align:start position:0%
[Pablo] Do you need any special, like,

27:25.650 --> 27:27.200 align:start position:0%
magic thingies for macOS, like,

27:27.300 --> 27:29.300
I recall that it has some protections,

27:29.300 --> 27:31.550
and it's like, ...

27:31.520 --> 27:35.120 align:start position:0%
[Brandt] This is, I mean, JITs work on macOS,

27:35.120 --> 27:36.600 align:start position:0%
so you can't have, you can't have

27:36.600 --> 27:38.240 align:start position:0%
writable executable memory, and I think

27:38.240 --> 27:39.960 align:start position:0%
as of Sonoma you can't have readable

27:39.960 --> 27:42.320 align:start position:0%
executable memory, which is something

27:42.320 --> 27:44.039 align:start position:0%
I need to fix. So this won't work on

27:44.039 --> 27:46.120 align:start position:0%
Somoma because currently the memory is

27:46.120 --> 27:47.799 align:start position:0%
read-execute, but that's on my list of

27:47.799 --> 27:49.200
things to fix.

27:49.200 --> 27:51.559
[Unknown] Do we need to, like, to

27:51.559 --> 27:53.960 align:start position:0%
change like the way we need to release

27:53.960 --> 27:56.120 align:start position:0%
this for macOS? I recall that there's a

27:56.120 --> 27:58.159 align:start position:0%
way to ask for it, ...

27:58.159 --> 28:01.320 align:start position:0%
[Brandt] When you map the memory, you ask for

28:01.320 --> 28:05.720 align:start position:0%
the JIT... In the flags when you mmap the

28:05.720 --> 28:08.600 align:start position:0%
memory, you can say mmap JIT, I think,

28:08.600 --> 28:11.640 align:start position:0%
and that says I'm a JIT. [Unknown] I think you

28:11.640 --> 28:13.080 align:start position:0%
may be referring to platform

28:13.080 --> 28:14.679 align:start position:0%
restrictions where you need to actually

28:14.679 --> 28:16.550
set the executable up specially

28:16.550 --> 28:17.500
before you even run it.

28:17.500 --> 28:19.800 align:start position:0%
[Pablo] Let me rephrase: So when we

28:19.800 --> 28:21.940
build the macOS binary, 

28:22.500 --> 28:24.500
because I suppose for the one that you compile is

28:24.700 --> 28:28.399 align:start position:0%
the same you compile yourself (yes),

28:28.399 --> 28:30.840 align:start position:0%
like, do you know if we need to set

28:30.840 --> 28:32.160
anything or ask Apple...

28:32.160 --> 28:33.480
[Brandt] If we do I don't know

28:33.480 --> 28:35.120 align:start position:0%
that we need to, I'm not familiar with

28:35.120 --> 28:37.519 align:start position:0%
how we're actually building macOS

28:37.519 --> 28:39.760 align:start position:0%
releases differently from how I just

28:39.760 --> 28:41.880 align:start position:0%
build it locally. I can vouch for it

28:41.880 --> 28:43.500 align:start position:0%
working locally.

28:44.850 --> 28:47.240 align:start position:0%
[Unknown] Presumably the the release

28:47.240 --> 28:49.300 align:start position:0%
manager needs to use that flag?

28:49.700 --> 28:51.679 align:start position:0%
[Brandt] Yes, there's anything that needs to be done,

28:51.679 --> 28:53.279 align:start position:0%
that sounds like the release manager

28:53.279 --> 28:57.000 align:start position:0%
should do it, but I'm not aware of, yeah...

28:58.000 --> 29:00.900 align:start position:0%
It very well could be... The most,

29:00.900 --> 29:03.279 align:start position:0%
Most of the sort of permissions stuff

29:03.279 --> 29:05.519 align:start position:0%
I've had to debug has been on macOS

29:05.519 --> 29:08.300 align:start position:0%
specifically M1 Mac. Yeah.

29:09.200 --> 29:10.880 align:start position:0%
[Sam] So it sounds like the runtime

29:10.880 --> 29:13.000 align:start position:0%
code generation is super fast. (Yes). Why not

29:13.000 --> 29:17.000 align:start position:0%
just do this, either, for like, tier-1, or

29:17.000 --> 29:20.700 align:start position:0%
I forget what number it starts at, interpreter...

29:20.700 --> 29:22.600
Why only do this for tier-2?

29:22.600 --> 29:23.500
[Brandt] Well we definitely

29:23.500 --> 29:24.360 align:start position:0%
don't want to do it for

29:24.360 --> 29:26.720 align:start position:0%
unspecialized byte-code, right, because the

29:26.720 --> 29:28.519 align:start position:0%
specialized byte-code is, uh, where we're

29:28.519 --> 29:29.919 align:start position:0%
able to actually generate high quality

29:29.919 --> 29:32.080 align:start position:0%
code for, um, and the reason that we want

29:32.080 --> 29:33.960 align:start position:0%
to break it up into tier-2 code is

29:33.960 --> 29:36.039 align:start position:0%
because just by breaking it up we're not

29:36.039 --> 29:38.000 align:start position:0%
actually gaining anything, right?

29:38.000 --> 29:39.519 align:start position:0%
If anything we're losing something because

29:39.519 --> 29:42.600 align:start position:0%
LLVM is able to optimize less over the

29:42.600 --> 29:47.559 align:start position:0%
same context. But the kind of

29:47.559 --> 29:49.399 align:start position:0%
reason to build this on top of tier-2

29:49.399 --> 29:51.080 align:start position:0%
is because ideally we're going to

29:51.080 --> 29:52.960 align:start position:0%
optimize here too, and Ken Jin will talk a

29:52.960 --> 29:54.679 align:start position:0%
little bit more about that. But if

29:54.679 --> 29:56.960 align:start position:0%
we're able to remove guards or reorder

29:56.960 --> 29:59.880 align:start position:0%
things or hoist guards or whatever,

29:59.880 --> 30:01.950 align:start position:0%
then this builds on top of that,

30:01.950 --> 30:03.200 align:start position:0%
and so those guards won't be present

30:03.200 --> 30:04.600
in the generated machine code.

30:05.000 --> 30:06.050
[Sam] I get all that,

30:06.050 --> 30:07.350 align:start position:0%
but like, so the examples you're talking

30:07.360 --> 30:09.080 align:start position:0%
about that are already using this are

30:09.080 --> 30:10.960 align:start position:0%
using this for their baseline, right,

30:10.960 --> 30:12.399 align:start position:0%
they're using this before any

30:12.399 --> 30:15.080 align:start position:0%
optimizations. (Yes.) So wouldn't this be

30:15.080 --> 30:18.100 align:start position:0%
advantageous in the same use case for Python?

30:18.300 --> 30:21.000 align:start position:0%
[Brandt] It could be, I haven't tried it.

30:22.500 --> 30:25.450 align:start position:0%
[Unknown] We currently can't translate every

30:25.480 --> 30:28.279 align:start position:0%
tier-1 byte-code into a corresonding sequence

30:28.279 --> 30:31.240 align:start position:0%
of tier two by codes. [Brandt] Although we have...

30:31.240 --> 30:33.000 align:start position:0%
[Sam] Do you translate every tier-1 byte-code

30:33.000 --> 30:35.799 align:start position:0%
to copy-and-patch? [Brandt] No.

30:35.799 --> 30:37.800 align:start position:0%
No, because [???]'s input needs to be tier-2...

30:37.800 --> 30:39.800 align:start position:0%
[???]

30:40.000 --> 30:44.500 align:start position:0%
We could, it would just be different. Yeah.

30:44.500 --> 30:46.100
[Unknown] Can I try explaining this?

30:46.500 --> 30:47.500
[Brandt] Yeah, go ahead.

30:47.700 --> 30:49.100
[Unknown] It's specializaion.

30:49.300 --> 30:55.840
[???]

30:55.840 --> 30:58.120 align:start position:0%
ahead although have and we want

30:58.120 --> 31:00.039 align:start position:0%
effective profiling that gives us as

31:00.039 --> 31:02.600 align:start position:0%
well, so, tier-1 stuff

31:02.600 --> 31:04.120 align:start position:0%
because we're effectively

31:04.120 --> 31:06.800
specializing very quickly and dynamically

31:07.000 --> 31:26.159
we can... [???]

31:27.000 --> 31:28.519 align:start position:0%
Another thing too, I realized

31:28.519 --> 31:31.039 align:start position:0%
I didn't mention: The reason that the

31:31.039 --> 31:32.760 align:start position:0%
generated code is such high quality is

31:32.760 --> 31:35.399 align:start position:0%
because we don't care about the

31:35.399 --> 31:36.720 align:start position:0%
compile times when we're actually

31:36.720 --> 31:38.279 align:start position:0%
building this thing so we pull out all

31:38.279 --> 31:39.960 align:start position:0%
the stops and tell LLVM to optimize

31:39.960 --> 31:41.320 align:start position:0%
heavily, which is something you

31:41.320 --> 31:43.950 align:start position:0%
wouldn't want to do in a real-time JIT. Yes?

31:43.950 --> 31:46.639 align:start position:0%
[Unknown] When you generate the machine

31:46.639 --> 31:50.500 align:start position:0%
code can you pass the equivalent to

31:51.960 --> 31:54.500 align:start position:0%
compiler flags? [Brandt] Yeah. We're using clang.

31:54.700 --> 31:55.700
[Unkown] [???]

31:55.700 --> 32:00.200
[Brandt] Yes. Yeah. So we compile first

32:00.240 --> 32:02.559 align:start position:0%
using clang and that turns C code into

32:02.559 --> 32:06.080 align:start position:0%
LLVM textual IR. The only reason we

32:06.080 --> 32:07.519 align:start position:0%
do that is because we want to fix up the

32:07.519 --> 32:08.960 align:start position:0%
calling convention and clang doesn't

32:08.960 --> 32:10.880 align:start position:0%
actually let let us have this calling

32:10.880 --> 32:12.880 align:start position:0%
convention from C. So we fix up the

32:12.880 --> 32:15.720 align:start position:0%
calling convention using a hacky regex

32:15.720 --> 32:18.300 align:start position:0%
replacement that we'll change in the future.

32:20.000 --> 32:22.400 align:start position:0%
And then compile again to the ELF.

32:25.100 --> 32:27.720 align:start position:0%
[Carol] And you said it was under your org?

32:27.720 --> 32:29.350 align:start position:0%
[Brandt] Yeah, yeah. So my user, Brandt Bucher,

32:29.350 --> 32:31.200 align:start position:0%
it's on my fork of CPython.

32:31.200 --> 32:32.500 align:start position:0%
[Carol] Oh, it's on the fork of CPython.

32:32.500 --> 32:34.500 align:start position:0%
(Yes.) [Unknown] Show the URL again. (Yes.)

32:37.750 --> 32:40.195
[Brandt] That's the URL.

32:40.195 --> 32:43.000
So it's the "justin" branch of brandtbucher/cpython

32:43.000 --> 32:46.080 align:start position:0%
And if you go to tools/jit, there's

32:46.080 --> 32:47.399 align:start position:0%
a README in there that says how to

32:47.399 --> 32:49.500 align:start position:0%
install LLVM. [Carol] Sweet.

32:50.600 --> 32:51.880 align:start position:0%
[Antonio] It's more a question of the general

32:51.880 --> 32:53.600 align:start position:0%
approach, than the what you did so far.

32:53.600 --> 32:55.480 align:start position:0%
But once you have a [???] trace and you

32:55.480 --> 32:57.919 align:start position:0%
can have individual calls with this function

32:57.919 --> 33:00.519 align:start position:0%
another obvious thing to try is to put

33:00.519 --> 33:02.799 align:start position:0%
all these calls into a C file, compile it

33:02.799 --> 33:05.039 align:start position:0%
all together, and see what happens. (Yeah.)

33:05.039 --> 33:07.639 align:start position:0%
Have you tried? [Brandt] No, but one thing the

33:07.639 --> 33:09.399 align:start position:0%
paper did have good success with is

33:09.399 --> 33:11.360 align:start position:0%
actually compiling super-instructions

33:11.360 --> 33:14.480 align:start position:0%
of common pairs or triples, because then

33:14.480 --> 33:17.440 align:start position:0%
it really allows LLVM to optimize across...

33:17.440 --> 33:19.559 align:start position:0%
Especially for for example, like,

33:19.559 --> 33:21.000 align:start position:0%
obvious things that we may want to look

33:21.000 --> 33:25.639 align:start position:0%
at are, when we, so the micro-ops are

33:25.639 --> 33:27.639 align:start position:0%
kind of expanded from a single

33:27.639 --> 33:30.039 align:start position:0%
instruction, I would imagine that in

33:30.039 --> 33:32.080 align:start position:0%
many cases we aren't able to optimize

33:32.080 --> 33:33.279 align:start position:0%
that very heavily and so it ends up

33:33.279 --> 33:34.600 align:start position:0%
being the equivalent of the original

33:34.600 --> 33:35.799 align:start position:0%
instruction. So that'd be sort of low-

33:35.799 --> 33:37.279 align:start position:0%
hanging fruit for things that we could

33:37.279 --> 33:39.600 align:start position:0%
compile and, again, when we're just

33:39.600 --> 33:42.039 align:start position:0%
walking over we can window over and see

33:42.039 --> 33:45.320 align:start position:0%
if we have anything that's...

33:45.320 --> 33:48.000 align:start position:0%
[Unknown] [???] really involve the compiler and...

33:48.800 --> 33:52.150 align:start position:0%
[Brandt] Exactly and and right now we have,

33:52.200 --> 33:56.559 align:start position:0%
like, we have, one template for every

33:56.559 --> 33:59.360 align:start position:0%
micro-op, so like 200-some odd

33:59.360 --> 34:01.639 align:start position:0%
templates. In the paper they generated

34:01.639 --> 34:05.100 align:start position:0%
as many as like 10,000 (combinations) Yes.

34:05.100 --> 34:06.960 align:start position:0%
Not only for combinations but also,

34:06.960 --> 34:09.320 align:start position:0%
like, for example, if you have some

34:09.320 --> 34:12.560 align:start position:0%
instructions, for example, the

34:12.560 --> 34:14.159 align:start position:0%
control flow changes based on the value

34:14.159 --> 34:16.919 align:start position:0%
of the op-arg, so it may make sense to

34:16.919 --> 34:19.560 align:start position:0%
actually burn in values of the op-arg, not

34:19.560 --> 34:22.040 align:start position:0%
actually at JIT time, but ahead of time

34:22.040 --> 34:23.760 align:start position:0%
where you hard code those values and LLVM

34:23.760 --> 34:25.480 align:start position:0%
can optimize based on them and the op-arg

34:25.480 --> 34:28.159 align:start position:0%
is completely removed. Then there's

34:28.159 --> 34:29.760 align:start position:0%
also super-instructions, and there

34:29.760 --> 34:31.760 align:start position:0%
there's all sorts of games you can play.

34:31.760 --> 34:33.359 align:start position:0%
Another example would be if you're

34:33.359 --> 34:35.960 align:start position:0%
lifting things from stack items into

34:35.960 --> 34:39.399 align:start position:0%
registers, if you are kind of keeping

34:39.399 --> 34:41.359 align:start position:0%
that mapping of sstack items to registers,

34:41.359 --> 34:42.760 align:start position:0%
you may want to compile variants for

34:42.760 --> 34:44.560 align:start position:0%
different stack sizes, so that you

34:44.560 --> 34:47.240 align:start position:0%
have a finite number of mappings but

34:47.240 --> 34:51.000 align:start position:0%
you're able to keep things relatively simple.

34:53.000 --> 34:54.000
Victor again.

34:54.400 --> 34:56.300
[Victor] So what is your proposal?

34:56.300 --> 34:58.760 align:start position:0%
Do you want to to merge, or do

34:58.760 --> 35:02.599 align:start position:0%
you want to maintain it outside Python for now?

35:03.800 --> 35:04.920 align:start position:0%
[Brandt] I didn't really have a

35:04.920 --> 35:08.040 align:start position:0%
proposal today, but basically if this is

35:08.040 --> 35:09.720 align:start position:0%
something people would like to see in

35:09.720 --> 35:12.560 align:start position:0%
main, off by default, we can get it in

35:12.560 --> 35:14.560 align:start position:0%
main very easily. I know we aren't crazy

35:14.560 --> 35:16.079 align:start position:0%
about experiments in main, which is kind

35:16.079 --> 35:18.200 align:start position:0%
of why I'm floating the idea now.

35:18.200 --> 35:19.880 align:start position:0%
If not, this has been a long-lived branch

35:19.880 --> 35:24.160 align:start position:0%
since like May, and so, if it's

35:24.160 --> 35:25.960 align:start position:0%
any testament to like how easy it is to

35:25.960 --> 35:27.880 align:start position:0%
maintain this stuff, a lot of stuff has

35:27.880 --> 35:30.599 align:start position:0%
landed in main since May, and keeping

35:30.599 --> 35:32.560 align:start position:0%
this branch up to date, and improving

35:32.560 --> 35:35.100 align:start position:0%
during that time, has not been very difficult.

35:36.000 --> 35:38.839 align:start position:0%
Ken even borrowed,

35:38.839 --> 35:40.400 align:start position:0%
he basically merged this branch into his

35:40.400 --> 35:42.880 align:start position:0%
own branch a while back when he was

35:42.880 --> 35:45.160 align:start position:0%
playing around with optimizing stuff

35:45.160 --> 35:46.599 align:start position:0%
and wanted to see what would happen if

35:46.599 --> 35:49.119 align:start position:0%
he JITted it. Ken, is it easy to, like, add

35:49.119 --> 35:51.520 align:start position:0%
new byte-codes and work with the JIT as

35:51.520 --> 35:55.600 align:start position:0%
a, like, a API? [Ken] This is a [???] question,

35:55.600 --> 35:57.680 align:start position:0%
but yes.

35:58.500 --> 36:00.560 align:start position:0%
Yeah, the good thing is that you just

36:00.560 --> 36:02.640 align:start position:0%
need to install LLVM,

36:02.640 --> 36:05.700 align:start position:0%
and the script will automatically

36:05.700 --> 36:07.510
generate it for you.

36:07.510 --> 36:09.319
So, you don't actually need to

36:09.319 --> 36:12.560 align:start position:0%
know how it works in the background. (Yeah.)

36:12.560 --> 36:14.520 align:start position:0%
Oh, and, because like you said at one time

36:14.520 --> 36:16.560 align:start position:0%
patching in is really simple, so we

36:16.560 --> 36:18.000 align:start position:0%
actually had to modify the patching

36:18.000 --> 36:20.560 align:start position:0%
because our patches were of different

36:20.560 --> 36:24.119 align:start position:0%
types than [???] tracers, but even then, like,

36:24.119 --> 36:25.400 align:start position:0%
the file is just a for loop like you

36:25.400 --> 36:27.520 align:start position:0%
mentioned, and memcpy, so really simple to

36:27.520 --> 36:30.400 align:start position:0%
modify. [Brandt] Yeah. The actual code that JITs

36:30.400 --> 36:33.560 align:start position:0%
and copies and patches, like, of those 300

36:33.560 --> 36:37.280 align:start position:0%
lines of fairly simple C, like

36:37.280 --> 36:38.880 align:start position:0%
the hot loop where we're actually just

36:38.880 --> 36:40.599 align:start position:0%
walking over stuff selecting stencils

36:40.599 --> 36:42.520 align:start position:0%
and patching stuff is like maybe 20

36:42.520 --> 36:44.920 align:start position:0%
lines of code. The rest is sort of

36:44.920 --> 36:47.599 align:start position:0%
like handling permissions on Windows and

36:47.599 --> 36:50.700 align:start position:0%
Mac and all that kind of fun.

36:50.900 --> 36:54.560 align:start position:0%
[Victor] Is it possible to maintain it outside

36:54.560 --> 36:57.000 align:start position:0%
Python? I mean just technically,

36:57.000 --> 36:59.300 align:start position:0%
I don't know if it make sense or is it,

36:59.500 --> 37:01.200
is the implementation [???]

37:01.200 --> 37:03.400
with the implementation of Python itself?

37:03.400 --> 37:04.400
[Brandt] I would say that since

37:04.440 --> 37:06.800 align:start position:0%
we are using the same micro-ops as tier-2,

37:06.800 --> 37:09.600 align:start position:0%
we're pretty tightly coupled to the implementation.

37:10.780 --> 37:13.520 align:start position:0%
[Victor] Can we maintain it outside?

37:13.750 --> 37:17.800 align:start position:0%
[Brandt] Um, it could be.

37:18.700 --> 37:20.400 align:start position:0%
One thing that we would need...

37:20.400 --> 37:25.280 align:start position:0%
So, when we actually compile the code,

37:25.280 --> 37:28.720 align:start position:0%
we basically in those header files,

37:28.720 --> 37:30.040 align:start position:0%
if you have a bite code instruction that

37:30.040 --> 37:33.079 align:start position:0%
calls, for example, PyNumber_Add, right,

37:33.079 --> 37:35.300 align:start position:0%
that's a symbol that you need to "link against".

37:35.850 --> 37:36.760 align:start position:0%
And so the way we do that in

37:36.760 --> 37:38.880 align:start position:0%
the header file is we actually just put

37:38.880 --> 37:41.599 align:start position:0%
address of PyNumber_Add as an addend for

37:41.599 --> 37:43.200 align:start position:0%
that relocation.

37:43.900 --> 37:45.599 align:start position:0%
That works for PyNumber_Add,

37:45.599 --> 37:48.119 align:start position:0%
but if we were building this separately

37:48.119 --> 37:50.839 align:start position:0%
from CPython itself, there's a lot of

37:50.839 --> 37:52.760 align:start position:0%
internal APIs that would need to be

37:52.760 --> 37:54.400 align:start position:0%
exposed as public symbols in order for

37:54.400 --> 37:56.040 align:start position:0%
us to link them and actually linking

37:56.040 --> 37:57.800 align:start position:0%
them at run time would be a lot more

37:57.800 --> 38:00.280 align:start position:0%
complicated. We would first probably

38:00.280 --> 38:03.079 align:start position:0%
need to initialize all the stencils when

38:03.079 --> 38:04.760 align:start position:0%
the extension or whatever was first

38:04.760 --> 38:08.640 align:start position:0%
loaded, by walking over and the

38:08.640 --> 38:10.640 align:start position:0%
stencils and actually resolving all of

38:10.640 --> 38:12.280 align:start position:0%
those symbols, finding them in the

38:12.280 --> 38:15.160 align:start position:0%
current process with using dlsym, or

38:15.160 --> 38:17.119 align:start position:0%
whatever the windows equivalent is,

38:17.119 --> 38:18.680 align:start position:0%
walking over them and actually fixing up

38:18.680 --> 38:21.720 align:start position:0%
those add-ins, and then it would mostly

38:21.720 --> 38:25.359 align:start position:0%
be the same. But that sounds a lot

38:25.359 --> 38:27.599 align:start position:0%
more complicated than... And I don't think

38:27.599 --> 38:29.119 align:start position:0%
we want to stick all that stuff as

38:29.119 --> 38:32.880 align:start position:0%
public symbols. So it is doable in

38:32.880 --> 38:34.680 align:start position:0%
theory. I think the ergonomics make it

38:34.680 --> 38:37.600 align:start position:0%
like probably not the best option.

38:37.600 --> 38:38.850
[Victor] I'm just trying to understand,

38:38.850 --> 38:40.900
the advantages and disadvantages of

38:40.900 --> 38:43.100
maintaining outside. (Yeah.)

38:43.100 --> 38:46.600
So for example adding a dependency on LLVM is

38:46.500 --> 38:49.800
not that straightforward. [Brandt] Okay.

38:50.150 --> 38:53.300
So then, don't build the JIT.

38:53.500 --> 38:58.000 align:start position:0%
Or I'll build it for you, and I'll host it in a container.

38:58.000 --> 39:01.500
[Victor] [???] wants the JIT?

39:04.480 --> 39:06.359 align:start position:0%
[Unknown] That's why that's behind a configure flag for now.

39:06.350 --> 39:09.400 align:start position:0%
The answer to that, this unknown,

39:09.400 --> 39:11.440 align:start position:0%
this proves very useful, then we find way

39:11.440 --> 39:12.800
forward to actually do it.

39:13.000 --> 39:14.750
[Unknown] You can't at the same time

39:14.750 --> 39:16.200 align:start position:0%
say that you want the JIT,

39:16.200 --> 39:19.500 align:start position:0%
and say that you cannot

39:19.500 --> 39:22.400 align:start position:0%
have this dependency, right?

39:22.400 --> 39:25.079 align:start position:0%
[Uknown] This is what I want.

39:25.079 --> 39:28.640 align:start position:0%
[Brandt] I want a million dollars.

39:28.640 --> 39:31.200 align:start position:0%
We all want, things I get it.

39:31.500 --> 39:34.000 align:start position:0%
Yuri, did you have your hand up?

39:34.000 --> 39:37.520 align:start position:0%
[Yuri] Yeah, so, as far as I understand there's pretty

39:37.520 --> 39:39.160 align:start position:0%
much no alternative to this, like if you

39:39.160 --> 39:41.880 align:start position:0%
want to go with the JIT, it's either us

39:41.880 --> 39:43.900
spending a lot of resources

39:43.900 --> 39:46.000
handwriting all this...

39:48.600 --> 39:50.800 align:start position:0%
handwriting all of these kinds of code paths,

39:50.800 --> 39:53.280 align:start position:0%
generating them, which is one of

39:53.280 --> 39:55.040 align:start position:0%
the hardest parts of the GIT. Like, this is

39:55.040 --> 39:58.800 align:start position:0%
a nice hack, it allows us to save a lot of

39:58.800 --> 40:01.800 align:start position:0%
resources, it seems like the plan should be

40:01.800 --> 40:04.900
to merge this to the main branch

40:04.900 --> 40:05.900
as soon as possible so that

40:05.900 --> 40:07.900
[???] can continue working on it.

40:09.500 --> 40:12.500 align:start position:0%
Like, really, am I missing something? Is there...

40:12.500 --> 40:15.450
[Brandt] No, that's how I feel as well.

40:15.450 --> 40:17.400 align:start position:0%
And another thing too, just since you

40:17.400 --> 40:19.319 align:start position:0%
mentioned handwriting assembly, is that

40:19.319 --> 40:21.000 align:start position:0%
the two are not mutually exclusive. So

40:21.000 --> 40:22.640 align:start position:0%
for example if we see that there's a

40:22.640 --> 40:25.119 align:start position:0%
really common op-code, and we see that we

40:25.119 --> 40:27.720 align:start position:0%
can actually write better than LLVM can,

40:27.720 --> 40:30.040 align:start position:0%
for whatever reason, we can do that. The,

40:30.040 --> 40:31.720 align:start position:0%
the two play very nicely together. So it'd

40:31.720 --> 40:34.440 align:start position:0%
just be in that build script, the 700

40:34.440 --> 40:36.160 align:start position:0%
lines of Python or whatever, we just

40:36.160 --> 40:37.480 align:start position:0%
special case that op-code and say: "Hey,

40:37.480 --> 40:39.650 align:start position:0%
use this assembly file instead". Yeah?

40:39.650 --> 40:41.500 align:start position:0%
[Yuri] Quick question, followup question on the,

40:41.550 --> 40:42.800
on the benchmark numbers that you showed

40:42.800 --> 40:44.300
on one of the slides.

40:44.300 --> 40:45.800 align:start position:0%
So basically what they did they

40:45.800 --> 40:47.450 align:start position:0%
just replaced... So for example,

40:47.450 --> 40:49.200
in the case of LuaJIT compiler,

40:49.400 --> 40:51.600
they just replaced the handwritten

40:51.800 --> 40:53.800
code paths, [???] handwritten assembly,

40:53.800 --> 40:55.900
and what not, where they stopped,

40:55.900 --> 40:57.500 align:start position:0%
and they generated with this approach

40:57.500 --> 40:59.500 align:start position:0%
from the slow interpreter?

40:59.500 --> 41:02.440 align:start position:0%
[Brandt] No, it was a completely, like, new

41:02.440 --> 41:04.480 align:start position:0%
implementation that they wrote. So if you

41:04.480 --> 41:06.160 align:start position:0%
go to the blog post that I linked to

41:06.160 --> 41:09.520 align:start position:0%
earlier, it's a nice long blog post. If

41:09.520 --> 41:10.680 align:start position:0%
you don't know anything about JITs

41:10.680 --> 41:12.400 align:start position:0%
you'll know how JITs work after reading

41:12.400 --> 41:14.520 align:start position:0%
it. And it goes over copy-and-patch

41:14.520 --> 41:16.119 align:start position:0%
and also things like inline caching and

41:16.119 --> 41:18.359 align:start position:0%
whatever, but it's basically him

41:18.359 --> 41:22.400 align:start position:0%
implementing a LuaJIT, (okay) right, and

41:22.400 --> 41:24.140
and so it's the...

41:24.140 --> 41:25.200
[Yuri] So that's [???]?

41:25.200 --> 41:27.900 align:start position:0%
[Brandt] Yeah yeah, so it's the comparison of his,

41:27.900 --> 41:30.200 align:start position:0%
just, from scratch implementation versus an

41:30.200 --> 41:33.200 align:start position:0%
established fast implementation.

41:33.750 --> 41:35.700 align:start position:0%
[Unknown] What blog post is that?

41:35.700 --> 41:38.119 align:start position:0%
[Brandt] I can put it back up there.

41:39.100 --> 41:41.040 align:start position:0%
[Unknown] You could probably find it just by

41:41.040 --> 41:43.700 align:start position:0%
Googling for copy... [Brandt] Yeah if you,

41:43.700 --> 41:44.950
if you search for,

41:44.950 --> 41:47.000
oh wait did I skip it already? Hang on...

41:47.600 --> 41:49.950 align:start position:0%
[Unknown] I never saw the link to the blog post.

41:49.950 --> 41:52.500 align:start position:0%
[Brandt] It was underneath the paper.

41:52.500 --> 41:56.000 align:start position:0%
It's right... here...

41:56.000 --> 41:57.800
[Unknown] If you haven't linked those from

41:57.800 --> 41:59.750
your repo, you should check that in.

41:59.750 --> 42:03.000
[Brandt] Yes, I should. Indeed. So the,

42:03.000 --> 42:04.700
the top one is the paper,

42:04.700 --> 42:08.000 align:start position:0%
the bottom one is the blog post.

42:08.750 --> 42:11.200 align:start position:0%
[Carol] And I just posted, they did a

42:11.200 --> 42:14.440 align:start position:0%
presentation a few months ago as well.

42:14.440 --> 42:17.200 align:start position:0%
[Brandt] Was that for the paper? [Carol] Good slides.

42:17.200 --> 42:19.250 align:start position:0%
[Unknown] Just as an FYI,

42:19.250 --> 42:21.400 align:start position:0%
like, that may be a new paper, but we

42:21.400 --> 42:23.079 align:start position:0%
were doing this type of approach for a

42:23.079 --> 42:25.160 align:start position:0%
translator at Transmeta 20 years ago, and I

42:25.160 --> 42:27.200 align:start position:0%
doubt we were the first people doing this. But,

42:27.200 --> 42:29.050
templates from regular C code

42:29.050 --> 42:31.500
are very fast to JIT.

42:31.500 --> 42:33.000 align:start position:0%
[Brandt] Yeah, how was your experience with it?

42:33.000 --> 42:34.500
[Unknown] I mean, we shipped it in a product.

42:34.500 --> 42:36.200
[Brandt] Okay, let's ship it in a product!

42:36.200 --> 42:40.800
[Unknown] It was like [???]

42:41.000 --> 42:43.359 align:start position:0%
[Brandt] Yeah, I mean it is, I kind of

42:43.359 --> 42:46.720 align:start position:0%
view this as a, like, a baseline, but a

42:46.720 --> 42:48.880 align:start position:0%
really good one, (yeah) right, and so if we

42:48.880 --> 42:50.559 align:start position:0%
wanted to have another tier where we

42:50.559 --> 42:52.000 align:start position:0%
pull out all the stops on top of this

42:52.000 --> 42:54.119 align:start position:0%
that's a bridge we could cross, right.

42:54.119 --> 42:56.300 align:start position:0%
[Greg] This is easy to maintain, like,

42:56.300 --> 42:57.850
 you don't have to modify assembly,

42:57.850 --> 43:02.000
you modify the C code, ...

43:02.750 --> 43:04.359 align:start position:0%
[Yury] Another question in terms of the code

43:04.359 --> 43:07.319 align:start position:0%
style. Will you need to change a lot?

43:07.319 --> 43:09.040 align:start position:0%
So like, I know that you compile some of the

43:09.040 --> 43:11.000
functions already in the prototype, but,

43:11.000 --> 43:12.800
will the code style change?

43:12.800 --> 43:15.000
Or, it's essentially the same thing,

43:15.000 --> 43:18.839
maybe with a couple of [???] on top.

43:19.500 --> 43:21.500
[Brandt] When you say the code style,

43:21.500 --> 43:23.200
so, we extract,

43:23.200 --> 43:25.079 align:start position:0%
so basically, [Yury] the way you write

43:25.079 --> 43:28.850 align:start position:0%
code, essentially, (Python code?) op-codes, yes,

43:29.000 --> 43:31.000
(oh) will this change? [Brandt] I'm sure

43:31.000 --> 43:32.500
you'll see lots of blog posts of

43:32.500 --> 43:34.100 align:start position:0%
how to get the most out of CPython's

43:34.100 --> 43:36.350
new JIT, you know,

43:36.350 --> 43:38.700
[Greg] But those are all written by, you know,

43:40.000 --> 43:46.550 align:start position:0%
[mixed unclear speech and laughter]

43:46.839 --> 43:49.359 align:start position:0%
[Brandt] I don't think it'll be any

43:49.359 --> 43:50.680 align:start position:0%
different than the specializing

43:50.680 --> 43:52.640 align:start position:0%
interpreter, where it's just, we play to

43:52.640 --> 43:54.480 align:start position:0%
the benchmarks, the benchmarks we take to

43:54.480 --> 43:56.839 align:start position:0%
be somewhat realistic, and we look to

43:56.839 --> 43:59.680 align:start position:0%
confirm that that is true in practice.

43:59.680 --> 44:01.880 align:start position:0%
Right, um, and I'm sure that there are

44:01.880 --> 44:04.960 align:start position:0%
people who, you know, like, try to optimize

44:04.960 --> 44:06.640 align:start position:0%
for the specializing interpreter, and I'm

44:06.640 --> 44:07.680 align:start position:0%
sure there'll be people who try to

44:07.680 --> 44:09.720 align:start position:0%
optimize for this, but I think in general

44:09.720 --> 44:11.280 align:start position:0%
it'll just be a good low overhead way of

44:11.280 --> 44:14.300 align:start position:0%
speeding up, kind of, the world.

44:15.500 --> 44:16.300
Pablo?

44:16.300 --> 44:18.650
[Pablo] We already [???] want I want everyone

44:18.650 --> 44:21.400
to, kind of, discuss, so,

44:21.400 --> 44:24.800
what is the debugging situation of this code?

44:24.800 --> 44:26.200
For instance, one of the things ...

44:26.500 --> 44:40.750
[???]

44:41.550 --> 44:44.559 align:start position:0%
[Brandt] Yeah, um, so, I don't know enough about

44:44.559 --> 44:46.440 align:start position:0%
unwind tables, and that, and like, DWARF

44:46.440 --> 44:48.440 align:start position:0%
and all of that, to give a good answer. I

44:48.440 --> 44:50.520 align:start position:0%
can tell you that I don't include any

44:50.520 --> 44:52.559 align:start position:0%
unwind tables or DWARF in the JITted

44:52.559 --> 44:55.680 align:start position:0%
code and we disable frame pointers. But,

44:55.680 --> 44:56.680 align:start position:0%
if it's it's something that could be

44:56.680 --> 44:59.160 align:start position:0%
reused from the original ELF, then

44:59.160 --> 45:00.280 align:start position:0%
that's something that would be easy to

45:00.280 --> 45:02.280 align:start position:0%
harvest, otherwise we would have to

45:02.280 --> 45:03.600
kind of emit it ourselves.

45:03.600 --> 45:04.920
[Pablo] [???]

45:04.920 --> 45:07.440 align:start position:0%
be maybe to, maybe at the beginning when,

45:07.440 --> 45:10.040 align:start position:0%
I mean, at the beginning maybe when we are

45:10.040 --> 45:12.760 align:start position:0%
playing with it, maybe achieve ways to allow

45:12.760 --> 45:15.359 align:start position:0%
at least, to or detect if you're building

45:15.359 --> 45:17.040 align:start position:0%
Python itself with frame pointers and

45:17.040 --> 45:18.800 align:start position:0%
then generating the template with frame

45:18.800 --> 45:20.900
pointers (yeah) I assume you are going to copy

45:20.900 --> 45:22.750
[???]

45:22.750 --> 45:24.000 align:start position:0%
[Brandt] Yeah, so we're disabling frame

45:24.000 --> 45:25.400 align:start position:0%
pointers right now, just because we're

45:25.400 --> 45:26.960 align:start position:0%
passing arguments in registers, and that's a

45:26.960 --> 45:29.079 align:start position:0%
valuable register, but I mean this

45:29.079 --> 45:30.520 align:start position:0%
argument's been had a million times, so

45:30.520 --> 45:33.079 align:start position:0%
we can build with frame pointers, you

45:33.079 --> 45:34.880 align:start position:0%
know, it's easy enough just to say don't

45:34.880 --> 45:37.440 align:start position:0%
use that register, right, and so that

45:37.440 --> 45:40.559 align:start position:0%
could be the first step, and then... Again,

45:40.559 --> 45:41.960 align:start position:0%
I would need to do more research if I

45:41.960 --> 45:43.680 align:start position:0%
were to do it myself. [Pablo] Well at least

45:43.680 --> 45:46.800 align:start position:0%
having an escape hatch, I think, a first kind of

45:46.800 --> 45:48.000 align:start position:0%
line of it...

45:48.000 --> 45:59.000
[???]

45:59.520 --> 46:04.200 align:start position:0%
[Brandt] Yeah, if we were extract like if we

46:04.200 --> 46:06.760 align:start position:0%
could just extract all of this stuff

46:06.760 --> 46:09.079 align:start position:0%
from the ELF file is that something that

46:09.079 --> 46:11.680 align:start position:0%
could be reused or would need to be

46:11.680 --> 46:13.720 align:start position:0%
different every time we emit a copy of

46:13.720 --> 46:14.900
that stencil?

46:14.900 --> 46:17.300
[Pablo] You would probably need to patch the

46:17.240 --> 46:18.300
relocations as well.

46:18.300 --> 46:20.500
[Brandt] So there's relocations in the,

46:20.500 --> 46:23.100 align:start position:0%
like, the unwind tables and stuff?

46:23.100 --> 46:24.839 align:start position:0%
[Pablo] The DWARF tree has like what is

46:24.839 --> 46:27.440 align:start position:0%
called [???], and those will change when you

46:27.440 --> 46:29.319 align:start position:0%
place the code in different places, so

46:29.319 --> 46:32.250 align:start position:0%
you need to somehow say, "Oh this,

46:32.250 --> 46:34.750 align:start position:0%
this code now leads here", so you need to say

46:34.750 --> 46:37.100
[???] address [???] things,

46:37.300 --> 46:39.000
but most of the annoying stuff

46:39.000 --> 46:40.700 align:start position:0%
to generate you can just copy for this.

46:40.700 --> 46:42.960 align:start position:0%
[Brandt] Okay, yeah, if it's anything like the

46:42.960 --> 46:46.280 align:start position:0%
mechanics of extracting, like for example,

46:46.280 --> 46:50.559 align:start position:0%
static data, BSS data, executable text, and

46:50.559 --> 46:52.160 align:start position:0%
processing relocations on those, then the

46:52.160 --> 46:53.700 align:start position:0%
mechanics are almost identical, it sounds.

46:53.700 --> 46:56.000 align:start position:0%
[Pablo] It depends on how annoying [???]

46:56.000 --> 46:59.079 align:start position:0%
to retrieve it from the file, but if it's

46:59.079 --> 47:01.750 align:start position:0%
very easy and people have some [???] output

47:01.750 --> 47:04.559 align:start position:0%
I suppose it's (yeah) like, not like something that I

47:04.559 --> 47:06.500 align:start position:0%
think is super super important.

47:06.500 --> 47:08.500 align:start position:0%
[Brandt] Yeah. Two flags that I pass to clang

47:08.400 --> 47:11.800 align:start position:0%
currently are: omit frame pointer, and no

47:11.800 --> 47:16.160 align:start position:0%
asynchronous unwind tables. So if

47:16.160 --> 47:18.040 align:start position:0%
we, if that's the sort of stuff that

47:18.040 --> 47:19.520 align:start position:0%
just gets dumped in the ELF file and is

47:19.520 --> 47:21.440 align:start position:0%
reusable then it sounds like we have a

47:21.440 --> 47:22.920 align:start position:0%
promising path forward for a good

47:22.920 --> 47:24.720 align:start position:0%
debugging experience.

47:24.720 --> 47:34.359
[Greg] [???]

47:34.359 --> 47:36.250
[Brandt] Oh, I didn't see...

47:36.250 --> 47:37.500
[Unknown] I think we're getting too 

47:37.500 --> 47:40.450 align:start position:0%
much into implementation details.

47:40.450 --> 47:43.600
[Brandt] I'll be here all week!

47:43.600 --> 47:48.559
[Unknown] Thanks Brandt!
