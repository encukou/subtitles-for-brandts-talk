WEBVTT
Kind: captions
Language: en

00:06.480 --> 00:08.880 align:start position:0%
all right it's

00:08.880 --> 00:16.279 align:start position:0%


00:16.279 --> 00:18.840 align:start position:0%
talk all right so instead of giving this

00:18.840 --> 00:20.199 align:start position:0%
talk tomorrow by the way can everyone

00:20.199 --> 00:23.279 align:start position:0%
hear me or okay cool uh so instead of

00:23.279 --> 00:24.560 align:start position:0%
giving this talk tomorrow I'm giving it

00:24.560 --> 00:26.840 align:start position:0%
today uh I'm going to be sharing a

00:26.840 --> 00:28.760 align:start position:0%
little bit about something I have been

00:28.760 --> 00:30.400 align:start position:0%
thinking quite a bit about for last few

00:30.400 --> 00:32.840 align:start position:0%
months which is what Python's future jit

00:32.840 --> 00:35.440 align:start position:0%
compiler might look like or see Python's

00:35.440 --> 00:38.079 align:start position:0%
uh future jit compiler specifically um

00:38.079 --> 00:39.360 align:start position:0%
so I'm going to start with some

00:39.360 --> 00:42.079 align:start position:0%
background and this kind of um will also

00:42.079 --> 00:43.559 align:start position:0%
be good background for Ken's talk

00:43.559 --> 00:45.280 align:start position:0%
immediately after this on uh

00:45.280 --> 00:47.440 align:start position:0%
optimizations that we hope to perform uh

00:47.440 --> 00:50.440 align:start position:0%
specifically I'm mostly going to be uh

00:50.440 --> 00:52.000 align:start position:0%
kind of talking about some experiments

00:52.000 --> 00:54.280 align:start position:0%
that I've done with actually generating

00:54.280 --> 00:56.600 align:start position:0%
and executing machine code um not

00:56.600 --> 00:58.280 align:start position:0%
necessarily optimizations and things

00:58.280 --> 01:00.120 align:start position:0%
that happen in the meantime however I

01:00.120 --> 01:01.680 align:start position:0%
will be giving some background on that

01:01.680 --> 01:03.120 align:start position:0%
because I think it's really helpful for

01:03.120 --> 01:04.880 align:start position:0%
understanding how everything ties

01:04.880 --> 01:07.799 align:start position:0%
together um so a little recent history

01:07.799 --> 01:09.560 align:start position:0%
in cpython

01:09.560 --> 01:11.720 align:start position:0%
3.11 uh one of the headline features was

01:11.720 --> 01:14.880 align:start position:0%
the specializing adaptive interpreter um

01:14.880 --> 01:17.400 align:start position:0%
and so this delivered uh really good

01:17.400 --> 01:19.080 align:start position:0%
speedups I think the number we quoted

01:19.080 --> 01:22.200 align:start position:0%
most widely was something like 25% um if

01:22.200 --> 01:24.040 align:start position:0%
you want to take that at face value that

01:24.040 --> 01:26.240 align:start position:0%
it was just a one-time performance gain

01:26.240 --> 01:29.640 align:start position:0%
um that was nice to have then sure but

01:29.640 --> 01:31.400 align:start position:0%
if if you think about it and you read a

01:31.400 --> 01:32.600 align:start position:0%
little bit between the lines you

01:32.600 --> 01:33.799 align:start position:0%
understand that we're now collecting

01:33.799 --> 01:37.520 align:start position:0%
runtime profiling data for uh user code

01:37.520 --> 01:38.600 align:start position:0%
and that's something that we can use

01:38.600 --> 01:40.640 align:start position:0%
later if we want to lower that code and

01:40.640 --> 01:42.280 align:start position:0%
make it more statically

01:42.280 --> 01:46.159 align:start position:0%
typed in cpython 3.12 um we got a nice

01:46.159 --> 01:47.840 align:start position:0%
quality of life Improvement as

01:47.840 --> 01:50.600 align:start position:0%
maintainers uh we started generating The

01:50.600 --> 01:53.520 align:start position:0%
Interpreter cases the main switch from a

01:53.520 --> 01:55.759 align:start position:0%
domain specific language um and this

01:55.759 --> 01:59.920 align:start position:0%
allowed us to like an analyze and modify

01:59.920 --> 02:01.240 align:start position:0%
uh parts of The Interpreter at build

02:01.240 --> 02:03.840 align:start position:0%
time um this is really helpful for the

02:03.840 --> 02:05.840 align:start position:0%
people actually working on the bite code

02:05.840 --> 02:09.840 align:start position:0%
because we can uh uh worry less about

02:09.840 --> 02:12.560 align:start position:0%
things like uh error handling reference

02:12.560 --> 02:17.440 align:start position:0%
counts uh uh adding uh counters and

02:17.440 --> 02:19.480 align:start position:0%
stats and all those sorts of things um

02:19.480 --> 02:21.400 align:start position:0%
but at the same time again if you can

02:21.400 --> 02:23.160 align:start position:0%
kind of read between the lines uh we now

02:23.160 --> 02:24.440 align:start position:0%
are able to generate multiple

02:24.440 --> 02:26.160 align:start position:0%
interpreters um from a single source of

02:26.160 --> 02:29.160 align:start position:0%
Truth um and we also are able to

02:29.160 --> 02:31.239 align:start position:0%
generate lots of metadata uh by

02:31.239 --> 02:33.319 align:start position:0%
analyzing that single source of

02:33.319 --> 02:35.480 align:start position:0%
Truth so in

02:35.480 --> 02:38.040 align:start position:0%
313 um and again this is all stuff

02:38.040 --> 02:40.760 align:start position:0%
that's actually currently on Main um we

02:40.760 --> 02:42.680 align:start position:0%
do have an internal pipeline for

02:42.680 --> 02:45.360 align:start position:0%
detecting optimizing and executing hot

02:45.360 --> 02:47.840 align:start position:0%
code paths so this is off by default but

02:47.840 --> 02:50.239 align:start position:0%
if you build Python and you set the

02:50.239 --> 02:51.599 align:start position:0%
right environment variable or pass the

02:51.599 --> 02:54.959 align:start position:0%
right X option it's called uops

02:54.959 --> 02:59.560 align:start position:0%
uops Uh basically cpython will uh find

02:59.560 --> 03:02.239 align:start position:0%
hot Loops in your codee it will

03:02.239 --> 03:05.440 align:start position:0%
basically uh build a trace of that Loop

03:05.440 --> 03:08.840 align:start position:0%
and it will break it up into uh a more

03:08.840 --> 03:09.799 align:start position:0%
efficient

03:09.799 --> 03:12.799 align:start position:0%
representation and uh optimize it do

03:12.799 --> 03:15.120 align:start position:0%
some light optimization and execute it

03:15.120 --> 03:18.440 align:start position:0%
in a second interpreter now currently

03:18.440 --> 03:19.720 align:start position:0%
this is actually a little bit slower so

03:19.720 --> 03:21.000 align:start position:0%
you don't want to turn it on it's like a

03:21.000 --> 03:22.920 align:start position:0%
five or six% slower just because it's

03:22.920 --> 03:24.920 align:start position:0%
kind of the first phase of this entire

03:24.920 --> 03:27.360 align:start position:0%
pipeline um and in the end The

03:27.360 --> 03:29.519 align:start position:0%
Interpreter isn't really what we want to

03:29.519 --> 03:32.040 align:start position:0%
be executing these things I'll get to

03:32.040 --> 03:34.040 align:start position:0%
that later um but basically this

03:34.040 --> 03:35.280 align:start position:0%
wouldn't be possible without either of

03:35.280 --> 03:37.480 align:start position:0%
the first two steps um being able to

03:37.480 --> 03:39.560 align:start position:0%
break uh big complicated bite code

03:39.560 --> 03:41.239 align:start position:0%
instructions down into more simple

03:41.239 --> 03:43.760 align:start position:0%
Atomic steps is only possible because of

03:43.760 --> 03:46.599 align:start position:0%
the changes made in uh 3.11 for

03:46.599 --> 03:49.040 align:start position:0%
specialization and in 3.12 where we're

03:49.040 --> 03:51.720 align:start position:0%
able to Define uh uh bite code

03:51.720 --> 03:54.640 align:start position:0%
instructions in terms of smaller

03:54.640 --> 03:58.400 align:start position:0%
steps so I like uh providing examples

03:58.400 --> 03:59.840 align:start position:0%
just so we can kind of walk through what

03:59.840 --> 04:01.280 align:start position:0%
this pipeline looks like in practice and

04:01.280 --> 04:02.599 align:start position:0%
what it may look like in the future so

04:02.599 --> 04:03.879 align:start position:0%
we're going to look at my Fibonacci

04:03.879 --> 04:05.760 align:start position:0%
function here um it's pretty

04:05.760 --> 04:07.319 align:start position:0%
straightforward and specifically we're

04:07.319 --> 04:09.640 align:start position:0%
going to focus on the inner loop um it's

04:09.640 --> 04:11.280 align:start position:0%
pretty simple we're just looping over

04:11.280 --> 04:13.280 align:start position:0%
the range and then we update the values

04:13.280 --> 04:16.440 align:start position:0%
for A and B by adding A and B

04:16.440 --> 04:19.079 align:start position:0%
together uh so if you look at the bite

04:19.079 --> 04:20.359 align:start position:0%
code for this function it'll look

04:20.359 --> 04:25.120 align:start position:0%
something like this um uh you

04:25.120 --> 04:27.199 align:start position:0%
know if you want to know how the bite

04:27.199 --> 04:28.639 align:start position:0%
code works you can look at the disc

04:28.639 --> 04:30.520 align:start position:0%
documentation um but basically these are

04:30.520 --> 04:33.919 align:start position:0%
generic instructions um that have mostly

04:33.919 --> 04:35.800 align:start position:0%
remained unchanged since the earliest

04:35.800 --> 04:37.199 align:start position:0%
versions of

04:37.199 --> 04:40.560 align:start position:0%
python um however in 311 we got our

04:40.560 --> 04:43.080 align:start position:0%
specialized bite code um so that took

04:43.080 --> 04:45.120 align:start position:0%
generic operations like for iter and

04:45.120 --> 04:48.360 align:start position:0%
binary up and allowed us to specialize

04:48.360 --> 04:50.000 align:start position:0%
those at runtime for example for

04:50.000 --> 04:52.520 align:start position:0%
iterating over a range object or adding

04:52.520 --> 04:54.360 align:start position:0%
two integers

04:54.360 --> 04:58.759 align:start position:0%
together um so that's great um now in

04:58.759 --> 05:02.600 align:start position:0%
313 we're building micro op traces and

05:02.600 --> 05:04.360 align:start position:0%
so these Micro Ops are those smaller

05:04.360 --> 05:06.000 align:start position:0%
more Atomic steps that I was talking

05:06.000 --> 05:07.199 align:start position:0%
about that we're able to break

05:07.199 --> 05:11.360 align:start position:0%
individual instructions uh up into um so

05:11.360 --> 05:13.240 align:start position:0%
as I mentioned before you can actually

05:13.240 --> 05:15.560 align:start position:0%
run these things off of Main by passing

05:15.560 --> 05:18.759 align:start position:0%
The X option uops um and when you do

05:18.759 --> 05:20.600 align:start position:0%
that we will collect a trace for this

05:20.600 --> 05:22.440 align:start position:0%
Loop and we'll actually break each of

05:22.440 --> 05:25.160 align:start position:0%
these instructions up into uh their

05:25.160 --> 05:26.840 align:start position:0%
individual components so you can see

05:26.840 --> 05:28.280 align:start position:0%
that for some of the simpler

05:28.280 --> 05:30.479 align:start position:0%
instructions uh in they may only expand

05:30.479 --> 05:32.960 align:start position:0%
to uh two Micro Ops and that's what we

05:32.960 --> 05:35.440 align:start position:0%
call them Micro Ops um but the more

05:35.440 --> 05:38.319 align:start position:0%
complicated ones like for it range or um

05:38.319 --> 05:40.240 align:start position:0%
the integer addition may have several

05:40.240 --> 05:42.479 align:start position:0%
different parts um and what's nice about

05:42.479 --> 05:44.479 align:start position:0%
breaking those parts up is that if any

05:44.479 --> 05:45.919 align:start position:0%
of the parts are redundant for example

05:45.919 --> 05:47.080 align:start position:0%
if we're checking that something's an

05:47.080 --> 05:48.680 align:start position:0%
integer when we can actually prove that

05:48.680 --> 05:51.520 align:start position:0%
it's an integer then we can remove it um

05:51.520 --> 05:53.319 align:start position:0%
or if we want to move things around

05:53.319 --> 05:55.000 align:start position:0%
that's an option as

05:55.000 --> 05:59.600 align:start position:0%
well uh so another thing that uh 313

05:59.600 --> 06:01.720 align:start position:0%
Maine will currently do for you is we'll

06:01.720 --> 06:03.280 align:start position:0%
do some light optimization on these

06:03.280 --> 06:05.120 align:start position:0%
Micro Ops um So currently the only

06:05.120 --> 06:07.800 align:start position:0%
optimization we perform is we'll find a

06:07.800 --> 06:09.720 align:start position:0%
redundant frame pointer updates

06:09.720 --> 06:11.840 align:start position:0%
basically if we have an operation that

06:11.840 --> 06:14.280 align:start position:0%
cannot fail or the control flow cannot

06:14.280 --> 06:16.280 align:start position:0%
move uh to any other point in the

06:16.280 --> 06:18.680 align:start position:0%
program there's no reason for us to

06:18.680 --> 06:20.039 align:start position:0%
update the frame and say oh we're

06:20.039 --> 06:22.199 align:start position:0%
currently executing this instruction um

06:22.199 --> 06:24.199 align:start position:0%
so it's a very very simple optimization

06:24.199 --> 06:25.880 align:start position:0%
but it does work as a nice proof of

06:25.880 --> 06:28.000 align:start position:0%
concept and so um we will actually

06:28.000 --> 06:30.599 align:start position:0%
identify these four or set IP

06:30.599 --> 06:32.800 align:start position:0%
instructions and uh just remove them for

06:32.800 --> 06:35.080 align:start position:0%
you so that's just pure overhead that uh

06:35.080 --> 06:36.319 align:start position:0%
we're able to

06:36.319 --> 06:39.039 align:start position:0%
remove in the future and Ken will talk a

06:39.039 --> 06:40.440 align:start position:0%
little bit more about this we'll be able

06:40.440 --> 06:42.919 align:start position:0%
to do uh Stronger optimizations uh where

06:42.919 --> 06:44.560 align:start position:0%
we're able to remove more expensive

06:44.560 --> 06:46.800 align:start position:0%
checks so for instance if we can

06:46.800 --> 06:48.520 align:start position:0%
statically prove as we can in the case

06:48.520 --> 06:50.800 align:start position:0%
of this function that for example we're

06:50.800 --> 06:52.479 align:start position:0%
always iterating over a range object

06:52.479 --> 06:54.479 align:start position:0%
once we've entered this Loop and that uh

06:54.479 --> 06:56.400 align:start position:0%
A and B are both integers once we've

06:56.400 --> 06:58.080 align:start position:0%
entered this Loop then we can also

06:58.080 --> 07:00.560 align:start position:0%
remove those as well and what's left is

07:00.560 --> 07:02.199 align:start position:0%
basically the bare minimum amount of

07:02.199 --> 07:05.280 align:start position:0%
work required to uh actually execute

07:05.280 --> 07:06.960 align:start position:0%
this hot Inner Loop and you'll notice

07:06.960 --> 07:08.759 align:start position:0%
that this is entirely statically typed

07:08.759 --> 07:10.759 align:start position:0%
which is great for further

07:10.759 --> 07:14.000 align:start position:0%
lowering so um once we've removed all of

07:14.000 --> 07:15.960 align:start position:0%
that kind of extra stuff that we can

07:15.960 --> 07:19.000 align:start position:0%
prove we don't actually need then comes

07:19.000 --> 07:20.800 align:start position:0%
just in time compilation and that's kind

07:20.800 --> 07:21.800 align:start position:0%
of what I'm going to spend the rest of

07:21.800 --> 07:23.440 align:start position:0%
this uh time talking

07:23.440 --> 07:25.879 align:start position:0%
about um we have a couple different

07:25.879 --> 07:28.000 align:start position:0%
goals with the Justin Time compilation

07:28.000 --> 07:31.120 align:start position:0%
so um our main overarching goal is to

07:31.120 --> 07:33.680 align:start position:0%
remove interpretive overhead so we have

07:33.680 --> 07:37.039 align:start position:0%
removed all the extra sort of uh Dynamic

07:37.039 --> 07:39.599 align:start position:0%
work that needs to take place um but

07:39.599 --> 07:42.280 align:start position:0%
there's still a lot of other kind of

07:42.280 --> 07:43.919 align:start position:0%
overhead that just comes from the way

07:43.919 --> 07:46.280 align:start position:0%
the uh virtual machine is laid out and

07:46.280 --> 07:49.759 align:start position:0%
the way it interacts with data um so we

07:49.759 --> 07:51.520 align:start position:0%
want to remove interpretive overhead by

07:51.520 --> 07:53.639 align:start position:0%
statically compiling these optimized

07:53.639 --> 07:56.319 align:start position:0%
traces um and statically compiling them

07:56.319 --> 07:59.840 align:start position:0%
allows to us to reduce indirection um

07:59.840 --> 08:01.639 align:start position:0%
through a few different ways first of

08:01.639 --> 08:05.199 align:start position:0%
all we can burn in uh basically uh

08:05.199 --> 08:07.879 align:start position:0%
encode directly into the machine code

08:07.879 --> 08:10.599 align:start position:0%
the values of constants caches and uh

08:10.599 --> 08:13.440 align:start position:0%
arguments to instructions so basically

08:13.440 --> 08:16.080 align:start position:0%
uh instead of decoding uh in

08:16.080 --> 08:18.720 align:start position:0%
instructions uh opar every single time

08:18.720 --> 08:20.800 align:start position:0%
we execute that instruction we can

08:20.800 --> 08:23.000 align:start position:0%
instead for example make it an immediate

08:23.000 --> 08:26.159 align:start position:0%
value to uh an instruction in actual

08:26.159 --> 08:29.560 align:start position:0%
machine code um which uh repl is a

08:29.560 --> 08:31.280 align:start position:0%
memory load is a lot more Compact and a

08:31.280 --> 08:32.159 align:start position:0%
lot more

08:32.159 --> 08:34.599 align:start position:0%
efficient um we can also do things like

08:34.599 --> 08:36.320 align:start position:0%
moving data off of frames and into

08:36.320 --> 08:39.360 align:start position:0%
registers so the Micro Ops still execute

08:39.360 --> 08:41.640 align:start position:0%
on a python frame which means that

08:41.640 --> 08:43.360 align:start position:0%
intermediate values that live on the

08:43.360 --> 08:46.519 align:start position:0%
value stack are all still being written

08:46.519 --> 08:48.920 align:start position:0%
to memory and read from memory um so if

08:48.920 --> 08:50.680 align:start position:0%
we can lift all of that stuff out of

08:50.680 --> 08:52.600 align:start position:0%
memory and into actual Hardware

08:52.600 --> 08:55.360 align:start position:0%
registers um that saves a lot of traffic

08:55.360 --> 08:57.519 align:start position:0%
uh to and from uh main memory which is

08:57.519 --> 08:59.680 align:start position:0%
always a good thing um finally we can

08:59.680 --> 09:01.640 align:start position:0%
bring hot code paths in line so instead

09:01.640 --> 09:04.480 align:start position:0%
of having a uh large interpreter where

09:04.480 --> 09:06.720 align:start position:0%
we have all of these different cases uh

09:06.720 --> 09:08.279 align:start position:0%
that all need to be present because we

09:08.279 --> 09:10.880 align:start position:0%
can jump into them at any time um here

09:10.880 --> 09:12.640 align:start position:0%
we can make a straight line code path

09:12.640 --> 09:14.959 align:start position:0%
that executes exactly those instructions

09:14.959 --> 09:16.640 align:start position:0%
that I showed on the previous

09:16.640 --> 09:19.000 align:start position:0%
slide now these need to be weighed

09:19.000 --> 09:22.800 align:start position:0%
against some like practical goals right

09:22.800 --> 09:24.640 align:start position:0%
like I I don't think anyone wants me to

09:24.640 --> 09:27.720 align:start position:0%
dump like a 10,000 line C++ jit on us

09:27.720 --> 09:30.800 align:start position:0%
right so uh the first thing is Broad

09:30.800 --> 09:32.640 align:start position:0%
platform support python runs lots of

09:32.640 --> 09:35.000 align:start position:0%
places and arjit should too um I think

09:35.000 --> 09:36.440 align:start position:0%
that this is an ambitious goal but it's

09:36.440 --> 09:39.959 align:start position:0%
an important one uh I think that uh it

09:39.959 --> 09:42.240 align:start position:0%
should have few runtime dependencies for

09:42.240 --> 09:45.519 align:start position:0%
example I would like for this jit to be

09:45.519 --> 09:48.279 align:start position:0%
in a place where uh for example users

09:48.279 --> 09:50.680 align:start position:0%
wouldn't need to have a full lovm

09:50.680 --> 09:53.040 align:start position:0%
install for example um I don't think

09:53.040 --> 09:55.120 align:start position:0%
that's a good user experience it can

09:55.120 --> 09:56.680 align:start position:0%
maybe be made into a good user

09:56.680 --> 09:58.839 align:start position:0%
experience but I think I'd rather start

09:58.839 --> 10:01.120 align:start position:0%
from a place where you just download

10:01.120 --> 10:03.120 align:start position:0%
python the same way as you always have

10:03.120 --> 10:04.600 align:start position:0%
and everything just

10:04.600 --> 10:07.760 align:start position:0%
works um and finally and perhaps most

10:07.760 --> 10:10.120 align:start position:0%
importantly to me uh low implementation

10:10.120 --> 10:12.480 align:start position:0%
complexity um see python is

10:12.480 --> 10:14.920 align:start position:0%
overwhelmingly maintained by volunteers

10:14.920 --> 10:18.640 align:start position:0%
um and so I think that uh being able to

10:18.640 --> 10:22.120 align:start position:0%
keep the complexity down uh is a really

10:22.120 --> 10:24.279 align:start position:0%
really important goal to keep in mind in

10:24.279 --> 10:27.000 align:start position:0%
fact um I personally feel like it's

10:27.000 --> 10:28.760 align:start position:0%
worth sacrificing Peak Performance in

10:28.760 --> 10:30.880 align:start position:0%
order to keep the implementation as

10:30.880 --> 10:33.120 align:start position:0%
simple easy to maintain and easy to

10:33.120 --> 10:35.480 align:start position:0%
understand and teach and learn as

10:35.480 --> 10:38.760 align:start position:0%
possible um and so these are competing

10:38.760 --> 10:41.000 align:start position:0%
goals right like we want to make things

10:41.000 --> 10:43.600 align:start position:0%
fast but we're also willing to as I said

10:43.600 --> 10:45.639 align:start position:0%
sacrifice Peak Performance to make sure

10:45.639 --> 10:48.160 align:start position:0%
that you know this is something that we

10:48.160 --> 10:50.880 align:start position:0%
can all uh understand and that we can

10:50.880 --> 10:52.600 align:start position:0%
all maintain for the Long

10:52.600 --> 10:57.880 align:start position:0%
Haul so uh one kind of uh recent

10:57.880 --> 11:01.399 align:start position:0%
development uh in jit compiler

11:01.399 --> 11:03.680 align:start position:0%
technology is something called copy and

11:03.680 --> 11:05.120 align:start position:0%
Patch compilation and it actually

11:05.120 --> 11:07.000 align:start position:0%
fulfills many of these goals in a really

11:07.000 --> 11:09.480 align:start position:0%
satisfying way um so if you haven't

11:09.480 --> 11:11.639 align:start position:0%
heard about it which you know I hadn't

11:11.639 --> 11:14.279 align:start position:0%
heard about it that long ago um copy and

11:14.279 --> 11:16.800 align:start position:0%
Patch compilation comes out of a

11:16.800 --> 11:19.880 align:start position:0%
Stanford paper um but if you don't like

11:19.880 --> 11:22.399 align:start position:0%
reading the paper I highly recommend the

11:22.399 --> 11:24.160 align:start position:0%
uh blog post there's a blog post called

11:24.160 --> 11:26.079 align:start position:0%
building a baseline jit for Lua

11:26.079 --> 11:27.600 align:start position:0%
automatically this is by the same author

11:27.600 --> 11:29.079 align:start position:0%
as the paper and I've actually spoken

11:29.079 --> 11:31.480 align:start position:0%
with him on a couple occasions um

11:31.480 --> 11:35.200 align:start position:0%
basically this is a way of uh turning a

11:35.200 --> 11:38.200 align:start position:0%
c interpreter into a fast template jip

11:38.200 --> 11:41.279 align:start position:0%
compiler um and what's really really

11:41.279 --> 11:43.560 align:start position:0%
nice is that we are able to maintain

11:43.560 --> 11:45.399 align:start position:0%
that single source of Truth for how B

11:45.399 --> 11:47.320 align:start position:0%
code instruction should be implemented

11:47.320 --> 11:48.880 align:start position:0%
it doesn't require us to hand write

11:48.880 --> 11:51.160 align:start position:0%
assembly which means that if you want to

11:51.160 --> 11:53.399 align:start position:0%
fix a bug in The Interpreter and you

11:53.399 --> 11:55.720 align:start position:0%
already know how to fix bugs in The

11:55.720 --> 11:58.000 align:start position:0%
Interpreter the jib will be fixed too

11:58.000 --> 11:59.519 align:start position:0%
without you having to actually do

11:59.519 --> 12:01.000 align:start position:0%
anything we have that one source of

12:01.000 --> 12:02.399 align:start position:0%
Truth and everything's built

12:02.399 --> 12:04.360 align:start position:0%
automatically for you but the jit itself

12:04.360 --> 12:06.000 align:start position:0%
is still really fast and has good

12:06.000 --> 12:08.519 align:start position:0%
quality code um if you don't believe me

12:08.519 --> 12:10.399 align:start position:0%
here are some numbers from the paper

12:10.399 --> 12:12.360 align:start position:0%
compared to a web assembly Baseline

12:12.360 --> 12:14.680 align:start position:0%
compiler um copy and Patch has five

12:14.680 --> 12:17.160 align:start position:0%
times faster code generation and 50%

12:17.160 --> 12:19.560 align:start position:0%
faster code overall the code quality is

12:19.560 --> 12:21.040 align:start position:0%
really good and I'll show you why in a

12:21.040 --> 12:24.000 align:start position:0%
second um compared to a mid-tier

12:24.000 --> 12:27.120 align:start position:0%
compiler uh like a traditional J tool

12:27.120 --> 12:29.880 align:start position:0%
tool chain which would be lvm with a low

12:29.880 --> 12:32.320 align:start position:0%
optimization level to keep things fast

12:32.320 --> 12:34.440 align:start position:0%
um it has 100 times faster code

12:34.440 --> 12:38.279 align:start position:0%
generation and still 15% faster code and

12:38.279 --> 12:40.519 align:start position:0%
just to kind of complete the numbers uh

12:40.519 --> 12:42.800 align:start position:0%
compared to a full optimizing jit with

12:42.800 --> 12:44.639 align:start position:0%
handwritten assembly so in this case L

12:44.639 --> 12:47.560 align:start position:0%
jit um a copy and Patch low

12:47.560 --> 12:49.920 align:start position:0%
implementation it's still faster on some

12:49.920 --> 12:52.120 align:start position:0%
benchmarks and it's only 35% slower

12:52.120 --> 12:54.279 align:start position:0%
overall despite being much much simpler

12:54.279 --> 12:55.440 align:start position:0%
to

12:55.440 --> 12:59.399 align:start position:0%
maintain so how does it work well

12:59.399 --> 13:02.240 align:start position:0%
let's think about um the kind of

13:02.240 --> 13:05.320 align:start position:0%
simplest form of a template jit compiler

13:05.320 --> 13:07.360 align:start position:0%
if we want to compile uh sequence of

13:07.360 --> 13:09.000 align:start position:0%
bite code instructions to machine code

13:09.000 --> 13:11.600 align:start position:0%
as fast as possible at runtime what it

13:11.600 --> 13:13.279 align:start position:0%
might look like is walking over that

13:13.279 --> 13:15.199 align:start position:0%
sequence of bite code instructions and

13:15.199 --> 13:17.839 align:start position:0%
then for each one copying over some

13:17.839 --> 13:20.199 align:start position:0%
static pre-compiled machine code into

13:20.199 --> 13:23.240 align:start position:0%
executable memory and then going through

13:23.240 --> 13:24.760 align:start position:0%
that machine code and patching up

13:24.760 --> 13:26.240 align:start position:0%
instructions that need to have runtime

13:26.240 --> 13:28.639 align:start position:0%
data encoded in them um so these would

13:28.639 --> 13:31.079 align:start position:0%
the be things like op bars uh constants

13:31.079 --> 13:33.240 align:start position:0%
that we want to burn in things like

13:33.240 --> 13:35.639 align:start position:0%
that now if you look at these two

13:35.639 --> 13:37.760 align:start position:0%
requirements um you'll notice that this

13:37.760 --> 13:39.279 align:start position:0%
sounds a lot like something we already

13:39.279 --> 13:42.199 align:start position:0%
have which are relocatable object files

13:42.199 --> 13:44.519 align:start position:0%
so uh I could just as easily say when

13:44.519 --> 13:46.560 align:start position:0%
linking or loading an elf file we want

13:46.560 --> 13:48.519 align:start position:0%
to copy some static pre-compiled machine

13:48.519 --> 13:50.720 align:start position:0%
code into executable memory and then we

13:50.720 --> 13:51.959 align:start position:0%
want to patch up the instructions that

13:51.959 --> 13:53.480 align:start position:0%
need to have run some data encoded in

13:53.480 --> 13:55.519 align:start position:0%
them these are relocations for like X

13:55.519 --> 13:56.480 align:start position:0%
turn

13:56.480 --> 13:58.959 align:start position:0%
symbols and so this is how copy and P

13:58.959 --> 14:03.519 align:start position:0%
Works um basically we uh will use llvm

14:03.519 --> 14:07.120 align:start position:0%
to build an elf object file and then we

14:07.120 --> 14:08.440 align:start position:0%
parse out the stuff that we care about

14:08.440 --> 14:10.519 align:start position:0%
from that elf object file namely the

14:10.519 --> 14:12.440 align:start position:0%
body of the bite code instruction and

14:12.440 --> 14:14.160 align:start position:0%
any information on how we need to fix up

14:14.160 --> 14:16.279 align:start position:0%
the stuff that we want to fix out so I'm

14:16.279 --> 14:18.040 align:start position:0%
going to give you a concrete example and

14:18.040 --> 14:19.800 align:start position:0%
by concrete I mean I'm glossing over

14:19.800 --> 14:21.639 align:start position:0%
some details so take everything at like

14:21.639 --> 14:25.839 align:start position:0%
80% face value okay so uh we have a load

14:25.839 --> 14:28.240 align:start position:0%
fast instruction here um we are going to

14:28.240 --> 14:30.000 align:start position:0%
take the body of that load fast

14:30.000 --> 14:32.519 align:start position:0%
instruction we're going to put it inside

14:32.519 --> 14:34.519 align:start position:0%
of some other code that is going to be

14:34.519 --> 14:36.639 align:start position:0%
sort of the scaffolding that we need to

14:36.639 --> 14:38.079 align:start position:0%
be able to extract the stuff that we

14:38.079 --> 14:39.959 align:start position:0%
care about later and be able to stitch

14:39.959 --> 14:42.079 align:start position:0%
everything together so in this example

14:42.079 --> 14:44.399 align:start position:0%
we are going to be burning in the opar

14:44.399 --> 14:46.839 align:start position:0%
and we are going to be basically jumping

14:46.839 --> 14:48.519 align:start position:0%
into the next bite code instruction

14:48.519 --> 14:49.519 align:start position:0%
because we need to make sure that the

14:49.519 --> 14:51.839 align:start position:0%
code is laid out in a way that we can

14:51.839 --> 14:53.839 align:start position:0%
flow from one instruction to the next

14:53.839 --> 14:55.959 align:start position:0%
and that lbm will like move things

14:55.959 --> 14:59.920 align:start position:0%
around on us um so see here I have sort

14:59.920 --> 15:04.600 align:start position:0%
of um some placeholders here uh some uh

15:04.600 --> 15:06.920 align:start position:0%
things that I don't Define for magically

15:06.920 --> 15:08.880 align:start position:0%
inserting the op AR and magically

15:08.880 --> 15:10.079 align:start position:0%
continuing

15:10.079 --> 15:12.480 align:start position:0%
execution uh copy and Patch solves this

15:12.480 --> 15:16.440 align:start position:0%
problem by using xterms so uh instead of

15:16.440 --> 15:18.720 align:start position:0%
uh using the value of the X turn for our

15:18.720 --> 15:20.680 align:start position:0%
off Ark we use the address of the X turn

15:20.680 --> 15:23.360 align:start position:0%
for our off Ark which allows uh lvm to

15:23.360 --> 15:25.519 align:start position:0%
generate really efficient code that we

15:25.519 --> 15:27.839 align:start position:0%
can patch very very easily when you're

15:27.839 --> 15:30.399 align:start position:0%
actually fixing up relocations typically

15:30.399 --> 15:32.240 align:start position:0%
you're inserting the address of the

15:32.240 --> 15:35.519 align:start position:0%
extern into the uh relocatable code and

15:35.519 --> 15:37.000 align:start position:0%
so with this we don't actually need to

15:37.000 --> 15:38.680 align:start position:0%
dreference the value at that address we

15:38.680 --> 15:40.600 align:start position:0%
can just use the address directly and so

15:40.600 --> 15:42.959 align:start position:0%
the code is really efficient um and

15:42.959 --> 15:44.360 align:start position:0%
since we're using clang we have this

15:44.360 --> 15:46.880 align:start position:0%
beautiful must tail attribute on the

15:46.880 --> 15:49.399 align:start position:0%
final continuation call which means that

15:49.399 --> 15:52.079 align:start position:0%
we will just get a single jump um that

15:52.079 --> 15:55.000 align:start position:0%
we can use to flow into the next op code

15:55.000 --> 15:57.519 align:start position:0%
and even better if the next uh if that

15:57.519 --> 15:59.759 align:start position:0%
junp happens to be a l zero we can just

15:59.759 --> 16:01.240 align:start position:0%
skip the jump

16:01.240 --> 16:03.720 align:start position:0%
entirely so the object file that we get

16:03.720 --> 16:05.839 align:start position:0%
out of this when we compile this to elf

16:05.839 --> 16:07.120 align:start position:0%
looks a lot like this and we have

16:07.120 --> 16:08.600 align:start position:0%
everything we care about we have the

16:08.600 --> 16:11.399 align:start position:0%
machine code here highlighted in blue

16:11.399 --> 16:13.800 align:start position:0%
and we have the relocations and where

16:13.800 --> 16:15.880 align:start position:0%
their uh data is going to go we know

16:15.880 --> 16:17.240 align:start position:0%
exactly how the data is going to be

16:17.240 --> 16:19.199 align:start position:0%
patched and we know exactly where it's

16:19.199 --> 16:21.639 align:start position:0%
going to be and so we can take this

16:21.639 --> 16:24.079 align:start position:0%
parse it out and put it in static header

16:24.079 --> 16:27.519 align:start position:0%
files and now we have all the data that

16:27.519 --> 16:29.600 align:start position:0%
we want to copy and then all the holes

16:29.600 --> 16:31.079 align:start position:0%
that we want to

16:31.079 --> 16:35.000 align:start position:0%
patch um so uh I've been working on this

16:35.000 --> 16:37.240 align:start position:0%
for a couple months uh and I've done

16:37.240 --> 16:38.720 align:start position:0%
this so if you want to check it out it's

16:38.720 --> 16:41.680 align:start position:0%
on my Fork of cpython uh the branch name

16:41.680 --> 16:45.160 align:start position:0%
is Justin as in Justin time so uh if you

16:45.160 --> 16:48.360 align:start position:0%
want to check it out it works um you can

16:48.360 --> 16:50.639 align:start position:0%
also just like actually look at The Code

16:50.639 --> 16:53.720 align:start position:0%
by uh going to uh ghub and uh check out

16:53.720 --> 16:54.920 align:start position:0%
my Branch

16:54.920 --> 16:58.079 align:start position:0%
there um just some kind of stats on the

16:58.079 --> 17:01.120 align:start position:0%
implement ation itself um at build time

17:01.120 --> 17:03.920 align:start position:0%
it is about 700 lines of complex python

17:03.920 --> 17:06.240 align:start position:0%
um so this is python code that handles

17:06.240 --> 17:09.039 align:start position:0%
uh actually extracting all the cases

17:09.039 --> 17:11.039 align:start position:0%
compiling each one parsing out the elf

17:11.039 --> 17:13.799 align:start position:0%
and then generating the header files um

17:13.799 --> 17:15.720 align:start position:0%
it has about 100 lines of complex c

17:15.720 --> 17:17.199 align:start position:0%
those are the templates that I showed

17:17.199 --> 17:19.160 align:start position:0%
you that we actually insert the cases

17:19.160 --> 17:21.280 align:start position:0%
into so that we can comp compile and

17:21.280 --> 17:24.600 align:start position:0%
extract them um and there is an lovm

17:24.600 --> 17:26.160 align:start position:0%
dependency but most importantly this is

17:26.160 --> 17:27.799 align:start position:0%
a fill time dependency not something

17:27.799 --> 17:30.840 align:start position:0%
that users need to install um compare

17:30.840 --> 17:33.799 align:start position:0%
this to the uh runtime requirements um

17:33.799 --> 17:36.720 align:start position:0%
so we have 300 lines of simple C again

17:36.720 --> 17:38.000 align:start position:0%
the nice thing about the copy and Patch

17:38.000 --> 17:40.120 align:start position:0%
compiler is that it's really fast but

17:40.120 --> 17:42.280 align:start position:0%
it's also really simple it's a mem copy

17:42.280 --> 17:43.799 align:start position:0%
and then walking over the relocations

17:43.799 --> 17:47.840 align:start position:0%
and just performing them um and then we

17:47.840 --> 17:50.000 align:start position:0%
have the 3,000 lines of simple generated

17:50.000 --> 17:51.960 align:start position:0%
C and it truly is just as simple as the

17:51.960 --> 17:53.919 align:start position:0%
code that I showed you on the last

17:53.919 --> 17:57.280 align:start position:0%
slide um and most importantly no runtime

17:57.280 --> 17:59.880 align:start position:0%
dependencies everything is full fully

17:59.880 --> 18:02.679 align:start position:0%
self-contained um and what I really like

18:02.679 --> 18:05.720 align:start position:0%
about this is that uh from a maintainer

18:05.720 --> 18:08.520 align:start position:0%
point of view I like that uh all the

18:08.520 --> 18:09.919 align:start position:0%
complexity has been shifted to build

18:09.919 --> 18:11.919 align:start position:0%
time rather than run time and it's been

18:11.919 --> 18:13.880 align:start position:0%
shifted into python code rather than C

18:13.880 --> 18:17.440 align:start position:0%
code um so we are able to do all of the

18:17.440 --> 18:19.640 align:start position:0%
kind of fancy stuff later when we

18:19.640 --> 18:21.720 align:start position:0%
actually start making this thing really

18:21.720 --> 18:23.360 align:start position:0%
really fast and really really performant

18:23.360 --> 18:26.760 align:start position:0%
and optimizing the code um in the python

18:26.760 --> 18:29.440 align:start position:0%
code itself um rather than doing most of

18:29.440 --> 18:32.320 align:start position:0%
that work at runtime and in uh C code I

18:32.320 --> 18:33.840 align:start position:0%
think we can all agree that we prefer

18:33.840 --> 18:35.600 align:start position:0%
writing python to C yeah PA did you have

18:35.600 --> 18:39.080 align:start position:0%
a question yeah so I'm curious why you

18:39.080 --> 18:42.600 align:start position:0%
need L dependency

18:42.600 --> 18:47.640 align:start position:0%
like you want to generate the

18:47.640 --> 18:52.520 align:start position:0%
object it into it put into templates but

18:52.520 --> 18:54.440 align:start position:0%
you just use whatever compiler you're

18:54.440 --> 18:57.280 align:start position:0%
using to compile python to just compile

18:57.280 --> 18:59.799 align:start position:0%
maybe this templ and as far as they

18:59.799 --> 19:01.799 align:start position:0%
below yeah so there yeah there are a

19:01.799 --> 19:03.120 align:start position:0%
couple reasons so the first one is that

19:03.120 --> 19:04.640 align:start position:0%
must tail attribute where we get

19:04.640 --> 19:07.080 align:start position:0%
guaranteed tail calls GC GCC doesn't

19:07.080 --> 19:08.400 align:start position:0%
have that and we need tail calls for

19:08.400 --> 19:10.000 align:start position:0%
correctness otherwise we'll blow the

19:10.000 --> 19:13.720 align:start position:0%
stack stud every

19:13.720 --> 19:16.520 align:start position:0%
comp exactly clang is a great cross

19:16.520 --> 19:18.880 align:start position:0%
compiler so it it works lots of places

19:18.880 --> 19:22.280 align:start position:0%
um and we also use some other LM tools

19:22.280 --> 19:23.840 align:start position:0%
for example we don't actually parse the

19:23.840 --> 19:26.520 align:start position:0%
elf um LM has a tool that will dump El

19:26.520 --> 19:29.080 align:start position:0%
elf to Json which is great oh so we

19:29.080 --> 19:30.840 align:start position:0%
actually just parse the Json which is

19:30.840 --> 19:34.080 align:start position:0%
beautiful um it also has uh you know a

19:34.080 --> 19:36.559 align:start position:0%
built-in disassembler so uh the 3,000

19:36.559 --> 19:38.559 align:start position:0%
lines of header file is actually

19:38.559 --> 19:40.960 align:start position:0%
annotated where each above each kind of

19:40.960 --> 19:43.520 align:start position:0%
dump of the assembly um we actually have

19:43.520 --> 19:45.360 align:start position:0%
the human readable assembly output as

19:45.360 --> 19:48.360 align:start position:0%
well that you can audit and look at um

19:48.360 --> 19:51.360 align:start position:0%
and another thing too is uh once we

19:51.360 --> 19:53.000 align:start position:0%
start getting really clever with this uh

19:53.000 --> 19:54.600 align:start position:0%
there are actually really cool things

19:54.600 --> 19:57.760 align:start position:0%
that you can do by using lm's uh like

19:57.760 --> 20:00.480 align:start position:0%
wide VAR iy of calling conventions um so

20:00.480 --> 20:01.559 align:start position:0%
for example they have calling

20:01.559 --> 20:03.559 align:start position:0%
conventions that pass all arguments in

20:03.559 --> 20:05.320 align:start position:0%
registers and have no call E saved

20:05.320 --> 20:07.039 align:start position:0%
registers which is ideal if you want to

20:07.039 --> 20:10.360 align:start position:0%
like pin stack items in registers and uh

20:10.360 --> 20:12.440 align:start position:0%
make the jump at the very end of the

20:12.440 --> 20:14.640 align:start position:0%
continuation really really

20:14.640 --> 20:18.559 align:start position:0%
clean yes separate question um the bill

20:18.559 --> 20:21.240 align:start position:0%
time dependency is that bill time or is

20:21.240 --> 20:24.760 align:start position:0%
it generate files time could we separate

20:24.760 --> 20:28.640 align:start position:0%
that out could for python releases yes

20:28.640 --> 20:31.120 align:start position:0%
yeah the only thing we're using L LM for

20:31.120 --> 20:33.919 align:start position:0%
is to generate one header file um So

20:33.919 --> 20:35.200 align:start position:0%
currently on my Branch that's not

20:35.200 --> 20:36.919 align:start position:0%
checked into the rapo because it's

20:36.919 --> 20:39.280 align:start position:0%
platform specific and even whatever your

20:39.280 --> 20:40.760 align:start position:0%
pie config looks like it can change the

20:40.760 --> 20:42.960 align:start position:0%
way it works okay so it does need to be

20:42.960 --> 20:45.039 align:start position:0%
built yeah we could choose to check

20:45.039 --> 20:46.720 align:start position:0%
those in or host those somewhere or

20:46.720 --> 20:48.760 align:start position:0%
whatever um well if it's if it's

20:48.760 --> 20:51.600 align:start position:0%
configured specific yeah then you can't

20:51.600 --> 20:55.080 align:start position:0%
check them in yeah yeah it it I I choose

20:55.080 --> 20:59.200 align:start position:0%
not to track it um you know uh

20:59.200 --> 21:01.720 align:start position:0%
yeah so it is it is it is technically

21:01.720 --> 21:04.120 align:start position:0%
generate files time but it's not checked

21:04.120 --> 21:06.159 align:start position:0%
in so it's built time effectively well

21:06.159 --> 21:09.159 align:start position:0%
yeah it it also I mean all the other

21:09.159 --> 21:12.039 align:start position:0%
generated files we have are platform

21:12.039 --> 21:14.440 align:start position:0%
agnostic yes yeah yeah I I understand

21:14.440 --> 21:16.360 align:start position:0%
the question now yes it's build time

21:16.360 --> 21:19.000 align:start position:0%
okay yeah you put it in a container like

21:19.000 --> 21:21.760 align:start position:0%
the thing that we using for configure so

21:21.760 --> 21:24.240 align:start position:0%
everyone can run the commands and get

21:24.240 --> 21:26.600 align:start position:0%
the same out no because it depends on

21:26.600 --> 21:28.320 align:start position:0%
the platform so you would need need a

21:28.320 --> 21:30.039 align:start position:0%
container for every you would need a

21:30.039 --> 21:32.360 align:start position:0%
container for your specific platform it

21:32.360 --> 21:34.799 align:start position:0%
would be for every platform every option

21:34.799 --> 21:36.159 align:start position:0%
of whether you have a search turned on

21:36.159 --> 21:38.559 align:start position:0%
or off debug turned on or off by the way

21:38.559 --> 21:40.120 align:start position:0%
you can put asserts and printfs and

21:40.120 --> 21:41.640 align:start position:0%
stuff inside of your cases and they'll

21:41.640 --> 21:43.880 align:start position:0%
just be in the assembly it's

21:43.880 --> 21:46.720 align:start position:0%
awesome how long does it take a build

21:46.720 --> 21:48.640 align:start position:0%
time again it depends you have one of

21:48.640 --> 21:50.760 align:start position:0%
the new Macs because it takes like 30

21:50.760 --> 21:53.440 align:start position:0%
seconds on on slower machines it's less

21:53.440 --> 21:56.320 align:start position:0%
than a minute um and it doesn't uh

21:56.320 --> 21:58.919 align:start position:0%
always rerun so for example I have it

21:58.919 --> 22:00.720 align:start position:0%
cached so that it won't regenerate if

22:00.720 --> 22:02.760 align:start position:0%
the file's already present and the

22:02.760 --> 22:04.760 align:start position:0%
generated cases haven't changed so in

22:04.760 --> 22:05.799 align:start position:0%
practice if you're not modifying The

22:05.799 --> 22:07.880 align:start position:0%
Interpreter you won't see it but um

22:07.880 --> 22:09.919 align:start position:0%
otherwise it takes a few seconds on Fast

22:09.919 --> 22:11.559 align:start position:0%
hardware and no more than a minute on

22:11.559 --> 22:12.520 align:start position:0%
everything

22:12.520 --> 22:16.720 align:start position:0%
else so do windows oh let's talk about

22:16.720 --> 22:20.120 align:start position:0%


22:20.120 --> 22:22.559 align:start position:0%
support Victor you will be happy to know

22:22.559 --> 22:25.080 align:start position:0%
that the the uh the initial

22:25.080 --> 22:27.360 align:start position:0%
implementation supports two platforms it

22:27.360 --> 22:31.320 align:start position:0%


22:31.320 --> 22:33.840 align:start position:0%
windows Micosoft just

22:33.840 --> 22:36.120 align:start position:0%
kidding it supports all tier one

22:36.120 --> 22:37.600 align:start position:0%
platforms if you check it out right now

22:37.600 --> 22:39.559 align:start position:0%
on any of these it'll work in fact it

22:39.559 --> 22:41.520 align:start position:0%
supports all tier one and tier 2

22:41.520 --> 22:44.400 align:start position:0%
platforms right now um except power PC

22:44.400 --> 22:47.159 align:start position:0%
but we don't talk about

22:47.159 --> 22:50.320 align:start position:0%
that um but uh most notably since clang

22:50.320 --> 22:52.600 align:start position:0%
is such a great cross compiler uh the

22:52.600 --> 22:55.320 align:start position:0%
default cross compile setup just works

22:55.320 --> 22:56.760 align:start position:0%
perfectly um if you're doing cross

22:56.760 --> 22:59.120 align:start position:0%
compiles now don't change anything just

22:59.120 --> 23:02.559 align:start position:0%
install lbm 16 nearby um and your

23:02.559 --> 23:04.760 align:start position:0%
regular build your cross build whatever

23:04.760 --> 23:06.279 align:start position:0%
options you're passing to configure

23:06.279 --> 23:08.000 align:start position:0%
things just

23:08.000 --> 23:11.720 align:start position:0%
work and I think that's it so no

23:11.720 --> 23:16.510 align:start position:0%


23:16.510 --> 23:20.840 align:start position:0%


23:20.840 --> 23:24.120 align:start position:0%
you uh sorry

23:24.120 --> 23:27.440 align:start position:0%
Victor did you have a question okay yeah

23:27.440 --> 23:29.480 align:start position:0%
no I was to say how does it compare to

23:29.480 --> 23:32.039 align:start position:0%
number does it work with gpus uh how

23:32.039 --> 23:34.039 align:start position:0%
does it to compare in terms of speed

23:34.039 --> 23:36.159 align:start position:0%
yeah uh So currently it is no faster

23:36.159 --> 23:37.480 align:start position:0%
than main when you have this turned on

23:37.480 --> 23:39.880 align:start position:0%
but that represents a 5% improvement

23:39.880 --> 23:43.080 align:start position:0%
over the Micro Ops that it's based on um

23:43.080 --> 23:44.440 align:start position:0%
and we haven't done any of the fun

23:44.440 --> 23:48.120 align:start position:0%
tricks yet okay um so it's much slower

23:48.120 --> 23:51.520 align:start position:0%
than number um and what was the other

23:51.520 --> 23:55.760 align:start position:0%
question number a GPU support GPU

23:55.760 --> 23:58.559 align:start position:0%
support I would guess just as well as LM

23:58.559 --> 24:00.720 align:start position:0%
supports gpus so I I have I'm not doing

24:00.720 --> 24:04.200 align:start position:0%
anything special yeah they aren CPUs

24:04.200 --> 24:05.720 align:start position:0%
resources AR in the right place so it's

24:05.720 --> 24:07.760 align:start position:0%
we yeah it's nice because for things

24:07.760 --> 24:10.360 align:start position:0%
like platform support or more specific

24:10.360 --> 24:12.559 align:start position:0%
like Hardware integration we can just

24:12.559 --> 24:14.559 align:start position:0%
piggy back on LM so if there's a way to

24:14.559 --> 24:16.640 align:start position:0%
make lbm uh use the gpus more

24:16.640 --> 24:18.360 align:start position:0%
effectively then we can harness that too

24:18.360 --> 24:22.360 align:start position:0%
at least for that build yes okay

24:22.360 --> 24:25.520 align:start position:0%
yeah Victor the thing about container is

24:25.520 --> 24:36.039 align:start position:0%


24:36.039 --> 24:38.000 align:start position:0%
theats you don't you don't need the

24:38.000 --> 24:40.200 align:start position:0%
container so if you install the cross

24:40.200 --> 24:43.120 align:start position:0%
compiler tool chain um LM knows how to

24:43.120 --> 24:44.480 align:start position:0%
find that and you can just build them

24:44.480 --> 24:46.000 align:start position:0%
all because you you don't actually need

24:46.000 --> 24:48.360 align:start position:0%
to run anything for this he really wants

24:48.360 --> 24:50.559 align:start position:0%
to use a

24:50.559 --> 24:53.520 align:start position:0%
container when you ask people to install

24:53.520 --> 24:56.360 align:start position:0%
LM they get different flavor different

24:56.360 --> 24:59.200 align:start position:0%
FL and output can

24:59.200 --> 25:01.880 align:start position:0%
change config to put everything in

25:01.880 --> 25:04.799 align:start position:0%
container we know that you always get

25:04.799 --> 25:07.919 align:start position:0%
exactly the same yeah we that is

25:07.919 --> 25:09.480 align:start position:0%
definitely something important but again

25:09.480 --> 25:11.080 align:start position:0%
remember this also depends on configure

25:11.080 --> 25:14.520 align:start position:0%
flag so it's only as stable as those um

25:14.520 --> 25:17.720 align:start position:0%
also on top of that I I mean I have test

25:17.720 --> 25:20.200 align:start position:0%
I do have CI running this on all the

25:20.200 --> 25:24.120 align:start position:0%
platforms I listed there um and uh it's

25:24.120 --> 25:25.679 align:start position:0%
also tested against the full Matrix of

25:25.679 --> 25:28.799 align:start position:0%
LM 14 15 and 16 so for all three of

25:28.799 --> 25:31.200 align:start position:0%
those um I've verified that this passes

25:31.200 --> 25:32.679 align:start position:0%
the entire test

25:32.679 --> 25:36.399 align:start position:0%
Suite so are you going to checking

25:36.399 --> 25:38.679 align:start position:0%
this I have no plans

25:38.679 --> 25:40.960 align:start position:0%
to we

25:40.960 --> 25:42.880 align:start position:0%
should you can host a bunch of them

25:42.880 --> 25:45.440 align:start position:0%


25:45.440 --> 25:47.360 align:start position:0%
want like I'm not sure we're going to

25:47.360 --> 25:48.919 align:start position:0%
need a container basically it sounds

25:48.919 --> 25:52.000 align:start position:0%
like this is working on things

25:52.000 --> 25:55.399 align:start position:0%
syst get yeah and if you

25:55.399 --> 25:58.760 align:start position:0%
checking problem for people building

25:58.760 --> 26:01.520 align:start position:0%
and yeah people in this room probably

26:01.520 --> 26:04.559 align:start position:0%
not and if you check out my Branch too

26:04.559 --> 26:07.679 align:start position:0%
uh there's a read me in tools jit um it

26:07.679 --> 26:09.640 align:start position:0%
tells you how to install lvm on all

26:09.640 --> 26:11.360 align:start position:0%
platforms and again one thing I want to

26:11.360 --> 26:13.640 align:start position:0%
highlight is you don't need to build

26:13.640 --> 26:15.760 align:start position:0%
cpython itself with lovm or even the

26:15.760 --> 26:18.399 align:start position:0%
same version of lovm lovm is only used

26:18.399 --> 26:20.279 align:start position:0%
for just for generating that one header

26:20.279 --> 26:24.640 align:start position:0%
file um so when you get a t of python

26:24.640 --> 26:28.559 align:start position:0%
you don't need LM so it would be

26:28.559 --> 26:31.000 align:start position:0%
yes if if you want to build the jit yes

26:31.000 --> 26:32.919 align:start position:0%
um so I imagine this behind a configure

26:32.919 --> 26:36.840 align:start position:0%
flag um where I mean just just

26:36.840 --> 26:39.760 align:start position:0%
spitballing here um if you don't pass

26:39.760 --> 26:41.080 align:start position:0%
the configure flag and you don't have

26:41.080 --> 26:44.240 align:start position:0%
lovm installed um we don't do we just do

26:44.240 --> 26:47.080 align:start position:0%
a normal build if we smell that lovm is

26:47.080 --> 26:48.640 align:start position:0%
nearby but you didn't pass the flag we

26:48.640 --> 26:50.159 align:start position:0%
can say hey by the way you can build a

26:50.159 --> 26:52.000 align:start position:0%
jit if you want to and if you do pass

26:52.000 --> 26:55.039 align:start position:0%
the flag then we build the

26:55.039 --> 26:59.279 align:start position:0%
jit you can also leave work for fure of

26:59.279 --> 27:05.120 align:start position:0%


27:05.120 --> 27:09.000 align:start position:0%
comp just just that making that configur

27:09.000 --> 27:11.000 align:start position:0%
flag an optional thing is pretty much

27:11.000 --> 27:14.000 align:start position:0%
Essential for iOS because or or like web

27:14.000 --> 27:15.520 align:start position:0%
assembly for example or any of the list

27:15.520 --> 27:17.080 align:start position:0%
of tier three platforms that we

27:17.080 --> 27:20.240 align:start position:0%
absolutely can't build for

27:20.240 --> 27:23.640 align:start position:0%
yeah uh public sorry I should say names

27:23.640 --> 27:25.520 align:start position:0%
do you need any special

27:25.520 --> 27:28.679 align:start position:0%
like for mic like call that they has

27:28.679 --> 27:31.520 align:start position:0%
some protections

27:31.520 --> 27:35.120 align:start position:0%
like this is I mean jits work on Mac OS

27:35.120 --> 27:36.600 align:start position:0%
so you can't have you can't have

27:36.600 --> 27:38.240 align:start position:0%
writable executable memory and I think

27:38.240 --> 27:39.960 align:start position:0%
as of Sonoma you can't have readable

27:39.960 --> 27:42.320 align:start position:0%
executable memory um which is something

27:42.320 --> 27:44.039 align:start position:0%
I need to fix so this won't work on

27:44.039 --> 27:46.120 align:start position:0%
somoma because currently the memory is

27:46.120 --> 27:47.799 align:start position:0%
read execute but that's on my list of

27:47.799 --> 27:51.559 align:start position:0%
things to fix like do we need to like to

27:51.559 --> 27:53.960 align:start position:0%
change like the way we need to release

27:53.960 --> 27:56.120 align:start position:0%
this for like I I recall that there's a

27:56.120 --> 27:58.159 align:start position:0%
way to ask for it

27:58.159 --> 28:01.320 align:start position:0%
say when you map the memory you ask for

28:01.320 --> 28:05.720 align:start position:0%
the jit uh in the flags when you map the

28:05.720 --> 28:08.600 align:start position:0%
memory you can say map jit I think yeah

28:08.600 --> 28:11.640 align:start position:0%
yeah and that says I'm AIT I I think you

28:11.640 --> 28:13.080 align:start position:0%
may be referring to platform

28:13.080 --> 28:14.679 align:start position:0%
restrictions where you need to actually

28:14.679 --> 28:17.399 align:start position:0%
set the exe up speci before you even run

28:17.399 --> 28:21.440 align:start position:0%
it let me let me ref so when we the

28:21.440 --> 28:24.080 align:start position:0%
mic because I supp one that you compile

28:24.080 --> 28:28.399 align:start position:0%
is the same you compile right we need to

28:28.399 --> 28:30.840 align:start position:0%
like do you know if we need to set

28:30.840 --> 28:33.480 align:start position:0%
anything or ask if we do I don't know

28:33.480 --> 28:35.120 align:start position:0%
that we need to I'm not familiar with

28:35.120 --> 28:37.519 align:start position:0%
how we're actually building Mac OS

28:37.519 --> 28:39.760 align:start position:0%
releases differently from how I just

28:39.760 --> 28:41.880 align:start position:0%
build it locally um I can vouch for it

28:41.880 --> 28:44.080 align:start position:0%
working

28:44.080 --> 28:47.240 align:start position:0%
locally presumably the the release

28:47.240 --> 28:50.279 align:start position:0%
manager needs to use that flag yes if

28:50.279 --> 28:51.679 align:start position:0%
there's anything that needs to be done

28:51.679 --> 28:53.279 align:start position:0%
that sounds like the release manager

28:53.279 --> 28:58.000 align:start position:0%
should do it but I'm not aware of yeah

28:58.000 --> 29:00.960 align:start position:0%
it it very well could be the most the

29:00.960 --> 29:03.279 align:start position:0%
most of the sort of permissions stuff

29:03.279 --> 29:05.519 align:start position:0%
I've had to debug has been on Mac OS

29:05.519 --> 29:08.320 align:start position:0%
specifically M1 Mac

29:08.320 --> 29:10.880 align:start position:0%
yeah so it sounds like the Run

29:10.880 --> 29:13.000 align:start position:0%
generation is super fast yes why not

29:13.000 --> 29:17.000 align:start position:0%
just do this either for like tier one or

29:17.000 --> 29:21.039 align:start position:0%
I what number starts at interpret why

29:21.039 --> 29:23.360 align:start position:0%
only do this for tier two well we don't

29:23.360 --> 29:24.360 align:start position:0%
definitely don't want to do it for

29:24.360 --> 29:26.720 align:start position:0%
unspecialized bik code right because the

29:26.720 --> 29:28.519 align:start position:0%
specialized B code is uh where we're

29:28.519 --> 29:29.919 align:start position:0%
able to actually generate high quality

29:29.919 --> 29:32.080 align:start position:0%
code for um and the reason that we want

29:32.080 --> 29:33.960 align:start position:0%
to break it up into tier 2 code is

29:33.960 --> 29:36.039 align:start position:0%
because just by breaking it up we're not

29:36.039 --> 29:38.200 align:start position:0%
actually gaining anything right um if

29:38.200 --> 29:39.519 align:start position:0%
anything we're losing something because

29:39.519 --> 29:42.600 align:start position:0%
lvm is able to optimize less over the

29:42.600 --> 29:47.559 align:start position:0%
same context um but uh the kind of

29:47.559 --> 29:49.399 align:start position:0%
reason to build this on top of tier two

29:49.399 --> 29:51.080 align:start position:0%
is because ideally we're going to

29:51.080 --> 29:52.960 align:start position:0%
optimiz here to and Ken Jen will talk a

29:52.960 --> 29:54.679 align:start position:0%
little bit more about that um but if

29:54.679 --> 29:56.960 align:start position:0%
we're able to remove guards or reorder

29:56.960 --> 29:59.880 align:start position:0%
things or hoist guards or whatever um

29:59.880 --> 30:02.039 align:start position:0%
then this Builds on top of that um and

30:02.039 --> 30:03.399 align:start position:0%
so those guards won't be present in the

30:03.399 --> 30:05.919 align:start position:0%
generated machine code I get all that

30:05.919 --> 30:07.360 align:start position:0%
but like so the examples you're talking

30:07.360 --> 30:09.080 align:start position:0%
about that are already using this are

30:09.080 --> 30:10.960 align:start position:0%
using this for their Baseline right

30:10.960 --> 30:12.399 align:start position:0%
they're using this before any

30:12.399 --> 30:15.080 align:start position:0%
optimizations yes so wouldn't this be

30:15.080 --> 30:17.760 align:start position:0%
advantageous in the same use case for

30:17.760 --> 30:21.720 align:start position:0%
python it could be I haven't tried

30:21.720 --> 30:25.480 align:start position:0%
it we we currently can't translate every

30:25.480 --> 30:28.279 align:start position:0%
tier one by code corresonding sequence

30:28.279 --> 30:31.240 align:start position:0%
of tier two by codes although we have

30:31.240 --> 30:33.799 align:start position:0%
translate every tier one by code to copy

30:33.799 --> 30:35.799 align:start position:0%
and Patch no

30:35.799 --> 30:37.840 align:start position:0%
because needs to

30:37.840 --> 30:43.360 align:start position:0%
be simp we we we could it would just be

30:43.360 --> 30:45.399 align:start position:0%
different

30:45.399 --> 30:55.840 align:start position:0%


30:55.840 --> 30:58.120 align:start position:0%
ahead although have and we want

30:58.120 --> 31:00.039 align:start position:0%
effective profiling that gives us as

31:00.039 --> 31:01.720 align:start position:0%
well so theer

31:01.720 --> 31:04.120 align:start position:0%
oneu because we're effectively

31:04.120 --> 31:17.960 align:start position:0%


31:17.960 --> 31:26.159 align:start position:0%


31:26.159 --> 31:28.519 align:start position:0%
probably another thing too I I realized

31:28.519 --> 31:31.039 align:start position:0%
I didn't mention um the reason that the

31:31.039 --> 31:32.760 align:start position:0%
generated code is such high quality is

31:32.760 --> 31:35.399 align:start position:0%
because we don't care about uh like the

31:35.399 --> 31:36.720 align:start position:0%
compil times when we're actually

31:36.720 --> 31:38.279 align:start position:0%
building this thing so we pull out all

31:38.279 --> 31:39.960 align:start position:0%
the stops and tell lvm to optimize

31:39.960 --> 31:41.320 align:start position:0%
heavily um which is something you

31:41.320 --> 31:43.960 align:start position:0%
wouldn't want to do in a RI time jit yes

31:43.960 --> 31:46.639 align:start position:0%
when youate the machine

31:46.639 --> 31:51.960 align:start position:0%
code can you pass the equivalent to

31:51.960 --> 31:54.919 align:start position:0%
compile we're using

31:54.919 --> 32:00.240 align:start position:0%
clim yes yeah so uh we uh compile first

32:00.240 --> 32:02.559 align:start position:0%
using clang and that turns C code into

32:02.559 --> 32:06.080 align:start position:0%
llvm uh textual IR um the only reason we

32:06.080 --> 32:07.519 align:start position:0%
do that is because we want to fix up the

32:07.519 --> 32:08.960 align:start position:0%
calling convention and clang doesn't

32:08.960 --> 32:10.880 align:start position:0%
actually let let us have this calling

32:10.880 --> 32:12.880 align:start position:0%
convention from C so we fix up the

32:12.880 --> 32:15.720 align:start position:0%
calling convention using a hacky Rex

32:15.720 --> 32:17.639 align:start position:0%
replacement that will change in the

32:17.639 --> 32:21.120 align:start position:0%
future um and uh and then compile again

32:21.120 --> 32:24.240 align:start position:0%


32:24.240 --> 32:27.720 align:start position:0%
elf and you said it was under your or

32:27.720 --> 32:29.399 align:start position:0%
yeah yeah so my user brand Booker it's

32:29.399 --> 32:31.519 align:start position:0%
on my fory python the brand it's on the

32:31.519 --> 32:36.840 align:start position:0%


32:36.840 --> 32:38.840 align:start position:0%
yes uh that's the

32:38.840 --> 32:42.639 align:start position:0%
URL so it's the Justin branch of Bry P

32:42.639 --> 32:46.080 align:start position:0%
that's if you go to uh tools jit there's

32:46.080 --> 32:47.399 align:start position:0%
a read me in there that says how to

32:47.399 --> 32:49.480 align:start position:0%
install lvm

32:49.480 --> 32:51.880 align:start position:0%
sweet it's one a question of the general

32:51.880 --> 32:53.600 align:start position:0%
approach than the what you need so far

32:53.600 --> 32:55.480 align:start position:0%
but once you have a line of tra and you

32:55.480 --> 32:57.919 align:start position:0%
can have individual with this function

32:57.919 --> 33:00.519 align:start position:0%
another obvious things to try is to put

33:00.519 --> 33:02.799 align:start position:0%
all these calls into a cile compile it

33:02.799 --> 33:05.039 align:start position:0%
all together and see what happens yeah

33:05.039 --> 33:07.639 align:start position:0%
have you tried uh no but one thing the

33:07.639 --> 33:09.399 align:start position:0%
paper did have good success with is

33:09.399 --> 33:11.360 align:start position:0%
actually compiling super instructions uh

33:11.360 --> 33:14.480 align:start position:0%
for common pairs or triples because then

33:14.480 --> 33:17.440 align:start position:0%
it really allows lbm to optimize across

33:17.440 --> 33:19.559 align:start position:0%
um especially for for example like

33:19.559 --> 33:21.000 align:start position:0%
obvious things that we may want to look

33:21.000 --> 33:25.639 align:start position:0%
at are um when we so the Micro Ops are

33:25.639 --> 33:27.639 align:start position:0%
kind of expanded from a single

33:27.639 --> 33:30.039 align:start position:0%
instruction um I would imagine that in

33:30.039 --> 33:32.080 align:start position:0%
many cases we aren't able to optimize

33:32.080 --> 33:33.279 align:start position:0%
that very heavily and so it ends up

33:33.279 --> 33:34.600 align:start position:0%
being the equivalent of the original

33:34.600 --> 33:35.799 align:start position:0%
instruction so that'd be sort of low

33:35.799 --> 33:37.279 align:start position:0%
hanging fruit for things that we could

33:37.279 --> 33:39.600 align:start position:0%
compile and again when we're just

33:39.600 --> 33:42.039 align:start position:0%
walking over we can window over and see

33:42.039 --> 33:45.320 align:start position:0%
if we have anything that's entire

33:45.320 --> 33:47.880 align:start position:0%
X involve the compiler

33:47.880 --> 33:52.200 align:start position:0%
and exactly and and right now we have um

33:52.200 --> 33:56.559 align:start position:0%
like we have one uh template for every

33:56.559 --> 33:59.360 align:start position:0%
uh micro op so like 200 some odd

33:59.360 --> 34:01.639 align:start position:0%
templates um in the paper they generated

34:01.639 --> 34:04.720 align:start position:0%
as many as like 10,000 um combinations

34:04.720 --> 34:06.960 align:start position:0%
yes not only for combinations but also

34:06.960 --> 34:09.320 align:start position:0%
like for example if you have uh some

34:09.320 --> 34:12.560 align:start position:0%
instructions for example um CH the

34:12.560 --> 34:14.159 align:start position:0%
control flow changes based on the value

34:14.159 --> 34:16.919 align:start position:0%
of the opar so it may make sense to

34:16.919 --> 34:19.560 align:start position:0%
actually burn in values of the opar not

34:19.560 --> 34:22.040 align:start position:0%
actually at jit time but ahead of time

34:22.040 --> 34:23.760 align:start position:0%
where you hard code those values and LM

34:23.760 --> 34:25.480 align:start position:0%
can optimize based on them and the op AR

34:25.480 --> 34:28.159 align:start position:0%
is completely removed um then there's

34:28.159 --> 34:29.760 align:start position:0%
also super instructions and there

34:29.760 --> 34:31.760 align:start position:0%
there's all sorts of games you can play

34:31.760 --> 34:33.359 align:start position:0%
um another example would be if you're

34:33.359 --> 34:35.960 align:start position:0%
lifting things from uh stack items into

34:35.960 --> 34:39.399 align:start position:0%
registers um if you are kind of keeping

34:39.399 --> 34:41.359 align:start position:0%
that mapping of Stack items to registers

34:41.359 --> 34:42.760 align:start position:0%
you may want to compile variants for

34:42.760 --> 34:44.560 align:start position:0%
different stack sizes um so that you

34:44.560 --> 34:47.240 align:start position:0%
have a finite number of uh mappings but

34:47.240 --> 34:52.000 align:start position:0%


34:52.000 --> 34:55.879 align:start position:0%
simple Victor again so what is your

34:55.879 --> 34:58.760 align:start position:0%
proposal do you want to to match or do

34:58.760 --> 35:02.599 align:start position:0%


35:02.599 --> 35:04.920 align:start position:0%
mainside uh I I didn't really have a

35:04.920 --> 35:08.040 align:start position:0%
proposal today but basically if this is

35:08.040 --> 35:09.720 align:start position:0%
something people would like to see in

35:09.720 --> 35:12.560 align:start position:0%
main off by default um we can get it in

35:12.560 --> 35:14.560 align:start position:0%
main very easily I know we aren't crazy

35:14.560 --> 35:16.079 align:start position:0%
about experiments in Maine which is kind

35:16.079 --> 35:18.520 align:start position:0%
of why I'm floating the idea now if not

35:18.520 --> 35:19.880 align:start position:0%
uh this has been a long live Branch

35:19.880 --> 35:24.160 align:start position:0%
since like May um and so if if if it's

35:24.160 --> 35:25.960 align:start position:0%
any Testament to like how easy it is to

35:25.960 --> 35:27.880 align:start position:0%
maintain this stuff a lot of stuff has

35:27.880 --> 35:30.599 align:start position:0%
landed in Maine since May and uh keeping

35:30.599 --> 35:32.560 align:start position:0%
this Branch up to date and improving

35:32.560 --> 35:34.520 align:start position:0%
during that time has not been very

35:34.520 --> 35:38.839 align:start position:0%
difficult um Ken even borrowed uh he

35:38.839 --> 35:40.400 align:start position:0%
basically merged this Branch into his

35:40.400 --> 35:42.880 align:start position:0%
own Branch a while back when he was uh

35:42.880 --> 35:45.160 align:start position:0%
uh playing around with optimizing stuff

35:45.160 --> 35:46.599 align:start position:0%
and wanted to see what would happen if

35:46.599 --> 35:49.119 align:start position:0%
he jitted it Ken is it easy to like add

35:49.119 --> 35:51.520 align:start position:0%
new bite codes and work with the jit as

35:51.520 --> 35:56.000 align:start position:0%
a like a API this is a r question about

35:56.000 --> 35:57.680 align:start position:0%
yes

35:57.680 --> 36:00.560 align:start position:0%
um yeah the good thing is that you just

36:00.560 --> 36:02.640 align:start position:0%
need to install LM

36:02.640 --> 36:06.839 align:start position:0%
and uh the the script will automatically

36:06.839 --> 36:09.319 align:start position:0%
generate so you don't actually need to

36:09.319 --> 36:12.560 align:start position:0%
know how it works in the background yeah

36:12.560 --> 36:14.520 align:start position:0%
oh and because like you said at one time

36:14.520 --> 36:16.560 align:start position:0%
patching in is really simple so we

36:16.560 --> 36:18.000 align:start position:0%
actually had to modify the patching

36:18.000 --> 36:20.560 align:start position:0%
because our patches were of different

36:20.560 --> 36:24.119 align:start position:0%
types than L tracers but even then like

36:24.119 --> 36:25.400 align:start position:0%
the file is just a for Lo like you

36:25.400 --> 36:27.520 align:start position:0%
mentioned copy so really simple to

36:27.520 --> 36:30.400 align:start position:0%
multiply yeah the actual code that jits

36:30.400 --> 36:33.560 align:start position:0%
and copies and patches like of those 300

36:33.560 --> 36:37.280 align:start position:0%
lines of Fairly uh simple c um like the

36:37.280 --> 36:38.880 align:start position:0%
the hot Loop where we're actually just

36:38.880 --> 36:40.599 align:start position:0%
walking over stuff selecting stencils

36:40.599 --> 36:42.520 align:start position:0%
and patching stuff is like maybe 20

36:42.520 --> 36:44.920 align:start position:0%
lines of code um the rest is sort of

36:44.920 --> 36:47.599 align:start position:0%
like handling permissions on Windows and

36:47.599 --> 36:51.240 align:start position:0%
Mac and all that kind of fun is it

36:51.240 --> 36:54.560 align:start position:0%
possible to to maintain it outside

36:54.560 --> 36:57.680 align:start position:0%
python I mean just technically

36:57.680 --> 37:01.160 align:start position:0%
sense or is it is

37:01.160 --> 37:04.440 align:start position:0%
implementation of I would say that since

37:04.440 --> 37:06.119 align:start position:0%
we are using the same Micro Ops as tier

37:06.119 --> 37:09.119 align:start position:0%
2 um we're pretty tightly coupled to the

37:09.119 --> 37:10.780 align:start position:0%
implementation

37:10.780 --> 37:13.520 align:start position:0%
[Music]

37:13.520 --> 37:17.520 align:start position:0%
um um it could

37:17.520 --> 37:20.520 align:start position:0%
be um one thing that we would need so so

37:20.520 --> 37:25.280 align:start position:0%
when we actually uh compile the code um

37:25.280 --> 37:28.720 align:start position:0%
we basically in those header files if

37:28.720 --> 37:30.040 align:start position:0%
you have a bite code instruction that

37:30.040 --> 37:33.079 align:start position:0%
calls for example p number ad right

37:33.079 --> 37:34.760 align:start position:0%
that's a symbol that you need to link

37:34.760 --> 37:36.760 align:start position:0%
against um and so the way we do that in

37:36.760 --> 37:38.880 align:start position:0%
the header file is we actually just put

37:38.880 --> 37:41.599 align:start position:0%
address of p number ad as an addend for

37:41.599 --> 37:42.560 align:start position:0%
that uh

37:42.560 --> 37:45.599 align:start position:0%
relocation um that works for p number ad

37:45.599 --> 37:48.119 align:start position:0%
but if we were building this separately

37:48.119 --> 37:50.839 align:start position:0%
from cpython itself there's a lot of

37:50.839 --> 37:52.760 align:start position:0%
internal apis that would need to be

37:52.760 --> 37:54.400 align:start position:0%
exposed as public symbols in order for

37:54.400 --> 37:56.040 align:start position:0%
us to link them and actually linking

37:56.040 --> 37:57.800 align:start position:0%
them at run time would be a lot more

37:57.800 --> 38:00.280 align:start position:0%
complicated um we would first probably

38:00.280 --> 38:03.079 align:start position:0%
need to initialize all the stencils when

38:03.079 --> 38:04.760 align:start position:0%
the extension or whatever was first

38:04.760 --> 38:08.640 align:start position:0%
loaded by walking over and uh the

38:08.640 --> 38:10.640 align:start position:0%
stencils and actually resolving all of

38:10.640 --> 38:12.280 align:start position:0%
those symbols finding them in the

38:12.280 --> 38:15.160 align:start position:0%
current process uh with using dlm or

38:15.160 --> 38:17.119 align:start position:0%
whatever the windows equivalent is

38:17.119 --> 38:18.680 align:start position:0%
walking over them and actually fixing up

38:18.680 --> 38:21.720 align:start position:0%
those add-ins and then it would mostly

38:21.720 --> 38:25.359 align:start position:0%
be the same um but that sounds a lot

38:25.359 --> 38:27.599 align:start position:0%
more complicated than and I don't think

38:27.599 --> 38:29.119 align:start position:0%
we want to stick all that stuff as

38:29.119 --> 38:32.880 align:start position:0%
public symbols um so it is doable in

38:32.880 --> 38:34.680 align:start position:0%
theory I think the ergonomics make it

38:34.680 --> 38:37.839 align:start position:0%
like probably not the best option I'm

38:37.839 --> 38:41.440 align:start position:0%


38:41.440 --> 38:47.720 align:start position:0%


38:47.720 --> 38:49.520 align:start position:0%
examp

38:49.520 --> 38:52.839 align:start position:0%
okay don't build

38:52.839 --> 38:55.720 align:start position:0%
the or or I'll build it for you and I'll

38:55.720 --> 39:04.480 align:start position:0%


39:04.480 --> 39:06.359 align:start position:0%
that's behind the configur flag for now

39:06.359 --> 39:08.119 align:start position:0%
the answer to

39:08.119 --> 39:11.440 align:start position:0%
that unknown this very useful find way

39:11.440 --> 39:13.760 align:start position:0%
forward to actually do it you you can't

39:13.760 --> 39:16.079 align:start position:0%
at the same time say that you want the

39:16.079 --> 39:19.160 align:start position:0%
jit and say that you

39:19.160 --> 39:22.400 align:start position:0%
cannot have this dependency right this

39:22.400 --> 39:25.079 align:start position:0%


39:25.079 --> 39:28.640 align:start position:0%
want I want million we can we all want

39:28.640 --> 39:31.119 align:start position:0%
things I get

39:31.119 --> 39:36.000 align:start position:0%
it y did you have your hand up yeah so

39:36.000 --> 39:37.520 align:start position:0%
as far as I understand there's pretty

39:37.520 --> 39:39.160 align:start position:0%
much no alternative to this like if you

39:39.160 --> 39:41.880 align:start position:0%
want to go with the it's either us

39:41.880 --> 39:44.800 align:start position:0%
spending a lot of resources handwriting

39:44.800 --> 39:48.040 align:start position:0%


39:48.040 --> 39:50.680 align:start position:0%
uh handwriting all of this kind of code

39:50.680 --> 39:53.280 align:start position:0%
pass generating them uh which is one of

39:53.280 --> 39:55.040 align:start position:0%
the hardest parts of the gy like this is

39:55.040 --> 39:58.520 align:start position:0%
a nice to a lot of

39:58.520 --> 40:02.200 align:start position:0%
resour it seems like the plan should be

40:02.200 --> 40:09.240 align:start position:0%


40:09.240 --> 40:11.440 align:start position:0%
main am

40:11.440 --> 40:15.560 align:start position:0%
I no that's how I feel as well um and

40:15.560 --> 40:17.400 align:start position:0%
and another thing too just since you

40:17.400 --> 40:19.319 align:start position:0%
mentioned handwriting assembly is that

40:19.319 --> 40:21.000 align:start position:0%
the two are not mutually exclusive so

40:21.000 --> 40:22.640 align:start position:0%
for example if we see that there's a

40:22.640 --> 40:25.119 align:start position:0%
really common op code and we see that we

40:25.119 --> 40:27.720 align:start position:0%
can actually write better than LM can

40:27.720 --> 40:30.040 align:start position:0%
for whatever reason we can do that the

40:30.040 --> 40:31.720 align:start position:0%
the two play very nicely together so it

40:31.720 --> 40:34.440 align:start position:0%
just be in that build script uh the 700

40:34.440 --> 40:36.160 align:start position:0%
lines of python or whatever we just

40:36.160 --> 40:37.480 align:start position:0%
special case that off code and say hey

40:37.480 --> 40:39.920 align:start position:0%
use this assembly file instead yeah Qui

40:39.920 --> 40:41.599 align:start position:0%
question P question on the on the

40:41.599 --> 40:43.359 align:start position:0%
Benchmark numbers that you show one of

40:43.359 --> 40:45.800 align:start position:0%
the slid so basically what they did they

40:45.800 --> 40:48.480 align:start position:0%
just repl so for example in the case of

40:48.480 --> 40:53.560 align:start position:0%
compil they just replaced the G uh Cod

40:53.560 --> 40:56.800 align:start position:0%
assembly and what not where the stop

40:56.800 --> 40:58.640 align:start position:0%
this

40:58.640 --> 41:02.440 align:start position:0%
appro no it was a completely uh like new

41:02.440 --> 41:04.480 align:start position:0%
implementation that they wrote so if you

41:04.480 --> 41:06.160 align:start position:0%
go to the blog post that I linked to

41:06.160 --> 41:09.520 align:start position:0%
earlier um it's a nice long blog post if

41:09.520 --> 41:10.680 align:start position:0%
you don't know anything about jits

41:10.680 --> 41:12.400 align:start position:0%
you'll know how jits work after reading

41:12.400 --> 41:14.520 align:start position:0%
it um and it goes over copy and patch

41:14.520 --> 41:16.119 align:start position:0%
and also things like inline caching and

41:16.119 --> 41:18.359 align:start position:0%
whatever but it's basically him

41:18.359 --> 41:22.400 align:start position:0%
implementing a Lua uh jit okay right and

41:22.400 --> 41:25.880 align:start position:0%
and so it's the so that yeah yeah so so

41:25.880 --> 41:28.160 align:start position:0%
it's it's the comparison of his just

41:28.160 --> 41:30.200 align:start position:0%
from scratch implementation versus an

41:30.200 --> 41:33.000 align:start position:0%
established fast

41:33.000 --> 41:36.800 align:start position:0%
implementation what is that I can put it

41:36.800 --> 41:38.119 align:start position:0%
back up

41:38.119 --> 41:41.040 align:start position:0%
there you could probably find it just by

41:41.040 --> 41:44.000 align:start position:0%
Google for a c yeah if you if you if you

41:44.000 --> 41:46.400 align:start position:0%
search for oh wait did I skip it already

41:46.400 --> 41:49.440 align:start position:0%
hang on I never saw the link to the blog

41:49.440 --> 41:53.599 align:start position:0%
post uh it was underneath the paper it's

41:53.599 --> 41:55.240 align:start position:0%
right

41:55.240 --> 41:59.880 align:start position:0%
here you haven't linked the che that yes

41:59.880 --> 42:04.079 align:start position:0%
I should indeed so the uh the top one is

42:04.079 --> 42:07.599 align:start position:0%
the paper the bottom one is the blog

42:07.599 --> 42:11.200 align:start position:0%
post and I just posted they did a

42:11.200 --> 42:14.440 align:start position:0%
presentation a few months ago as well

42:14.440 --> 42:17.200 align:start position:0%
was that for the paper good slides yeah

42:17.200 --> 42:18.760 align:start position:0%
and just as an

42:18.760 --> 42:21.400 align:start position:0%
FYI like that may be a new paper but we

42:21.400 --> 42:23.079 align:start position:0%
were doing this type of approach for a

42:23.079 --> 42:25.160 align:start position:0%
translator transmeta 20 years ago and I

42:25.160 --> 42:27.599 align:start position:0%
doubt we were the this but templates

42:27.599 --> 42:31.559 align:start position:0%
from regular yeah are very fast to yeah

42:31.559 --> 42:34.640 align:start position:0%
how was your experience with it I sh in

42:34.640 --> 42:40.319 align:start position:0%


42:40.319 --> 42:43.359 align:start position:0%
intermediate yeah I mean it is I kind of

42:43.359 --> 42:46.720 align:start position:0%
view this as a like a baseline but a

42:46.720 --> 42:48.880 align:start position:0%
really good one yeah right and so if we

42:48.880 --> 42:50.559 align:start position:0%
wanted to have another tier where we

42:50.559 --> 42:52.000 align:start position:0%
pull out all the stops on top of this

42:52.000 --> 42:54.119 align:start position:0%
that's a bridge we could cross right

42:54.119 --> 42:56.520 align:start position:0%
this is easy to maintain you don't have

42:56.520 --> 43:02.000 align:start position:0%


43:02.000 --> 43:04.359 align:start position:0%
was another question in terms of the Cod

43:04.359 --> 43:07.319 align:start position:0%
style will will you need to change a lot

43:07.319 --> 43:09.040 align:start position:0%
like I know that you compile some of the

43:09.040 --> 43:12.359 align:start position:0%
functions already but will the Cod style

43:12.359 --> 43:18.839 align:start position:0%


43:18.839 --> 43:22.319 align:start position:0%
same when you say the code style so we

43:22.319 --> 43:25.079 align:start position:0%
extract so basically the way you write

43:25.079 --> 43:29.559 align:start position:0%
code py code

43:29.559 --> 43:32.040 align:start position:0%
yes I'm I'm sure you'll see lots of blog

43:32.040 --> 43:33.960 align:start position:0%
posts of how to get the most out of C

43:33.960 --> 43:37.040 align:start position:0%
Python's new jit you know but those are

43:37.040 --> 43:42.359 align:start position:0%


43:42.359 --> 43:46.839 align:start position:0%


43:46.839 --> 43:49.359 align:start position:0%
yeah I I don't think it'll be any

43:49.359 --> 43:50.680 align:start position:0%
different than the specializing

43:50.680 --> 43:52.640 align:start position:0%
interpreter where it's just we play to

43:52.640 --> 43:54.480 align:start position:0%
the benchmarks the benchmarks we take to

43:54.480 --> 43:56.839 align:start position:0%
be somewhat realistic and we look to

43:56.839 --> 43:59.680 align:start position:0%
confirm that that is true in practice

43:59.680 --> 44:01.880 align:start position:0%
right um and I'm sure that there are

44:01.880 --> 44:04.960 align:start position:0%
people who you know like try to optimize

44:04.960 --> 44:06.640 align:start position:0%
for the specializing interpreter and I'm

44:06.640 --> 44:07.680 align:start position:0%
sure there'll be people who try to

44:07.680 --> 44:09.720 align:start position:0%
optimize for this but I think in general

44:09.720 --> 44:11.280 align:start position:0%
it'll just be a good low overhead way of

44:11.280 --> 44:15.920 align:start position:0%


44:15.920 --> 44:21.000 align:start position:0%
world we already I want everyone discuss

44:21.000 --> 44:24.920 align:start position:0%
so what is theing situation of this like

44:24.920 --> 44:26.520 align:start position:0%
for one of

44:26.520 --> 44:30.440 align:start position:0%


44:30.440 --> 44:40.760 align:start position:0%


44:40.760 --> 44:44.559 align:start position:0%
to yeah um so I don't know enough about

44:44.559 --> 44:46.440 align:start position:0%
unwind tables and that and like dwarf

44:46.440 --> 44:48.440 align:start position:0%
and all of that to give a good answer I

44:48.440 --> 44:50.520 align:start position:0%
can tell you that I don't include any

44:50.520 --> 44:52.559 align:start position:0%
unwind tables or dwarf in the jitted

44:52.559 --> 44:55.680 align:start position:0%
code and we disable frame pointers but

44:55.680 --> 44:56.680 align:start position:0%
if it's it's something that could be

44:56.680 --> 44:59.160 align:start position:0%
reused from the original elf um then

44:59.160 --> 45:00.280 align:start position:0%
that's something that would be easy to

45:00.280 --> 45:02.280 align:start position:0%
harvest uh otherwise we would have to

45:02.280 --> 45:04.920 align:start position:0%
kind of emit it ourselves when way will

45:04.920 --> 45:07.440 align:start position:0%
be maybe to May at the beginning when I

45:07.440 --> 45:10.040 align:start position:0%
mean at the beginning maybe when we are

45:10.040 --> 45:12.760 align:start position:0%
playing with maybe a che way is to allow

45:12.760 --> 45:15.359 align:start position:0%
at least to or detect if you're building

45:15.359 --> 45:17.040 align:start position:0%
python itself with frame pointers and

45:17.040 --> 45:18.800 align:start position:0%
then generating the template with frame

45:18.800 --> 45:21.920 align:start position:0%
pointers yeah I assume going to copy

45:21.920 --> 45:24.000 align:start position:0%
one yeah so we're disabling frame

45:24.000 --> 45:25.400 align:start position:0%
pointers right now just because we're

45:25.400 --> 45:26.960 align:start position:0%
passing argument registers and that's a

45:26.960 --> 45:29.079 align:start position:0%
valuable register um but I mean this

45:29.079 --> 45:30.520 align:start position:0%
argument's been had a million times so

45:30.520 --> 45:33.079 align:start position:0%
we can build with frame pointers you

45:33.079 --> 45:34.880 align:start position:0%
know it's easy enough just to say don't

45:34.880 --> 45:37.440 align:start position:0%
use that register right um and so that

45:37.440 --> 45:40.559 align:start position:0%
could be the first step and then again I

45:40.559 --> 45:41.960 align:start position:0%
I would need to do more research if I

45:41.960 --> 45:43.680 align:start position:0%
were to do it myself well at least

45:43.680 --> 45:47.440 align:start position:0%
having aouch I think a first kind of

45:47.440 --> 45:49.960 align:start position:0%
line

45:49.960 --> 45:54.880 align:start position:0%
cheap useful in you

45:54.880 --> 45:59.520 align:start position:0%


45:59.520 --> 46:04.200 align:start position:0%
side yeah if we were extract like if we

46:04.200 --> 46:06.760 align:start position:0%
could just extract all of this stuff

46:06.760 --> 46:09.079 align:start position:0%
from the elf file is that something that

46:09.079 --> 46:11.680 align:start position:0%
could be reused or would need to be

46:11.680 --> 46:13.720 align:start position:0%
different every time we emit a copy of

46:13.720 --> 46:17.240 align:start position:0%
that stencil you would need toch the

46:17.240 --> 46:18.839 align:start position:0%
relocations as well so there's

46:18.839 --> 46:22.440 align:start position:0%
relocations in the like the unwind

46:22.440 --> 46:24.839 align:start position:0%
tables and stuff the has like what is

46:24.839 --> 46:27.440 align:start position:0%
called and those will change when you

46:27.440 --> 46:29.319 align:start position:0%
place the code in different places so

46:29.319 --> 46:32.319 align:start position:0%
you need to somehow say oh this this

46:32.319 --> 46:36.040 align:start position:0%
code now Lees here so you need to say

46:36.040 --> 46:38.800 align:start position:0%
address things but most of the Annoying

46:38.800 --> 46:41.000 align:start position:0%
stuff to generate you can just copy okay

46:41.000 --> 46:42.960 align:start position:0%
yeah if it's if it's anything like the

46:42.960 --> 46:46.280 align:start position:0%
mechanics of extracting like for example

46:46.280 --> 46:50.559 align:start position:0%
static data BSS data executable text and

46:50.559 --> 46:52.160 align:start position:0%
processing relocations on those then the

46:52.160 --> 46:53.640 align:start position:0%
mechanics are almost identical it sounds

46:53.640 --> 46:54.800 align:start position:0%
like depends on

46:54.800 --> 46:59.079 align:start position:0%
how it to retri it from the file but if

46:59.079 --> 47:02.800 align:start position:0%
very easy and have some outut I suppose

47:02.800 --> 47:04.559 align:start position:0%
yeah like not like something that I

47:04.559 --> 47:07.000 align:start position:0%
think is super super important yeah two

47:07.000 --> 47:09.040 align:start position:0%
flags that I passed to clang currently

47:09.040 --> 47:11.800 align:start position:0%
are omit frame pointer and no

47:11.800 --> 47:16.160 align:start position:0%
asynchronous on wine tables um so if if

47:16.160 --> 47:18.040 align:start position:0%
we if if that's the sort of stuff that

47:18.040 --> 47:19.520 align:start position:0%
just gets dumped in the AL file and is

47:19.520 --> 47:21.440 align:start position:0%
reusable then it sounds like we have a

47:21.440 --> 47:22.920 align:start position:0%
promising path forward for a good

47:22.920 --> 47:24.720 align:start position:0%
debugging

47:24.720 --> 47:28.440 align:start position:0%


47:28.440 --> 47:34.359 align:start position:0%


47:34.359 --> 47:37.079 align:start position:0%
lot oh I didn't see I think we're

47:37.079 --> 47:40.880 align:start position:0%
getting too much into implementation

47:40.880 --> 47:48.559 align:start position:0%

